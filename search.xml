<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>赛博硬币</title>
      <link href="/2024/cyber-coin/"/>
      <url>/2024/cyber-coin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为什么我们需要硬币？</p></blockquote><span id="more"></span><p>一个人确实需要硬币来帮自己做决定。</p><p>不一定是因为硬币可以帮忙做出选择，而是因为<strong>在硬币升空的一瞬间，你常常就知道了自己想选的是哪一个</strong>。</p><hr><p>最近新换了 fish。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span> 2 &amp;&amp; math (<span class="built_in">dd</span> <span class="keyword">if</span>=/dev/random bs=1 count=1 2&gt;/dev/null | <span class="built_in">od</span> -An -vtu1) % 2</span><br></pre></td></tr></table></figure><p>按下 ^C，<strong>把还没落地的硬币一把抓回手里</strong>。</p><hr><p>如果你在用 zsh 或者 bash：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span> 2 &amp;&amp; <span class="built_in">echo</span> $(( $(dd if=/dev/random bs=<span class="number">1</span> count=<span class="number">1</span> <span class="number">2</span>&gt;/dev/null | od -An -vtu1) % <span class="number">2</span> ))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 复习</title>
      <link href="/2023/CSAPP-%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/CSAPP-%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>hexo 渲染这个页面有问题。请参见 <a href="/files/html/CSAPP-review.html">csapp-review.html</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>周行 2022 新春码拉松部分题解</title>
      <link href="/2022/ZXOJ2022Spring/"/>
      <url>/2022/ZXOJ2022Spring/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><!-- 写这玩意纯属是闲着没事 + 想要奖品。 --><span id="more"></span><h3 id="1-4-完美，近乎完美"><a href="#1-4-完美，近乎完美" class="headerlink" title="1-4 完美，近乎完美"></a><a href="http://47.102.108.97/contest/6/problem/4">1-4 完美，近乎完美</a></h3><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><p>给定一个大小为 $n \ (2 \le n \le 2 \times 10^5)$ 的可重集合，询问删去集合中的哪些元素后，集合中存在一个元素等于其余所有元素的和。集合中元素有值域 $[1, 10^6]$。</p><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>集合中存在一个元素等于其他元素的和，当且仅当该元素的大小等于集合中所有元素的和的 $\dfrac 12$。于是可以处理出</p><ol><li>集合中所有元素的和 $s$；</li><li>值域中每个数字在集合中出现的次数和位置。</li></ol><p>枚举每个元素 $x$，判断删去该元素后是否仍存在某个元素等于 $s - x$ 即可。</p><p>时间复杂度 $O(n)$。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>注意需要 C++17。</p><p><code>s: int64</code>  即前述的 $s$，<code>v[i]: std::vector&lt;int&gt;</code> 记录 $i$ 出现的所有位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">200003</span>];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ans, v[<span class="number">1000003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">  <span class="keyword">int64_t</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; z[i];</span><br><span class="line">    s += z[i];</span><br><span class="line">    <span class="comment">// 这里判一下 if (v[z[i]].size &gt; 1) 则不 push 也是可以的，但没必要</span></span><br><span class="line">    v[z[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int64_t</span> x = s - z[i]; x &lt;= <span class="number">2000000</span> &amp;&amp; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (v[x / <span class="number">2</span>].<span class="built_in">size</span>() &gt; <span class="number">1</span> || (v[x / <span class="number">2</span>].<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; v[x / <span class="number">2</span>][<span class="number">0</span>] != i))</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(i);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (ans.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : ans)</span><br><span class="line">      std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="1-5-回文，排版错误"><a href="#1-5-回文，排版错误" class="headerlink" title="1-5 回文，排版错误"></a><a href="http://47.102.108.97/contest/6/problem/5">1-5 回文，排版错误</a></h3><h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h4><p>给定 $n \ (1 \le n \le 100)$ 个长度均为 $m \ (1 \le m \le 50)$ 的字符串 $s_i$。判断这些字符串拼接而成的最长的回文串 $P$ 的长度。字符集小写拉丁字母。字符串不能重复使用。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>所有字符串长度都相等实在是很强的约束条件，不然这题就太毒了。</p><p>考虑一个字符串 $s$ 能够参与拼接进 $P$，当且仅当 $s$</p><ol><li><p>本身是回文串，或</p></li><li><p>给定了另一个字符串 $t$ 使得 $s + t$ 是回文串（此处 $+$ 表示字符串的拼接操作，显然这时 $t + s$ 也是回文串）</p></li></ol><p>满足性质 1 的串 $s$ 可以置于 $P$ 的中心，而满足性质 2 的串 $s, t$ 可以对称地置于 $P$ 中心的两侧。为了最大化 $|P|$，当一个串 $s$ 同时满足两个性质时，优先按照性质 2 参与拼接。并且可以发现，至多只能有一个只满足性质 1 的串参与构造 $P$。</p><p>于是可以预处理出每个字符串是否满足以上两个性质，并据此构造 $P$，实现细节见代码。总复杂度 $O(n^2 m)$。</p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><p>注意需要 C++11。</p><p><code>v1[i]: bool</code> 即字符串 $s_i$ 满足性质 1 与否；<code>v2[i]</code> 中的所有元素 $x$ 表示 $s_i, s_x$ 满足性质 2。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isPalin</span><span class="params">(<span class="keyword">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Returns if $s is a palindrome</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">std::string <span class="title">t</span><span class="params">(s)</span></span>;</span><br><span class="line">  std::<span class="built_in">reverse</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> t == s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string s[<span class="number">103</span>];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v2[<span class="number">103</span>];</span><br><span class="line"><span class="keyword">bool</span> v1[<span class="number">103</span>], used[<span class="number">103</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    std::cin &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    v1[i] = <span class="built_in">isPalin</span>(s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isPalin</span>(s[i] + s[j])) &#123;</span><br><span class="line">        v2[i].<span class="built_in">emplace_back</span>(j);</span><br><span class="line">        v2[j].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string ans1, ans2;</span><br><span class="line">  <span class="comment">// 性质 2</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (v2[i].<span class="built_in">size</span>())</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j : v2[i])</span><br><span class="line">        <span class="keyword">if</span> (!used[j]) &#123;</span><br><span class="line">          ans1 += s[i];</span><br><span class="line">          ans2 = s[j] + ans2;</span><br><span class="line">          used[i] = used[j] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">// 性质 1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (v1[i] &amp;&amp; !used[i]) &#123;</span><br><span class="line">      ans1 += s[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  std::string ans = ans1 + ans2;</span><br><span class="line">  std::cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (ans.<span class="built_in">size</span>())</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="1-9-睁眼，便是终局-amp-2-7-睁眼，便是终局"><a href="#1-9-睁眼，便是终局-amp-2-7-睁眼，便是终局" class="headerlink" title="1-9 睁眼，便是终局 &amp; 2-7 睁眼，便是终局"></a><a href="http://47.102.108.97/contest/6/problem/9">1-9 睁眼，便是终局</a> &amp; <a href="http://47.102.108.97/contest/7/problem/7">2-7 睁眼，便是终局</a></h3><h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h4><p>给定长为 $n$ 的数列 $\{ a_i \} \ (1 \le a_i \le 10^9)$，在其中选中 $x$ 个数字，且连续 $k$ 个数字中至少有一个被选中，最大化选中的所有数字的和。</p><p>Constraint of Easy Version(1-9): $1 \le k, x, n \le 200$​；</p><p>Constraint of Hard Version(2-7): $1 \le k, x, n \le 5000$；</p><h4 id="solution-for-Easy-Version"><a href="#solution-for-Easy-Version" class="headerlink" title="solution for Easy Version"></a>solution for Easy Version</h4><p>经典 dp（</p><p>设 $f_{i, j}$ 表示前 $i$ 个数字中选中了 $j$ 个数字，且第 $i$ 个数字被选中的答案。有显然的转移：</p><script type="math/tex; mode=display">f_{i, j} = \max_{k' = i - k + 1}^{i - 1}{f_{k', j - 1} + a_i}</script><p>边界条件 $f_{i, j} = - \infty, f_{0, 0} = 0$。</p><p>时间复杂度 $O(nxk)$；空间复杂度 $O(nx)$，可以压一维到 $O(n)$，不过没必要，毕竟时间复杂度摆在那。</p><h4 id="code-for-Easy-Version"><a href="#code-for-Easy-Version" class="headerlink" title="code for Easy Version"></a>code for Easy Version</h4><p><code>f[i][j]</code> 即前述的 $f_{i, j}$。这里用了 $-1$ 标记 $-\infty$，这样恰好把无解输出 <code>-1</code> 处理掉了，不用单独再判。注意一下写法问题别越界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">203</span>];</span><br><span class="line"><span class="keyword">int64_t</span> f[<span class="number">203</span>][<span class="number">203</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, K, X;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; N &gt;&gt; K &gt;&gt; X;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    std::cin &gt;&gt; z[i];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) <span class="comment">// 这里 j &lt;= min(i, X) 就可以</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= std::<span class="built_in">max</span>(<span class="number">0</span>, i - K); --k) <span class="comment">// 这里正着或反着枚举是无所谓的</span></span><br><span class="line">        <span class="keyword">if</span> (f[k][j - <span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">          f[i][j] = std::<span class="built_in">max</span>(f[i][j], f[k][j - <span class="number">1</span>] + z[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int64_t</span> ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = N - K + <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    ans = std::<span class="built_in">max</span>(ans, f[i][X]);</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="solution-for-Hard-Version"><a href="#solution-for-Hard-Version" class="headerlink" title="solution for Hard Version"></a>solution for Hard Version</h4><p>我这个状态数只有 $O(nx)$ 个啊，干啥要 $O(nxk)$ 的复杂度呢？</p><p>如果固定一个 $j$，枚举每个 $i$，就会发现枚举转移的时候内层的两维（对于每个 $i$ 枚举 $k’$ 求 $\max f_{k’, j - 1}$）和 $i$ 无关，非常的滑动窗口，于是单调队列优化转移，时间复杂度降到了 $O(nx)$。</p><p>空间也可以压到 $O(n)$，但是同上没有必要。</p><p>参考题目：<a href="https://www.luogu.com.cn/problem/P1886">洛谷 P1886 滑动窗口 /【模板】单调队列</a></p><h4 id="code-for-Hard-Version"><a href="#code-for-Hard-Version" class="headerlink" title="code for Hard Version"></a>code for Hard Version</h4><p><code>f[i][j]</code> 即前述的 $f_{j, i}$。注意两维在思考优化的过程中反过来了，于是代码里顺手也反过来写了。</p><p>这里用了 $-1$ 标记 $-\infty$，这样恰好把无解输出 <code>-1</code> 处理掉了，不用单独再判。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">5003</span>];</span><br><span class="line"><span class="keyword">int64_t</span> f[<span class="number">5003</span>][<span class="number">5003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, K, X;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; N &gt;&gt; K &gt;&gt; X;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    std::cin &gt;&gt; z[i];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= X; ++j) &#123;</span><br><span class="line">    std::deque&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int64_t</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, now = std::<span class="built_in">max</span>(<span class="number">0</span>, i - K); i &lt;= N; ++i) &#123;</span><br><span class="line">      <span class="comment">// k \in [max(0, i - K), i - 1]</span></span><br><span class="line">      <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">front</span>().first &lt; i - K)</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (; now &lt; i; ++now)</span><br><span class="line">        <span class="keyword">if</span> (f[j - <span class="number">1</span>][now] != <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">back</span>().second &lt;= f[j - <span class="number">1</span>][now])</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">          q.<span class="built_in">push_back</span>(&#123;now, f[j - <span class="number">1</span>][now]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        f[j][i] = std::<span class="built_in">max</span>(f[j][i], q.<span class="built_in">front</span>().second + z[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; *std::<span class="built_in">max_element</span>(f[X] + N - K + <span class="number">1</span>, f[X] + N + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="1-10-尾声，抑或开始-amp-2-8-残页，封存往事"><a href="#1-10-尾声，抑或开始-amp-2-8-残页，封存往事" class="headerlink" title="1-10 尾声，抑或开始 &amp; 2-8 残页，封存往事"></a><a href="http://47.102.108.97/contest/6/problem/10">1-10 尾声，抑或开始</a> &amp; <a href="http://47.102.108.97/contest/7/problem/8">2-8 残页，封存往事</a></h3><h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem"></a>problem</h4><p>给定一个长为 $n \ (1 \le n \le 2 \times 10^5)$ 的序列 $\{ a_i \} \ (1 \le a_i \le 2 \times 10^5)$ 和一个值 $m \ (1 \le m \le 2 \times 10^5)$。询问序列中有多少子序列（连续）的<strong>中位数</strong>是 $m$。</p><p>此处<strong>中位数</strong>的定义和数学上略有不同。区别在于对于长度为偶数 $2k$ 的子序列，定义中位数为第 $k$ 小的数。例如序列 $[1, 1, 4, 5, 1, 4]$ 的中位数为第 $3$ 小的 $1$，而非数学上的 $\dfrac{1 + 4}2 = \dfrac 52$。</p><p>Extra Constraint for Easy Version: 保证序列 $\{ a_i \}$ 为整数 $1 \sim n$ 的一个排列。</p><h4 id="solution-for-Easy-Version-1"><a href="#solution-for-Easy-Version-1" class="headerlink" title="solution for Easy Version"></a>solution for Easy Version</h4><p>感性理解一下就会发现，我们其实只需要每个数之间的偏序关系，而不需要它们具体的值。</p><p>Easy Version 保证了序列是一个排列，也就是说，所有的值都是两两不同的。这时我们可以套路性地将原排列中小于 $m$ 的数、$m$、大于 $m$ 的数分别重新映射为 $-1, 0, 1$。然后从原排列的 $m$ 的位置开始，向左做后缀和，并记录每个后缀和 $s$ 出现的次数 $c_s$。然后再向右做前缀和，这样，当枚举到下标 $i$ 时，前缀和为 $s$ 时，$c_{-s}$ 和 $c_{1 - s}$ 即为以位置 $i$ 为右端点的符合条件的区间的个数，且两者分别为区间长度为奇数、偶数时的个数。</p><p>这个做法非常容易想，但是只看文字描述是很难以理解的。这里以样例 1 的 reverse (maybe it should be called reversal?) 作为<strong>例子</strong>：</p><ul><li>我们有 $1 \sim 5$ 的一个排列 $[1, 3, 5, 4, 2]$。</li><li>从 $m = 4$ 所在的下标 $4$ 向左做后缀和，得到 $[-1, 0, 1, 0, \mathrm{NaN}]$。</li><li>于是我们得到 $c_{-1} = 1, c_0 = 2, c_1 = 1$，对于其余的 $s$ 值，$c_s$ 均为 $0$。</li><li>接着我们从下标 $4$ 向右做前缀和。在下标 $4$ 处 $s = 0$，此时 $c_{-s} = c_0= 2, c_{1 - s} = c_1 = 1$。在下标 $5$ 处 $s = -1$，此时 $c_{-s} = c_1 = 1, c_{1 - s} = c_2 = 0$。</li><li>把上述提到的值全部相加得到答案 $4$。（感性理解一下样例 1 的 reverse 和样例 1 的答案肯定是相同的）</li></ul><p>时空复杂度均为 $O(n)$。</p><h4 id="code-for-Easy-Version-1"><a href="#code-for-Easy-Version-1" class="headerlink" title="code for Easy Version"></a>code for Easy Version</h4><p>变量名和上述除大小写外完全相同。</p><p>这里用了很骚的写法，给下标传了负数。注意实际上 <code>c</code> 是 <code>int *</code> 而不是 <code>int[]</code>，<code>c[-s]</code> 相当于 <code>*(c + (-s))</code>，只要没有发生越界就没有问题。<strong>向数组名的 <code>operator[]</code> 中传递负下标是未定义行为。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">200003</span>], c_[<span class="number">400007</span>], *c = c_ + <span class="number">200003</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, M, p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= N; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> (x == M) p = i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; M) z[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> z[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = p, s = <span class="number">0</span>; i; --i) &#123;</span><br><span class="line">    s += z[i];</span><br><span class="line">    ++c[s];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int64_t</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = p, s = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    s += z[i];</span><br><span class="line">    ans += c[-s];</span><br><span class="line">    ans += c[<span class="number">1</span> - s];</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="solution-for-Hard-Version-1"><a href="#solution-for-Hard-Version-1" class="headerlink" title="solution for Hard Version"></a>solution for Hard Version</h4><p>很不幸，如果按照上面的思考方法，那么这题的 Hard Version 将会变得非常难想。</p><p><em>首先提一下 Easy Version 的上述做法在这里是错的：其一，Hard version 可能存在不止一个 $m$，因此上述做法变得难以扩展；其二，即使强行找到方法 $O(n)$ 地扩展，其赖以正确的约束条件「$\{a_n\}$ 中的每两个数都存在严格的偏序关系」 不成立，它的正确性会出问题。这里不作更多说明。</em></p><p>Hard Version 用到了另一个思想：把求值转化为求前缀和的差分。这句话看起来非常的蠢，但是我们尝试把它应用到这道题上。</p><p>求中位数等于 $m$ 的区间个数，即求<strong>中位数大于等于 $m$ 的区间个数</strong>，减去<strong>中位数大于 $m$ 的区间个数</strong>。由于 $\{ a_n \}$ 及其所有子区间的中位数只有整数，后者等价于中位数大于等于 $m + 1$ 的区间个数。</p><p>现在问题转化为了如何求<strong>中位数大于等于 $m$ 的区间个数</strong>。对于一个区间，我们设其中小于 $m$ 的数、$m$、大于 $m$ 的数分别有 $x, y, z$ 个，则该区间的中位数大于等于 $m$ 等价于 $x &lt; y + z$。这个可以通过大力分类讨论 $x, y, z$ 的值关系得到，此处略去不表。</p><p>我们同样把小于 $m$ 的数、大于等于 $m$ 的数分别记作 $-1, 1$，同时统计此意义下前 $i$ 个数的前缀和 $s$、每个前缀和 $s_0$ 出现的次数 $c_{s_0}$ 以及 $c_{[0, s)}$ 的前缀和 $ss$。注意 $ss$ 的意义随着 $s$​ 值的改变而改变。</p><p>对于枚举过程中每一个 $s$ 的取值，可以将其看作前一段提到的 $y + z$ 的值，此时 $ss$ 的值即为满足 $x &lt; y + z$ 的 $x$ 的个数。类似于 Easy Version 里对每个 $c_{-s} + c_{1 - s}$ 求和的想法，我们对所有的 $ss$ 求和，即可得到答案。</p><p>统计 $ss$ 既可以像下述代码里一样单次 $O(1)$ 地动态统计，也可以写个数据结构单次 $O( \log k)$ 地统计。总复杂度 $O(n)$ 或 $O(n \log k)$。其中 $k$ 为 $a_i$ 的值域。</p><h4 id="code-for-Hard-Version-1"><a href="#code-for-Hard-Version-1" class="headerlink" title="code for Hard Version"></a>code for Hard Version</h4><p>变量名和上述除大小写外完全相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">200003</span>], c_[<span class="number">400007</span>], *c = c_ + <span class="number">200003</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Returns the number of subsequences(continuous) with a median of ge M</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> g = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (g) <span class="built_in">memset</span>(c_, <span class="number">0</span>, <span class="keyword">sizeof</span> c_);</span><br><span class="line">  g = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ss: sum of c[0..s)</span></span><br><span class="line">  <span class="keyword">int64_t</span> ss = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  ++c[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, s = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="comment">// 下面这两行太有感觉了，简直青回（</span></span><br><span class="line">    <span class="keyword">if</span> (z[i] &lt; M) ss -= c[--s];</span><br><span class="line">    <span class="keyword">else</span> ss += c[s++];</span><br><span class="line">    ans += ss;</span><br><span class="line">    ++c[s];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    std::cin &gt;&gt; z[i];</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">solve</span>(N, M) - <span class="built_in">solve</span>(N, M + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="2-9-猎手，抑或猎物"><a href="#2-9-猎手，抑或猎物" class="headerlink" title="2-9 猎手，抑或猎物"></a><a href="http://47.102.108.97/contest/7/problem/9">2-9 猎手，抑或猎物</a></h3><h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem"></a>problem</h4><p>给定一个 $n \times m \ (3 \le n \times m \le 10^6)$ 的迷宫，有些位置可以通过，有些不能。你可以将一些可以通过的位置改变为不能通过。求最少改变多少个位置的性质，使得不存在从 $(1, 1)$ 通向 $(n, m)$ 的路径。移动只能向右或向下。</p><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>嗷这题是非常的重量级，一眼看到这题以为要建 $O(nm)$ 个点和 $O(nm)$ 条边跑网络流，一看数据范围傻眼了🤗</p><p>发现答案只可能有 $0, 1, 2$ 三种取值，因为至多把起点旁边的俩格子堵上就完事了。现在的任务就是分出这三种情况来。</p><p>首先答案是 $0$ 的情况非常的好判，dfs 一遍到不了终点答案就是 $0$。</p><p>那么答案是 $1$ 和 $2$ 怎么区分呢，这个也很简单，dfs 第一遍的时候把经过的路都堵上，判能不能 dfs 到终点第二遍就行了。dfs 的时候先沿同一个方向走，直到发现死路再转向，正确性不会证，感性理解一下（</p><p>这个做法和一般图上找两条路径网络流第一遍不退流有异曲同工之妙，所以这题还是没能和网络流脱开干系（确信）</p><p>复杂度显然是 $O(nm)$。</p><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == N &amp;&amp; y == M) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  z[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, nx, ny; k &lt; <span class="number">2</span>; ++k) &#123;</span><br><span class="line">    nx = x + dx[k], ny = y + dy[k];</span><br><span class="line">    <span class="keyword">if</span> (nx &lt;= N &amp;&amp; ny &lt;= M &amp;&amp; z[nx][ny] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dfs</span>(nx, ny))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">z</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; z[i];</span><br><span class="line">    z[i] = <span class="string">&quot; &quot;</span> + z[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans1 = <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (!ans1) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  z[<span class="number">1</span>][<span class="number">1</span>] = z[N][M] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  <span class="keyword">int</span> ans2 = <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> + ans2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>Fin.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2022 Jan Records</title>
      <link href="/2022/2022-Jan-Records/"/>
      <url>/2022/2022-Jan-Records/</url>
      
        <content type="html"><![CDATA[<p>菜鸡 fa_555 会把一些动态简要地记在这里。主要还是留给自己以后看的。</p><span id="more"></span><p>这个月大概打了打学校公益课的入门赛。挑一些入门赛进阶组的题目写一写。</p><p><em>所有代码不保证包括无关紧要的部分</em></p><hr><h3 id="Second-1-I-Queuing-HDU-2604"><a href="#Second-1-I-Queuing-HDU-2604" class="headerlink" title="Second_1 I: Queuing (HDU 2604)"></a>Second_1 I: Queuing (HDU 2604)</h3><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>求满足以下性质的长为 $|s| \ (|s| \le 10^6)$ 的字符串 $s$ 的数量：</p><ol><li>$s$ 中仅包含 $\texttt{f} / \texttt{m}$ 两种字符</li><li>$s$ 不含子串 $\texttt{fff}, \texttt{fmf}$。</li></ol><p>答案对 $m \ (1 \le m \le 30)$ 取模。$T$ 组询问。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>没有什么疑问地 dp 推一下式子。网上的博客的 dp 方法都太神仙学不会，自己在赛时只会最弱智的。</p><p>设 $f_{i, 0/1/2/3}$ 分别表示长为 $i$ 的字符串 $s$ 的最后两位是 $\texttt{ff},  \texttt{fm}, \texttt{mf}, \texttt{mm}$ 的方案数。</p><p>由此得显然的递推式</p><script type="math/tex; mode=display">\begin{aligned}f_{i, 0} & = f_{i - 1, 2} \\f_{i, 1} & = f_{i - 1, 0} + f_{i - 1, 2} \\f_{i, 2} & = f_{i - 1, 3} \\f_{i, 3} & = f_{i - 1, 1} + f_{i - 1, 3} \\\end{aligned}</script><p>然后发现这题模数是不固定的，所以 $O(T |s|)$ 的暴力一看就过不去（</p><p>后面的操作就多少沾点魔术：</p><p>为了记号上的美观，令四元组 $(a_1, a_2, a_3, a_4)$ 表示 $a_1 f_{j, 0} + a_2 f_{j, 1} + a_3 f_{j, 2} + a_4 f_{j, 3}$。于是暴力向后推几项：</p><script type="math/tex; mode=display">\begin{array}{ccc}j = i & & j = i - 1 & & j = i - 2 & & j = i - 3 & & j = i - 4 \\(1, 0, 0, 0) & = & (0, 0, 1, 0) & = & (0, 0, 0, 1) & = & (0, 1, 0, 1) & = & (1, 1, 1, 1) \\(0, 1, 0, 0) & = & (1, 0, 1, 0) & = & (0, 0, 1, 1) & = & (0, 1, 0, 2) & = & (1, 2, 1, 2) \\(0, 0, 1, 0) & = & (0, 0, 0, 1) & = & (0, 1, 0, 1) & = & (1, 1, 1, 1) & = & (1, 1, 2, 2) \\(0, 0, 0, 1) & = & (0, 1, 0, 1) & = & (1, 1, 1, 1) & = & (1, 1, 2, 2) & = & (1, 2, 2, 4) \\(1, 1, 1, 1) & = & (1, 1, 2, 2) & = & (1, 2, 2, 4) & = & (2, 4, 3, 6) & = & (4, 6, 6, 9) \\\end{array}</script><p>（由于表里出现了很多重复项，所以人脑记忆化一下很快就算出来了，不能算麻烦）</p><p>发现 $(4, 6, 6, 9) = (2, 4, 3, 6) + (1, 1, 2, 2) + (1, 1, 1, 1)$。于是令 $f_i = \sum \limits_{j = 0}^3 f_{i, j}$，则有 $f_i = f_{i - 1} + f_{i - 3} + f_{i - 4}$。</p><p>后面的事大概就大家都知道了，搞出个矩阵来快速幂完事。</p><script type="math/tex; mode=display">\begin{bmatrix} f_n \\ f_{n - 1} \\ f_{n - 2} \\ f_{n - 3} \end{bmatrix} = \begin{bmatrix}1 & & 1 & 1 \\1 \\& 1 \\& & 1\end{bmatrix}^{n - 3} \begin{bmatrix} f_{3} \\ f_{2} \\ f_{1} \\ f_{0} \end{bmatrix}</script><p>其中 $f_0 = 1, f_1 = 2, f_2 = 4, f_3 = 6$。复杂度 $O(T \log |s|)$。</p><h3 id="Second-1-J-Count-HDU-6470"><a href="#Second-1-J-Count-HDU-6470" class="headerlink" title="Second_1 J: Count (HDU 6470)"></a>Second_1 J: Count (HDU 6470)</h3><h4 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem"></a>Problem</h4><p>已知 $f_1 = 1, f_2 = 2, f_n = f_{n - 1} + f_{n - 2} + n^3$，求模意义下的 $f_n \ (n \le 10^{18})$。$T \ (T \le 10^4)$ 组询问。</p><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>矩阵快速幂处理常数项的板子题。把所有含 $n$ 的项用 $n - 1$ 表示，得到矩阵</p><script type="math/tex; mode=display">\begin{bmatrix} f_n \\ f_{n - 1} \\ (n + 1)^3 \\ (n + 1)^2 \\ n + 1 \\ 1 \end{bmatrix} = \begin{bmatrix}1 & 2 & 1 \\1 \\& & 1 & 3 & 3 & 1 \\& & & 1 & 2 & 1 \\& & & & 1 & 1 \\& & & & & 1 \\\end{bmatrix} \begin{bmatrix} f_{n - 1} \\ f_{n - 2} \\ n^3 \\ n^2 \\ n \\ 1 \end{bmatrix} = \begin{bmatrix}1 & 2 & 1 \\1 \\& & 1 & 3 & 3 & 1 \\& & & 1 & 2 & 1 \\& & & & 1 & 1 \\& & & & & 1 \\\end{bmatrix}^{n - 2} \begin{bmatrix} f_{2} \\ f_{1} \\ 27 \\ 9 \\ 3 \\ 1 \end{bmatrix}</script><p>总复杂度 $O(T \log n)$。</p><h3 id="Second-1-L-Another-kind-of-Fibonacci-HDU-3306"><a href="#Second-1-L-Another-kind-of-Fibonacci-HDU-3306" class="headerlink" title="Second_1 L: Another kind of Fibonacci (HDU 3306)"></a>Second_1 L: Another kind of Fibonacci (HDU 3306)</h3><h4 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem"></a>Problem</h4><p>已知 $A_0 = 1, A_1 = 1, A_n = xA_{n - 1} + yA_{n - 2}$。令 $S_n = \sum \limits_{i = 0}^n{ A_i^2 }$，求模意义下的 $S_n$。$(2 \le n, x, y &lt; 2^{31})$。$T$ 组询问。</p><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>这题更是重量级。考虑推式子</p><script type="math/tex; mode=display">\begin{aligned}A_n^2 &= x^2 A_{n - 1}^2 + y^2 A_{n - 2}^2 + 2xy A_{n - 1} A_{n - 2} \\S_n & = S_{n - 1} + A_n^2 \\& = S_{n - 1} + x^2 A_{n - 1}^2 + y^2 A_{n - 2}^2 + 2xy A_{n - 1} A_{n - 2} \\A_n A_{n - 1} & = x A_{n - 1}^2 + y A_{n - 1} A_{n - 2}\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">\begin{bmatrix} S_n \\ A_n^2 \\ A_{n - 1}^2 \\ A_n A_{n - 1} \end{bmatrix} = \begin{bmatrix}1 & x^2 & y^2 & 2xy \\& x^2 & y^2 & 2xy \\& 1 \\& x & & y\end{bmatrix} \begin{bmatrix} S_{n - 1} \\ A_{n - 1}^2 \\ A_{n - 2}^2 \\ A_{n - 1} A_{n - 2} \end{bmatrix} = \begin{bmatrix}1 & x^2 & y^2 & 2xy \\& x^2 & y^2 & 2xy \\& 1 \\& x & & y\end{bmatrix}^{n - 1} \begin{bmatrix} 2 \\ 1 \\ 1 \\ 1 \end{bmatrix}</script><p>总复杂度 $O(T \log n)$。</p>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假数学一轮笔记</title>
      <link href="/2020/Note-Math/"/>
      <url>/2020/Note-Math/</url>
      
        <content type="html"><![CDATA[<p>这里是暑假数学一轮笔记。</p><p>随便写写的，会写点二级结论、例题和证明。</p><p>可能为了连贯会写非常水的，也会写非常难的。（写完后发现按照编排恰好难度大致递增）</p><p>不一定是从书上抄来的，有些可能是我个人想到的 idea。</p><p>例题一般只有 做法极其经典 或 我的做法比标准答案简单 或 解法极具启发意义 我才会写解法。</p><span id="more"></span><p><strong>这篇笔记的目的是介绍各种好用的思想方法和难推且好用的结论（主要在解析几何部分。实际上，这部笔记原本就是为了解析几何的大量二级结论而写的）不要把所有的结论都记住，这不是这篇笔记的目的。对于能快速推导的结论，应该从阅读这篇笔记中锻炼思维，从而掌握推导过程，每次用的时候现推。把所有的东西都记住只会让自己变傻。做题最重要的是脑子，结论只能在有脑子的前提下起辅助作用，千万不要满脑子只有结论。</strong></p><p>不一定会按照高中数学课本的规范写公式和术语。</p><p>不要外传给任何人，因为我觉得这个拿出去卖钱能挣一大笔，并且这个排版太丑，拿出去很丢人。</p><p>所有蓝色的超链接都是能点的（</p><p>[TOC]</p><hr><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p><em>由于复习的时候不在暑假所以没想到写啥，实际上三角函数也没啥结论，全是公式。</em></p><ul><li><p>已知扇形的周长为 $C$，则面积 $S = \frac{C^2}{2( \alpha + \frac 4 \alpha + 4)}$，其中 $\alpha$ 为圆心角。当 $\alpha = 2 \ \mathrm{rad}$ 时，$S_{\max} = \frac{C^2}{16}$。</p><hr></li><li><p>$a\sin x + b\cos x = \sqrt{a^2 + b^2} \sin(x + \varphi)$，其中 $\tan \varphi = \frac ba$。虽然辅助角公式已经记烂了，但还是写一下表示尊重。</p><hr></li><li><p>用 $\tan \alpha$ 表示 $\sin 2\alpha, \ \cos 2\alpha, \ \tan 2\alpha$ 的式子可以先降一次幂然后除以 $\sin^2 \alpha + \cos^2 \alpha$ 再瞎比 $\cos \alpha$ 得到。这个的用处主要是推导过程，公式太乱就不打了。</p><hr></li><li><p>在 $\triangle ABC$ 中，由于 $A + B &lt; \pi$ 的限制，$A &lt; B \Longleftrightarrow \sin A &lt; \sin B$。</p><hr></li><li><p><strong>噔噔咚</strong> 和差化积、积化和差</p><script type="math/tex; mode=display">\begin{split}\sin \alpha + \sin \beta &= 2 \sin \frac{ \alpha + \beta}2 \cos \frac{ \alpha - \beta}2 \\\sin \alpha - \sin \beta &= 2 \sin \frac{ \alpha - \beta}2 \cos \frac{ \alpha + \beta}2 \\\cos \alpha + \cos \beta &= 2 \cos \frac{ \alpha + \beta}2 \cos \frac{ \alpha - \beta}2 \\\cos \alpha - \cos \beta &= -2 \sin \frac{ \alpha + \beta}2 \sin \frac{ \alpha - \beta}2 \\\tan \alpha + \tan \beta &= \frac{ \sin( \alpha + \beta)}{ \cos \alpha \cos \beta} \\\tan \alpha - \tan \beta &= \frac{ \sin( \alpha - \beta)}{ \cos \alpha \cos \beta} \\\end{split}</script><script type="math/tex; mode=display">\begin{split}\sin \alpha \cos \beta &= \frac 12( \sin( \alpha + \beta) + \sin( \alpha - \beta)) \\\cos \alpha \cos \beta &= \frac 12( \cos( \alpha + \beta) + \cos( \alpha - \beta)) \\\sin \alpha \sin \beta &= - \frac 12( \cos( \alpha + \beta) - \cos( \alpha - \beta))\end{split}</script></li></ul><hr><h2 id="平面向量"><a href="#平面向量" class="headerlink" title="平面向量"></a>平面向量</h2><p><em>向量属实是又简单又好用的玩意了。</em></p><ul><li><p>对于起点相同、终点共线的三个向量 $\vec{ON}, \vec{OP}, \vec{OQ}$（$O$ 与 $PQ$ 不共线），总有 $\vec{ON} = u \cdot \vec{OP} + v \cdot \vec{OQ}$，其中 $u + v = 1$。</p><p><strong>例</strong> 设两个非零向量 $\vec a$ 与 $\vec b$ 不共线，若 $\vec a$ 与 $\vec b$ 的起点相同，且 $\vec a, t \vec b, \frac 13( \vec a + \vec b)$ 的终点在同一条直线上，求实数 $t$ 的值。</p><p><strong>解</strong> 设 $\begin{cases} \frac 13( \vec a + \vec b) = u \vec a + vt \vec b \\ u + v = 1 \end{cases}$，解出来就完事🌶</p><hr></li><li><p>在上一条的基础上，如果有 $\vec{OM} = \lambda \vec{ON}$，则有 $\vec{OM} = u \cdot \vec{OP} + v \cdot \vec{OQ}$，其中 $u + v = \lambda$。有很多题可以用这个简化。</p><hr></li><li><p>若 $G$ 为 $\triangle ABC$ 的<strong>重心</strong>（中线的交点），则有 $\vec{GA} + \vec {GB} + \vec {GC} = 0 $，$\vec{AG} = \frac 13( \vec{AB} + \vec{AC})$。</p><ul><li>这个结论在立体几何那章的题目里会非常有用：设正三角形的边长为 $a$，则某个顶点到重心的距离为 $\frac{ \sqrt 3}3 a$。相应地，重心到某条边的距离为 $\frac{ \sqrt 3}6 a$。</li></ul></li></ul><hr><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><ul><li><p>复数相乘，模相乘，幅角相加；复数相除，模相除，幅角相减。</p><ul><li>记住这个看起来非常 naive 的结论，脑子里再带着个复平面，大部分复数题可以秒出。</li></ul><p><strong>例</strong> 复数 $z = \frac {3 + 4i}{12 - 5i}$（$i$ 为虚数单位），求 $|z|$。</p><p><strong>解</strong> 分子模是 $5$，分母模是 $13$，完事了。<!-- 共轭复数平方差的憨批搁那算你🐴呢？ --><em>[这里本来的那句话已注释掉]</em></p></li></ul><hr><h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><p><!-- *傻逼玩意怎么高中题出得这么难受* --><em>[这里本来的那句话已注释掉]</em></p><p>数列题大部分是比较需要脑子的，但也有少部分烂题会不会结论完全就是两种感受。</p><p><strong>本节中默认 $n \in \N^\ast$，不再赘述。</strong></p><h3 id="求通项公式"><a href="#求通项公式" class="headerlink" title="求通项公式"></a>求通项公式</h3><p><em>这节没有值得学习的东西。一轮之后的阅读请跳过这节。</em></p><ul><li><p>$a_n = \begin{cases} S_1 &amp;, n = 1 \\ S_n - S_{n - 1} &amp;, n \ge 2 \end{cases}$，写这条是为了提醒你求出通项不要忘记验证 $a_1$ 是否满足。</p><p><strong>例</strong> 已知数列 $\{ a_n \}$ 的前 $n$ 项和公式为 $S_n = 2n^2 - n + 1$，求 $a_n$。</p><p><strong>答案</strong> $a_n = \begin{cases} 2 &amp;, n = 1 \\ 4n - 3 &amp;, n \ge 2 \end{cases}$</p><hr></li><li><p>已知 $\frac{a_{n + 1}}{a_n} = f(n)$，求 $a_n$，上<strong>累乘</strong>。</p><p><strong>例 1</strong> 已知在数列 $\{ a_n \}$ 中，已知 $a_1 = 1, na_{n - 1} = (n + 1)a_n \ (n \ge 2)$，求 $a_n$。</p><p><strong>解</strong></p><script type="math/tex; mode=display">\begin{align}& \begin{split}\frac{a_n}{a_{n - 1}} &= \frac n{n + 1} \ (n \ge 2) \\\Longrightarrow a_n &= \frac{a_n}{a_{n - 1}} \cdot \frac{a_{n - 1}}{a_{n - 2}} \cdot \ldots \cdot \frac{a_2}{a_1} \cdot a_1 \\&= \frac n{n + 1} \cdot \frac{n - 1}n \cdot \ldots \cdot \frac 23 \cdot 1 \\&= \frac{2}{n + 1} \ (n \ge 2)\end{split} \\& a_1 = 1 \text{ satisfies the above formula.} \\&\Longrightarrow a_n = \frac 2{n + 1}\end{align}</script><p><strong>例 2</strong> 已知在数列 $\{ a_n \}$ 中，$a_1 = 2, (n + 2)a_{n + 1} - (n + 1)a_n = 0$，求 $a_n$。</p><p><strong>答案</strong> $a_n = \frac 4{n + 1}$</p><hr></li><li><p>类似地，已知 $a_{n + 1} - a_n = f(n)$，上<strong>累加</strong>。</p><p><strong>例 1</strong> 已知在数列 $\{ a_n \}$ 中，$a_1 = 2, a_n - a_{n - 1} = 3n - 1 \ (n \ge 2)$，求 $a_n$。</p><p><strong>解</strong></p><script type="math/tex; mode=display">\begin{align}& \begin{split}a_n - a_{n - 1} &= 3n - 1 \ (n \ge 2) \\\Longrightarrow a_n &= (a_n - a_{n - 1}) + (a_{n - 1} - a_{n - 2}) + \cdots + (a_2 - a_1) + a_1 \\&= (3n - 1) + (3n - 4) + \cdots + 5 + 2 \\&= \frac{n(3n + 1)}2 \ (n \ge 2)\end{split} \\& a_1 = 2 \text{ satisfies the above formula.} \\&\Longrightarrow a_n = \frac{n(3n + 1)}2\end{align}</script><p><strong>例 2</strong> 已知在数列 $\{ a_n \}$ 中，$a_1 = 2, a_{n + 1} = a_n + \frac 1{n(n + 1)}$，求 $a_n$。</p><p><strong>答案</strong> $a_n = 3 - \frac 1n$</p><hr></li><li><p>已知 $a_{n + 1} = pa_n + q$，待定系数设 $a_{n + 1} + \lambda = p(a_n + \lambda)$，求出 $\lambda$，$\{ a_n + \lambda \}$ 是等比数列。</p><p><strong>例</strong> 已知在数列 $\{ a_n \}$ 中，$a_1 = 3$，且点 $P_n(a_n, a_{n + 1})$ 在直线 $4x - y + 1 = 0$ 上，求 $a_n$。</p><p><strong>解</strong> 发现 $a_{n + 1} = 4a_n + 1$。通过上面方法得到 $a_{n + 1} + \frac 13 = 4 \left(a_n + \frac 13 \right)$，则 $\left\{ a_n + \frac 13 \right\}$ 是首项为 $\frac{10}3$，公比为 $4$ 的等比数列。$a_n = \frac 56 \cdot 4^n - \frac 13$。</p><hr></li><li><p>剩下的求通项题就比较人类智慧了。比如<a href="https://fa555.github.io/2020/counting/#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0">这个</a>（？）</p></li></ul><hr><h3 id="等差数列相关"><a href="#等差数列相关" class="headerlink" title="等差数列相关"></a>等差数列相关</h3><p>本节中默认 $\{ a_n \}$ 是首项为 $a_1$，公差为 $d$ 的等差数列，$S_n$ 为其前缀和。</p><ul><li><p>若 $a, b, c$ 成等差数列，即 $b$ 是 $a$ 和 $c$ 的等差中项，则 $2b = a + c$。其实就是算术平均数。</p><hr></li><li><p>$a_n = a_m + (n - m)d$</p></li><li><p>$S_n = \frac{n(a_1 + a_n)}2 = na_1 + \frac{n(n - 1)}2 d$</p><ul><li>$\left \{ \frac{S_n}n \right \}$ 也是等差数列，$\frac{S_n}n = a_1 + \frac{n - 1}2 d$。</li></ul></li><li><p>$S_n, S_{2n - n}, S_{3n - 2n}, \cdots$ 成等差数列，公差为 $n^2d$。</p><hr></li><li><p>若项数为偶数 $2n$，则 $S_{2n} = n(a_1 + a_{2n}) = n(a_{n} + a_{n + 1})$，$\frac{S_{ \text{even}}}{S_{ \text{odd}}} = \frac{a_n}{a_{n + 1}}$。</p></li><li><p>若项数为奇数 $2n - 1$，则 $S_{2n - 1} = (2n - 1)a_n$，$S_{ \text{odd}} - S_{ \text{even}} = a_n$，$\frac{S_{ \text{odd}}}{S_{ \text{even}}} = \frac{n}{n - 1}$。</p><ul><li>校对过了，上两条不对称的地方没有错误。证明都不难，直接套通项就行，难就难在第一个想出这些结论。</li></ul><hr></li><li><p>若数列 $\{ a_n \}$ 和 $\{ b_n \}$ 均为等差数列，且前 $n$ 项和分别是 $S_n$ 和 $T_n$，则 $\frac{S_{2m - 1}}{T_{2m - 1}} = \frac{a_m}{b_m}$。</p></li></ul><hr><h3 id="等比数列相关"><a href="#等比数列相关" class="headerlink" title="等比数列相关"></a>等比数列相关</h3><p>本节中默认 $\{ a_n \}$ 是首项为 $a_1$，公比为 $q \ (q \ne 0)$ 的等比数列，$S_n$ 为其前缀和，$T_n$ 为其前缀积。</p><ul><li><p>若 $a, b, c$ 成等比数列，即 $b$ 是 $a$ 和 $c$ 的等比中项，则 $b^2 = ac$（反之不能推出，因为可能出现 $0$）。其实就是几何平均数。</p><hr></li><li><p>$a_n = a_m q^{n - m}$</p></li><li><p>若 $q \ne 1$，$S_n = \frac{a_1(1 - q^n)}{1 - q} = \frac{a_1 - a_n q}{1 - q}$。</p></li><li><p>$T_n = (a_1 a_n)^{ \frac n2} = a_1^n q^{ \frac{n(n - 1)}2}$</p></li><li><p>若 $q \ne -1$，$S_n, S_{2n} - S_n, S_{3n} - S_{2n}, \cdots$ 成等比数列，公比为 $q^n$。</p></li><li><p>$T_n, \frac{T_{2n}}{T_n}, \frac{T_{3n}}{T_{2n}}, \cdots$ 成等比数列，公比为 $q^{n^2}$。</p><hr></li><li><p>若项数为奇数 $2n + 1$，则 $T_{2n + 1} = a_n^{2n + 1}$。</p><ul><li>不光这个，显然上面等差数列前缀和对原数列的减法性质和做等比数列对原数列的除法性质是一一对应的。虽然非常简单，但是做题想不到就会像吃屎一样难受。</li></ul><hr></li><li><p>$S_{n + m} = S_n + q^n S_m = S_m + q^m S_n$</p><p><strong>例</strong> 已知数列 $\{ a_n \}$ 是各项都为正数的等比数列，$S_n$ 为其前 $n$ 项和，且 $S_{10} = 10, S_{30} = 70$，求 $S_{40}$。</p><p><strong>解</strong> $30$ 是 $10$ 的整数倍，所以可以拆成 $S_{10}(1 + q^{10} + q^{20}) = S_{30}$，解得 $q^{10} = 2$（另一根舍去）。就可以用这个非常显然的结论了。例如，$S_{40} = S_{10} + q^{10} S_{30}$，等号右面的三项都已知。</p></li></ul><hr><h3 id="数列求和"><a href="#数列求和" class="headerlink" title="数列求和"></a>数列求和</h3><p><em>这节没有值得学习的东西。一轮之后的阅读请跳过这节。</em></p><ul><li><p>等差数列求和公式：$S_n = \frac{n(a_1 + a_n)}2 = na_1 + \frac{n(n - 1)}2 d$。</p></li><li><p>等比数列求和公式：$S_n = \begin{cases} na_1 &amp;, n = 1 \\ \frac{a_1(1 - q^n)}{1 - q} = \frac{a_1 - a_n q}{1 - q} &amp; , n \ne 1 \end{cases}$。</p></li><li><p>倒序相加</p><p>适用于序列自身循环卷积后非常好算的情况。例如用于等差数列求和公式的推导。</p></li><li><p>分组求和</p><p>其实就是加法结合律。例如求 $a_n = 2^n + n$ 的前缀和。</p></li><li><p>并项求和</p><p>其实也是加法结合律。例如求 $a_n = (-1) f(n)$ 的前缀和，可以把奇偶项分别求和再相加。</p></li><li><p>错位相减</p><p>适用于等于等差数列乘以等比数列的数列求和，当然也可以推导等比数列求和公式。例如求 $a_n = n \cdot 2^n$ 的前缀和。</p><script type="math/tex; mode=display">\begin{align}& \begin{split}S_n &= 1 \cdot 2^1 + \ &  2 \cdot 2^2 + 3 \cdot 2^3 + \cdots + n \cdot 2^n \\2S_n &= &1 \cdot 2^2 + 2 \cdot 2^3 + \cdots + (n - 1) 2^n + n \cdot 2^{n + 1}\end{split} \\& (1 - 2)S_n = 2 + (2^2 + 2^3 + \cdots + 2^n) - n \cdot 2^{n + 1} \\& -S_n = 2^{n + 1} - 2 - n \cdot 2^{n + 1} \\& S_n = (n - 1)2^{n + 1} + 2\end{align}</script></li><li><p>裂项相消</p><p>把数列的通项拆成两项之差，在和式中某些项可以相互抵消，从而求得和。见<a href="#裂项公式">裂项公式</a>。</p></li></ul><hr><h2 id="立体几何"><a href="#立体几何" class="headerlink" title="立体几何"></a>立体几何</h2><p>这一块太水的东西就不写了。像什么<em>长方体边长和内切球、外切球半径的关系</em>，<em>正四棱锥边长和表面积、体积、内切球外接球半径的关系</em>之类的，瞎推就能出来，都写了没意思，当成结论记对脑子也不好。</p><p>后半段能用向量做的题也不会有啥结论值得学，有用的东西应该都会写在题目部分。</p><h3 id="棱锥和球"><a href="#棱锥和球" class="headerlink" title="棱锥和球"></a>棱锥和球</h3><p>经常会有题目把棱锥和球（内切球、外接球）联系起来（比如 2019 全国 I 卷 T12）。</p><ul><li><p>有些把棱锥放进外接球的题目，可以把棱锥放进长方体来更方便地求出球外接球的半径。</p><ul><li>详见<a href="#小题题">小题题</a>第二题。</li><li>当然更多的题棱锥自身性质放不进长方体里，这样就只能勾股定理爆算了。</li></ul></li><li><p>对于把内切球放进棱锥的题目，可以通过其体积 $V$ 和表面积 $S$ 来更方便地求出内切球球的半径 $r$：$\frac 13 Sr = V$。</p><ul><li>这个式子的意义考虑把棱锥分割成若干个以内切球半径为高的三棱锥一并求出体积。</li></ul><hr></li><li><p>球心与任意一个截面圆圆心的连线垂直于截面圆。经常由此性质确定球心的位置。</p></li></ul><hr><h3 id="点、直线和平面"><a href="#点、直线和平面" class="headerlink" title="点、直线和平面"></a>点、直线和平面</h3><p><em>多看几遍也不错</em></p><ul><li>公理<ul><li>如果一条直线上的两点在同一个平面内，那么这条直线在此平面内。<ul><li>$A \in l, B \in l, A \in \alpha, B \in \alpha \Longrightarrow l \in \alpha$</li></ul></li><li>过不在同一条直线上的三点，有且只有一个平面。<ul><li>过一条直线和这条直线外一点有且只有一个平面。</li><li>过两条相交直线有且只有一个平面。</li><li>过两条平行直线有且只有一个平面。</li></ul></li><li>如果两个不重合的平面有一个公共点，那么它们有且只有一条过该点的公共直线。<ul><li>$P \in \alpha, P \in \beta \Longrightarrow \alpha \cap \beta = l, P \in l$</li></ul></li><li>平行于同一条直线的两条直线互相平行。<ul><li>$a \parallel b, a \parallel c \Longrightarrow b \parallel c$</li></ul></li></ul></li><li>过平面外一点和平面内一点的直线与平面内不过该点的直线是异面直线。</li></ul><hr><h2 id="不等式"><a href="#不等式" class="headerlink" title="不等式"></a>不等式</h2><h3 id="均值不等式"><a href="#均值不等式" class="headerlink" title="均值不等式"></a>均值不等式</h3><p>设 $x_1, x_2, \cdots, x_n \in \R_+$，则</p><script type="math/tex; mode=display">\frac 1n \sum_{i = 1}^n x_i \ge \sqrt[n]{ \prod_{i = 1}^n{x_i}} \tag{1}</script><p>当且仅当 $x_1 = x_2 = \cdots = x_n$ 时取等号。</p><p><strong>证明</strong></p><p>$n = 1$ 时显然成立。</p><p>引理：$\forall a, b \in \R_+, \frac 12(a  + b) \ge \sqrt{ab}$，当且仅当 $a = b$ 时取等号。引理的证明通过基本不等式 $\forall a, b \in R, a^2 + b^2 \ge 2ab$。当 $a, b \ge 0$ 时以 $\sqrt a, \sqrt b$ 取代 $a, b$。这样就证明了 $(1)$ 式当 $n = 2$ 时成立。</p><p>考虑数学归纳法。若 $n = k \ (k \ge 2)$ 的情况成立，对于 $n = k + 1$  的情况，考虑将 $(1)$ 式左右分别提出前 $k$ 项的和或积，故而 $n = k + 1$ 的情况也成立。$\square$</p><h3 id="柯西不等式"><a href="#柯西不等式" class="headerlink" title="柯西不等式"></a>柯西不等式</h3><p>设 $a_1, a_2, \cdots, a_n, b_1, b_2, \cdots, b_n \in \R$，则</p><script type="math/tex; mode=display">\sum_{i = 1}^n{a_i^2} \sum_{i = 1}^n{b_i^2} \ge \left( \sum_{i = 1}^n{a_i b_i} \right)^2</script><p>等号成立条件：$\frac{a_1}{b_1} = \frac{a_2}{b_2} = \cdots = \frac{a_n}{b_n}$，或 $b_i = 0$。</p><p><strong>证明</strong></p><p>令 $f_i(x) = (a_i x + b_i)^2$，则 $f(x) = \sum_{i = 1}^n{f_i(x)} \ge 0$。因此其判别式 $\Delta = 4 \left( \sum_{i = 1}^n{x_i y_i} \right)^2 - 4 \left( \sum_{i = 1}^n{x_i^2} \right) \left( \sum_{i = 1}^n{y_i^2} \right) \le 0$。化简即得柯西不等式。$\square$</p><p>当然也可以用向量证。</p><p><strong>二维形式</strong></p><script type="math/tex; mode=display">(a^2 + b^2)(c^2 + d^2) \ge (ac + bd)^2</script><p><strong>推广形式</strong></p><script type="math/tex; mode=display">\prod_{i = 1}^n{ \sum_{j = 1}^m{ x_{i, j}}} \ge \left( \sum_{j = 1}^m{ \left( \prod_{i = 1}^n{x_{i, j}} \right)^{ \frac 1n}} \right)^n</script><p><strong>推论</strong></p><p>小于方向</p><script type="math/tex; mode=display">|a_1 b_1 + a_2 b_2 + \cdots + a_n b_n| \le \sqrt{a_1^2 + a_2^2 + \cdots + a_n^2} \cdot \sqrt{b_1^2 + b_2^2 + \cdots + b_n^2} \\\sqrt{a_1 b_1} + \sqrt{a_2 b_2} + \cdots + \sqrt{a_n b_n} \le \sqrt{a_1 + a_2 + \cdots + a_n} \cdot \sqrt{b_1 + b_2 + \cdots + b_n} \\|A \sin x + B \cos x| \le \sqrt{A^2 + B^2}</script><p>大于方向</p><script type="math/tex; mode=display">(a_1 + a_2 + \cdots + a_n) \left( \frac 1{a_1} + \frac 1{a_2} + \cdots + \frac 1{a_n} \right) \ge n^2</script><p><strong>推论 - 权方和不等式</strong></p><script type="math/tex; mode=display">\frac{a_1^2}{b_1} + \frac{a_2^2}{b_2} + \cdots + \frac{a_n^2}{b_n} \ge \frac{(a_1 + a_2 + \cdots + a_n)^2}{b_1 + b_2 + \cdots + b_n} \\\frac{a_1^{m + 1}}{b_1^m} + \frac{a_{m + 1}^{m + 1}}{b_2^m} + \cdots + \frac{a_n^{m + 1}}{b_n^m} \ge \frac{(a_1 + a_2 + \cdots + a_n)^{m + 1}}{(b_1 + b_2 + \cdots + b_n)^m}</script><h3 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h3><p>设 $a_1 \le a_2 \le \cdots \le a_n, \ b_1 \le b_2 \le \cdots \le b_n$，$\{c_n\}$ 是 $\{b_n\}$ 的一个排列。若</p><script type="math/tex; mode=display">\begin{split}S_1 & = a_1 b_n + a_2 b_{n - 1} + \cdots + a_n b_1 \\S_2 & = a_1 b_1 + a_2 b_2 + \cdots + a_n b_n \\S_3 & = a_1 c_1 + a_2 c_2 + \cdots + a_n c_n\end{split}</script><p>则有 $S_1 \le S_3 \le S_2$。</p><h3 id="其他的不等式"><a href="#其他的不等式" class="headerlink" title="其他的不等式"></a>其他的不等式</h3><ul><li><p>设 $x_1, x_2, \cdots, x_n \in \R_+$，则</p><script type="math/tex; mode=display">\frac{x_1^2}{x_2} + \frac{x_2^2}{x_3} + \cdots + \frac{x_{n - 1}^2}{x_n} + \frac{x_n^2}{x_1} \ge x_1 + x_2 + \cdots + x_n</script><p>证明：不等式两边同时加上不等式右边，原命题转化为证 $\frac{x_1^2}{x_2} + x_2 \ge 2x_1$（当且仅当 $x_1 = x_2$ 时取等号），其他各项同理。而这个不等式的正确性是显然的（通过基本不等式）。$\square$</p></li></ul><hr><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="裂项公式"><a href="#裂项公式" class="headerlink" title="裂项公式"></a>裂项公式</h3><ul><li>$\frac 1{n(n + k)} = \frac 1k \left( \frac 1n - \frac 1{n + k} \right)$</li><li><p>$\frac 1{(2n - 1)(2n + 1)} = \frac 12 \left( \frac 1{2n - 1} - \frac1{2n + 1} \right)$</p><ul><li>上两条其实是一个一般公式的特殊情况。</li><li>若 $\{ a_n \}$ 是公差为 $d$ 的等差数列，则 $\frac 1{a_n a_{n + 1}} = \frac 1d \left( \frac 1{a_n} - \frac 1{a_{n + 1}} \right)$。</li></ul></li><li><p>$\frac{2^n}{(2^n + 1)(2^{n + 1} + 1)} = \frac{1}{2^n + 1} - \frac{1}{2^{n + 1} + 1}$</p><ul><li>$\frac{x^n}{(x^n + k)(x^{n + 1} + k)} = \frac 1{x - 1} \left( \frac{1}{x^n + k} - \frac{1}{x^{n + 1} + k} \right)$</li></ul></li><li><p>$\frac 1{n(n + 1)(n + 1)} = \frac 12 \left( \frac 1{n(n + 1)} - \frac 1{(n + 1)(n + 2)} \right)$</p></li><li>$\frac 1{ \sqrt n - \sqrt{n + k}} = \frac 1k( \sqrt{n + k} - \sqrt n)$</li></ul><h3 id="和式"><a href="#和式" class="headerlink" title="和式"></a>和式</h3><ul><li>$\sum_{i = 1}^n{i^2} = \frac{n(n + 1)(2n + 1)}6$</li><li>$\sum_{i = 1}^n{i^3} = \left( \frac{n(n + 1)}2 \right)^2$</li></ul><h3 id="不等式-1"><a href="#不等式-1" class="headerlink" title="不等式"></a>不等式</h3><ul><li>$e^x \ge x + 1$，当且仅当 $x = 0$ 时取等号。</li><li>$e^x \ge ex$，当且仅当 $x = 1$ 时取等号。</li><li>$\ln x \le x - 1$，当且仅当 $x = 1$ 时取等号。</li><li>$\ln x \ge 1 - \frac 1x$，当且仅当 $x = 1$ 时取等号。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>立方和差公式：$a^3 \pm b^3 = (a \pm b)(a^2 \mp ab + b^2)$</li><li>已知 $f(x)$ 是定义在 $\R$ 上的函数：<ul><li>若 $f(a + x) = f(b - x)$ 恒成立，则 $y = f(x)$ 的图像关于直线 $x = \frac{a + b}2$ 对称。</li><li>若 $f(a + x) + f(a - x) = 0$ 恒成立，则 $y = f(x)$ 的图像关于点 $(a, 0)$ 中心对称。</li><li>若 $y = f(x)$ 有两条对称轴 $x = a, \ x = b$，则 $y = f(x)$ 为周期函数，且一个周期为 $2|b - a|$。</li></ul></li></ul><hr><h2 id="小题题"><a href="#小题题" class="headerlink" title="小题题"></a>小题题</h2><p>有一堆不等式杂题在隔壁<a href="Ineq-problems.md">这个文件</a>。</p><hr><ul><li><p>（多选）已知曲线 $C: y^2 = 2x + a$ 在点 $P_n(n, \sqrt{2n + a}) \ (a &gt; 0, n \in \N)$ 处的切线 $l_n$ 的斜率为 $k_n$，直线 $l_n$ 交 $x$ 轴、$y$ 轴分别于点 $A_n(x_n, 0)$、$B_n(0, y_n)$，且 $|x_0| = |y_0|$。以下结论中，正确的结论有（）。</p><p>A. $a = 1$</p><p>B. 当 $n \in \N^\ast$ 时，$y_n$ 的最小值为 $\frac{2 \sqrt 3}3$</p><p>C. 当 $n \in \N^\ast$ 时，$k_n &gt; \sqrt 2 \sin \frac 1{ \sqrt{2n + 1}}$</p><p>D. 当 $n \in \N^\ast$ 时，记数列 $k_n$ 的前 $n$ 项和为 $S_n$，则 $S_n &lt; \sqrt 2( \sqrt{n + 1} - 1)$</p></li></ul><p>  答案 ABD。虽然是个大杂烩，但是题确实挺牛逼的。</p><p>  因为 $P_n$ 的纵坐标 $\sqrt{2n + a} \ge 0$，所以可以只考虑 $y \ge 0$ 的情况，即 $y = \sqrt{2x + a}$。则 $y’ = \frac 1{ \sqrt{2x + a}}$，即 $k_n = \frac 1{ \sqrt{2n + a}}$。得 $C$ 在 $P_n$ 处的切线为 $y - \sqrt{2n + a} = \frac 1{ \sqrt{2n + a}} (x - n)$。则有 $x_n = -n - a, \ y_n = \frac{n + a}{ \sqrt{2n + a}}$。</p><p>  A：把 $|x_0| = |y_0|$ 代入得 $|-a| = \left| \frac a{\sqrt a} \right|$，即 $a = 1$，A 正确。且有 $x_n = -n - 1, \ y_n = \frac{n + 1}{ \sqrt{2n + 1}}, \ k_n = \frac 1{ \sqrt{2n + 1}}$。</p><p>  B：令 $t = \sqrt{2n + 1} \in [\sqrt 3, +\infty )$，代入推式子得 $y_n = \frac 12(t + \frac 1t)$。当 $t = \sqrt 3$ 时 $y_n$ 取最小值 $\frac{2 \sqrt 3}3$，B 正确。</p><p>  C：令 $u = k_n = \frac 1t \in \left(0, \frac 1{ \sqrt 3} \right], \ v(u) = \sqrt 2 \sin u - u$，则 $v’(u) = \sqrt 2 \cos u - 1$。由 $0 &lt; u \le \frac 1{ \sqrt 3} &lt; \frac \pi 4$ 得 $v’(u) &gt; 0$，即 $v(u)$ 在 $\left(0, \frac 1{ \sqrt 3} \right]$ 上单调增。$v(u) &gt; v(0) = 0$，所以 $\sqrt 2 \sin u &gt; u$ 恒成立，即 $k_n &lt; \sqrt 2 \sin \frac 1{ \sqrt{2n + 1}}$，C 错误。</p><p>  D：因为 $\left( \frac{a + b}2 \right)^2 \le \frac{a^2 + b^2}2$（当且仅当 $a = b$ 时取等号），所以 $a + b \le \sqrt{2(a^2 + b^2)}$。得到 $\sqrt n + \sqrt{n + 1} \le \sqrt 2 \cdot \sqrt{n + n + 1}$，从而 $\frac 1{ \sqrt{2n + 1}} &lt; \frac{ \sqrt 2}{ \sqrt n + \sqrt{n + 1}} = \sqrt 2( \sqrt{n + 1} - \sqrt n)$。</p><script type="math/tex; mode=display">  \begin{split}  S_n &= \frac 1{ \sqrt 3} + \frac 1{ \sqrt 5} + \cdots + \frac 1{ \sqrt{2n + 1}} \\  &< \sqrt 2(( \sqrt 2 - 1) + (\sqrt 3 - \sqrt 2) + \cdots + (\sqrt{n + 1} - \sqrt n) \\  &= \sqrt 2( \sqrt{n + 1} - 1)  \end{split}</script><p>  D 正确。</p><hr><ul><li>已知正四面体 $A-BCD$ 的外接球的体积为 $8 \sqrt 6 \pi$，求这个四面体的表面积。</li></ul><p>  答案 $16 \sqrt 3$。</p><p>  思路很明确。外接球的半径 $R = \sqrt 6$，接下来就是要想办法求出四面体的棱长。有两种方法。</p><ul><li><p>把这个球画出来，用勾股定理暴力算。设棱长为 $a$，捣鼓半天可以列出这样一个式子：$( \sqrt 6)^2 = \left( \frac{ \sqrt 3}3 a \right)^2 + \left( \frac{ \sqrt 6}3 a - \sqrt 6 \right)^2$。</p></li><li><p>把这个三棱锥放在一个正方体里，如下图：</p><p><img src="/files/img/Note/Math-1.png" style="zoom: 50%;" /></p><p>设正方体的边长为 $a$，则 $\sqrt 3 a = 2R$。又有棱锥的边长等于正方体的面对角线长 $\sqrt 2 a$。</p><p>两种方法都能得到棱锥的边长为 $4$，从而其表面积为 $16 \sqrt 3$。</p><p><strong>这里有一个思想：把棱锥放进长方体，有时候会有意想不到的效果。</strong></p></li></ul><hr><ul><li>在三棱锥 $P-ABC$ 中，$AB = 5, \ BC = 3, \ CA = 4$。三个侧面与底面所成的角均为 $60^\circ$。求三棱锥的内切球的表面积。</li></ul><p>  答案 $\frac{4 \pi}3$。</p><p>  首先底面是个直角三角形，可以求出它的内切圆的半径。底面内切圆半径、侧面三角形的高、棱锥的高组成的三角形已知一条边和两个角，可解。于是就得到了棱锥的表面积 $S$ 和体积 $V$。设 $r$ 为内切球半径，有 $\frac 13 Sr = V$。</p><hr><ul><li><p>（2017 全国 I 理数 T16）如图，圆形纸片的圆心为 $O$，半径为 $5$，该纸片上的等边三角形 $ABC$ 的中心为 $O$。$D, \ E, \ F$ 为圆 $O$ 上的点，$\triangle DBC, \ \triangle ECA, \ \triangle FAB$ 分别是以 $BC, \ CA, \ AB$ 为底边的等腰三角形，沿虚线剪开后，分别以 $BC, \ CA, \ AB$ 为折痕折起 $\triangle DBC, \ \triangle ECA, \ \triangle FAB$，使得 $D, \ E, \ F$ 重合，得到三棱锥。当 $\triangle ABC$ 的边长变化时，求所得三棱锥体积的最大值。</p><p><img src="/files/img/Note/Math-2.png" style="zoom: 50%;" /></p></li></ul><p>  答案 $4 \sqrt{15}$。如图，连接 $OD$ 交 $BC$ 于点 $G$。</p><p>  <img src="/files/img/Note/Math-3.png" style="zoom: 50%;" /></p><p>  显然有 $OD \perp BC$。设 $OG = x$，则 $BC = 2 \sqrt 3 x, \ DG = 5 - x$。三棱锥的高 $h = \sqrt{DG^2 - OG^2} = \sqrt{25 - 10x}$。$V = \frac 13 Sh = \sqrt 3 \cdot \sqrt{25x^4 - 10x^5}$。令 $f(x) = 25x^4 - 10x^5 \ (0 &lt; x &lt; \frac 52)$，导数讨论可得 $f(x)_{ \max} = f(2) = 80$，从而当 $x = 2$ 时 $V_{ \max} = 4 \sqrt{15}$。</p><hr><ul><li>设 $a, b, c &gt; 0$，求证：$\frac{(a + 1)^3}b + \frac{(b + 1)^3}c + \frac{(c + 1)^2}a \ge \frac{81}4$。</li></ul><p>  这是个轮换式，取等号时一定是三项相等，都等于 $\frac{27}4$。此时 $a = b = c = \frac 12$。利用这个可以进行构造。</p><p>  证明：根据均值不等式，$\frac{(a + 1)^3}b + \frac{27}2 b + \frac{27}4 \ge 3 \sqrt[3]{ \frac{3^6 (a + 1)^3}{2^3}} = \frac{27(a + 1)}2$，当且仅当 $a = b = \frac 12$ 时取等号。其他两式同理。三式相加得到 $\mathrm{L.H.S.} + \frac{27}2(a + b + c) + \frac{81}4 \ge \frac{27}2(a + b + c) + \frac{81}2$。当且仅当 $a = b = c = \frac 12$ 时取等号。$\square$</p><p>  这里 $\frac{(a + 1)^3}b + \frac{27}2 b + \frac{27}4$ 这三项是怎么来的呢…第一项是已知的对吧，我们要让它开三次根号，肯定要构造三项。我们已知三个数的值，并且要让构造出的三项都等于 $\frac{27}4$。因为这样最后三式相加，两边都是 $3 \times \frac{81}4$。</p><p>  <strong>这里利用了均值不等式的添项方法。</strong></p><hr><ul><li>设 $a, b, c &gt; 0, \ a + b + c = 1$。求证：$\left(1 + \frac 1a \right) \left(1 + \frac 1b \right) \left(1 + \frac 1c \right) \ge 64$。</li></ul><p>  这个显然是 $a = b = c = \frac 13$ 时取等号。</p><p>  证明：根据基本不等式，$1 + \frac 1a = 1 + \frac 1{3a} + \frac 1{3a} + \frac 1{3a} \ge 4 \sqrt[4]{ \frac 1{27a^3}}$，当且仅当 $a = \frac 13$ 时取等号。其他两式同理。三式相乘得到 $\mathrm{L.H.S.} \ge 64 \sqrt[4]{ \frac 1{3^9 a^3 b^3 c^3}}$，当且仅当 $a = b = c = \frac 13$ 时取等号。又有 $3 \sqrt[3]{abc} \le a + b + c = 1$，所以 $(abc)^3 \le \frac 1{3^9}$，当且仅当 $a = b = c = \frac 13$ 时取等号。$\square$</p><p>  <strong>这里利用了均值不等式的拆项方法。</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> 文化课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 June Records</title>
      <link href="/2020/2020-June-Records/"/>
      <url>/2020/2020-June-Records/</url>
      
        <content type="html"><![CDATA[<p>菜鸡 fa_555 会把一些动态简要地记在这里。主要还是留给自己以后看的。</p><span id="more"></span><p><em>所有代码不保证包括无关紧要的部分</em></p><hr><p>临近省选，不会记太多的东西。</p><hr><h3 id="YY的GCD"><a href="#YY的GCD" class="headerlink" title="YY的GCD"></a><a href="https://www.luogu.com.cn/problem/P2257">YY的GCD</a></h3><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><p>给定 $n, m \ (1 \le n, m \le 10^7)$，求 $1 \le x \le n, 1 \le y \le m$ 且 $\gcd(x, y)$ 为质数的 $(x, y)$ 有多少对。$T \ (1 \le T \le 10^4)$ 组数据。</p><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>不妨设 $n \le m$。设 $t = pd$。</p><script type="math/tex; mode=display">\begin{aligned}& \sum_{i = 1}^n{ \sum_{j = 1}^n{[ \gcd(i, j) \in \mathbb P]}} \\=& \sum_{p \in \mathbb P}{ \sum_{i = 1}^n{ \sum_{j = 1}^n{[ \gcd(i, j) = p]}}} \\=& \sum_{p \in \mathbb P}{ \sum_{i = 1}{ \lfloor n / p \rfloor}{ \sum_{j = 1}{ \lfloor m / p \rfloor}{[ \gcd(i, j) = 1]}}} \\=& \sum_{p \in \mathbb P}{ \sum_{i = 1}{ \lfloor n / p \rfloor}{ \sum_{j = 1}{ \lfloor m / p \rfloor}{ \sum_{d \mid \gcd(i, j)}{ \mu(d)}}}} \\=& \sum_{p \in \mathbb P}{ \sum_{d = 1}{ \lfloor n / p \rfloor}{ \mu(d) \left \lfloor \frac n{pd} \right \rfloor \left \lfloor \frac m{pd} \right \rfloor}} \\=& \sum_{p \in \mathbb P}{ \sum_{d = 1}{ \lfloor n / p \rfloor}{ \mu(d) \left \lfloor \frac nt \right \rfloor \left \lfloor \frac mt \right \rfloor}} \\=& \sum_{t = 1}^n{ \left \lfloor \frac nt \right \rfloor \left \lfloor \frac mt \right \rfloor \sum_{p \in \mathbb P, p \mid t}{ \mu \left( \frac tp \right)}}\end{aligned}</script><p>设 $f(x) = \sum_{p \in \mathbb P, p \mid t}{ \mu(t / p)}$，则 $f(x)$ 可以用埃筛在 $O(n \log \log n)$ 的时间内筛出，答案可以数论分块单次 $O( \sqrt n)$ 询问。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/34298758">code</a></h4><hr><h3 id="无平方因子数"><a href="#无平方因子数" class="headerlink" title="无平方因子数"></a>无平方因子数</h3><h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h4><p>求小于等于 $n$ 的无平方因子数的个数，即求 $\sum_{i = 1}^n{ \mu^2(i)}$。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>考虑一个素数 $p$，那么 $p^2$ 的倍数都有平方因子，个数是 $\lfloor n / p^2 \rfloor$，应该从答案中去掉。</p><p>但是这样又多去掉了一些数。比如对于不同的素数 $p_1, p_2$，$p_1^2 p_2^2$ 就被去掉了两次，个数是 $\lfloor n / (p_1^2 p_2^2) \rfloor$，应该加回来。显然这就是容斥原理。</p><p>如果 $d$ 是 $s$ 个不同素数的乘积，那么其对答案的贡献是 $(-1)^s \lfloor n / d^2 \rfloor$；如果 $d$ 不是不同素数的乘积，即 $d$ 有平方因子，那么 $d$ 对答案没有贡献。</p><p>容斥的系数恰好是 Mobius 函数。因此答案就是</p><script type="math/tex; mode=display">\sum_{i = 1}^n{ \mu^2(i)} = \sum_{d = 1}^\sqrt n{ \mu(d) \left \lfloor \frac n{d^2} \right \rfloor}</script><p>事实上，Mobius 反演本身就可以看成是对整除关系的容斥。</p><hr><h4 id="SDOI2014-数表"><a href="#SDOI2014-数表" class="headerlink" title="[SDOI2014]数表"></a><a href="https://www.luogu.com.cn/problem/P3312">[SDOI2014]数表</a></h4><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>不妨设 $n \le m$。设 $t = dg$。</p><script type="math/tex; mode=display">\begin{align}& \sum_{i = 1}^n{ \sum_{j = 1}^m{ \sigma( \gcd(i, j))}} \\=& \sum_{d = 1}^n{ \sigma(d) \sum_{i = 1}^{ \lfloor n / d \rfloor}{ \sum_{j = 1}^{ \lfloor m / d \rfloor}{[ \gcd(i, j) = 1]}}} \\=& \sum_{d = 1}^n{ \sigma(d) \sum_{i = 1}^{ \lfloor n / d \rfloor}{ \sum_{j = 1}^{ \lfloor m / d \rfloor}{ \sum_{g \mid \gcd(i, j)}{ \mu(g)}}}} \\=& \sum_{d = 1}^n{ \sigma(d) \sum_{g = 1}^{ \lfloor n / d \rfloor}{ \mu(g) \left \lfloor \frac n{dg} \right \rfloor \left \lfloor \frac m{dg} \right \rfloor}} \\=& \sum_{t = 1}^n{ \left \lfloor \frac nt \right \rfloor \left \lfloor \frac mt \right \rfloor \sum_{d | T}{ \sigma(d) \mu \left( \frac td \right)}}\end{align}</script><p>如果没有 $a$ 的限制这题就做完了。</p><p>设 $f(t) = \sum_{d | T}{ \sigma(d) \mu(t / d)}$，则当 $\sigma(d) \le a$ 时才会对 $f$ 产生贡献。</p><p>将询问离线，按 $a$ 升序排序。每次加入会对 $f$ 产生影响的 $\sigma(d)$。</p><p>用树状数组维护 $f$，每次暴力加入所有 $\sigma(d) \le a$ 的 $d$，即令所有满足 $kd \le n$ 的 $f(kd)$ 增加 $\sigma(d) \mu(k)$。</p><p>预处理 $O(n)$，修改 $O(n \log^2 n)$，查询单次 $O( \sqrt n \log n)$。</p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/problem/P3312">code</a></h4><hr><h3 id="SDOI2014-重建"><a href="#SDOI2014-重建" class="headerlink" title="[SDOI2014]重建"></a><a href="https://www.luogu.com.cn/problem/P3317">[SDOI2014]重建</a></h3><h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h4><p>$n \ (1 \le n \le 50)$ 个点，若干条边，每条边有一定几率保留，求保留一棵树的概率。</p><h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>考虑 Matrix-Tree 定理的实质：</p><p>枚举所有生成树 $T$ 和其中的边 $e$，求</p><script type="math/tex; mode=display">\sum_T{ \prod_{e \in T}{p_e}}</script><p>其中 $p$ 可以看做边权或出现概率，因此 $p_e = 1$。</p><p>而本题要求的是</p><script type="math/tex; mode=display">\begin{align}& \sum_T{ \left( \prod_{e \in T}{p_e} \prod_{e \not \in T}{(1 - p_e)} \right)} \\=& \sum_T{ \left( \prod_{e \in T}{p_e} \times \frac{ \prod_e{(1 - p_e)}}{ \prod_{e \in T}{(1 - p_e)}} \right)} \\=& \prod_e{(1 - p_e) \left( \sum_T{ \prod_{e \in T}{ \frac{p_e}{1 - p_e}}} \right)}\end{align}</script><p>把边权设为 $p_e / (1 - p_e)$ 即可。特别地，若 $p_e = 1$，令 $p_e = 1 - \epsilon$ 来避免零作除数。</p><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/34371275">code</a></h4>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数数入门笔记</title>
      <link href="/2020/counting/"/>
      <url>/2020/counting/</url>
      
        <content type="html"><![CDATA[<p>数数太难了，学不会数数。</p><span id="more"></span><p>[TOC]</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h3><p>$S_u(n, m)$ 表示 $n$ 个不同元素构成 $m$ 的圆排列的方案数。</p><script type="math/tex; mode=display">S_u(n, m) = S_u(n - 1, m - 1) + (n - 1) \times S_u(n - 1, m)</script><p>有符号：$S_s(n, m) = (-1)^{n + m} S_u(n, m)$</p><p>有符号生成函数：$x^{ \underline n}$</p><h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3><p>$S(n, m)$ 表示把 $n$ 个不同元素拆分成 $m$ 个非空集合的方案数。</p><script type="math/tex; mode=display">S(n, m) = S(n - 1, m - 1) + m \times S(n - 1, m) \\S(n, m) = \frac 1{m!} \sum{(-1)^k \binom mk (m - k)^n}</script><p>贝尔数为第二类斯特林数之和。</p><h3 id="拆分数"><a href="#拆分数" class="headerlink" title="拆分数"></a>拆分数</h3><p>$f_n$ 代表大小为 $n$ 的正整数拆分成若干个无序的正整数的和的方案数。</p><p>两种 dp，$f_{i, j}$ 表示拆分成若干个小于等于 $j$ 的数字的方案数，$f_{i, j} = f_{i - j, j} + f_{i, j - 1}$。$g_{i, j}$ 表示拆分成 $j$ 个数字的方案数，$g_{i, j} = g_{i - j, j} + g_{i - 1, j - 1}$。</p><p>单独用任何一个复杂度都是 $O(n^2)$。考虑大于 $\sqrt n$ 的数字只有 $\sqrt n$ 个，结合二者，复杂度 $O(n \sqrt n)$。</p><p>生成函数：$\displaystyle \frac 1{ \sum_{n = 0}^\infty{(-1)^k x^{k(3k \pm 1)}}}$</p><h2 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h2><p>形如 $\displaystyle \sum_{n = 0}^\infty{a_n x^n}$。</p><script type="math/tex; mode=display">\sum_{n = 0}^\infty{a_n x^n} \pm \sum_{n = 0}^\infty{b_n x^n} = \sum_{n = 0}^\infty{(a_n \pm b_n) x^n} \\\sum_{n = 0}^\infty{a_n x^n} \pm \sum_{n = 0}^\infty{b_n x^n} = \sum_{n = 0}^\infty{\left( \sum_{k = 0}^n{a_k b_{n - k}}\right) x^n}</script><h3 id="闭形式"><a href="#闭形式" class="headerlink" title="闭形式"></a>闭形式</h3><p>形式幂级数的表达形式是一个长度为无穷的多项式，但是对于部分的形式幂级数，存在长度有限的函数能够直接表示它，我们通常称之为闭形式。</p><p>考虑一个最简单的例子：$\displaystyle \sum_{n = 0}^\infty{x^n} = \frac 1{1 - x}$。</p><p>注意到闭形式其实存在收敛域的问题。但形式幂级数中，$x$ 仅仅是一个符号，我们忽略讨论收敛域。</p><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><ul><li>$\displaystyle \sum_{n = 0}^\infty{x^n} = \frac 1{1 - x}$，这个可以等比数列求和公式（存在收敛域，不讨论）</li><li>显然能得到 $\displaystyle \sum_{n = 1}^\infty{x^n} = \frac x{1 - x}$</li><li>考虑 $\displaystyle \sum_{n = 1}^\infty{n x^n}$，这个怎么求呢？<ol><li>对第一个式子两边求导：$\displaystyle \left( \sum_{n = 0}^\infty{x^n}\right)’ = \left( \dfrac 1{1 - x}\right)’ \Rightarrow \sum_{n = 0}^\infty{(n + 1) x^n} = \frac 1{(1 - x)^2}$。再两边乘 $x$ 即可得到 $\displaystyle \sum_{n = 1}^\infty{n x^n} = \dfrac x{(1 - x)^2}$。</li><li>$\displaystyle \left( \sum_{n = 0}^\infty{x^n}\right) \ast \left( \sum_{n = 0}^\infty{x^n}\right) = \sum_{n = 0}^\infty{(n + 1) x^n} = \frac 1{(1 - x)^2}$，和上一种方法殊途同归。</li></ol></li><li>我们还知道 $\displaystyle \sum_{n = 0}^\infty{ \frac 1{n!} x^n} = e^x$。</li><li>其实上面的几个就是各种生成函数。你已经上贼船了。</li></ul><h2 id="组合对象"><a href="#组合对象" class="headerlink" title="组合对象"></a>组合对象</h2><p>组合计数是一类常见问题，通常给定我们若干组合条件，对于每个组合对象，有某个函数 <code>size</code> 衡量了它的大小，如图的节点数，序列的长度等。<code>size</code> 为 $n$ 的满足组合条件的组合对象个数为有限个，记为 $A_n$ ，题目要求某个 $A_n$。</p><p>组合对象分为是否有标号的两种，指的是是否考虑组合对象内部的元素有不同的区别，例如无标号的三个点的图只有 $4$ 种，而有标号的有 $8$ 种。</p><h2 id="生成函数引入-二项式定理"><a href="#生成函数引入-二项式定理" class="headerlink" title="生成函数引入 - 二项式定理"></a>生成函数引入 - 二项式定理</h2><p>怎么让文化课选手也能理解生成函数呢？我们从大家都会的二项式定理说起。</p><p><em>此处选用了所有亲高中生的写法，比如将组合数 $\displaystyle \binom nm$ 改用 $C_n^m$ 表示。</em></p><p>如果你学过了选修 2-3，你会知道</p><script type="math/tex; mode=display">(1 + x)^n = C_n^0 + C_n^1 x + C_n^2 x^2 + \cdots + C_n^{n - 1} x^{n - 1} + C_n^n x^n</script><p>然后如果你做了（高中数学老师名字隐去）的作业，你会遇到让你求 $C_n^0 - C_n^1 + C_n^2 - C_n^3 + \cdots + (-1)^n C_n^n$ 的题目。作为一名文化课选手，你熟练地将 $x = -1$ 代了进去，并且发现等式左边是 $0$，于是你又做出了一道题，拿到了 5 分。</p><p>你没有局限于文化课固定的垃圾套路，发现了其中的奥秘。你发现，这种操作把一个数列（$C_n^i$）映射到了一个函数（$(x + 1)^n$）上。你开始思考，是不是其他的数列也可以这么操作呢？</p><p>恭喜你，你发现了<strong>生成函数</strong>。通过生成函数，我们可以把数列的运算转化为对函数的运算<del>，借用多项式的运算，大量的毒瘤数数题就此诞生了</del>。</p><h2 id="普通生成函数（OGF）"><a href="#普通生成函数（OGF）" class="headerlink" title="普通生成函数（OGF）"></a>普通生成函数（OGF）</h2><p>数列 $A_0, A_1, \cdots$ 的普通生成函数为 $\displaystyle \sum_{n = 0}^\infty{A_n x^n}$。</p><p>普通生成函数通常考虑无标号问题（组合问题），它的加法操作和乘法操作分别对应了并和拼接两种操作。</p><ul><li>并：无标号 $n$ 个点的图的个数，假如 $\displaystyle \sum_{n = 0}^\infty{a_n x^n}$ 是连通图的 OGF，$\displaystyle \sum_{n = 0}^\infty{b_n x^n}$ 是不连通图的 OGF，$\displaystyle \sum_{n = 0}^\infty{a_n x^n} + \sum_{n = 0}^\infty{b_n x^n}$ 就是所有图的 OGF。</li><li>拼接：有两类物品，拿 $n$ 个物品 A 的方案数为 $a_n$，OGF 为 $\displaystyle \sum_{n = 0}^\infty{a_n x^n}$；拿 $n$ 个物品 B 的方案数为 $b_n$，OGF 为 $\displaystyle \sum_{n = 0}^\infty{b_n x^n}$。那么拿 $n$ 个物品的 OGF 为 $\displaystyle \sum_{n = 0}^\infty{a_n x^n} \ast \sum_{n = 0}^\infty{b_n x^n}$。</li></ul><h3 id="常用的-OGF"><a href="#常用的-OGF" class="headerlink" title="常用的 OGF"></a>常用的 OGF</h3><p><em>↓这个表格某些单元格的对齐方式渲染有问题，有神仙知道原因或解决方案请务必告诉我，谢谢（</em></p><div class="table-container"><table><thead><tr><th style="text-align:center">数列</th><th style="text-align:center">形式幂级数</th><th style="text-align:center">闭形式</th></tr></thead><tbody><tr><td style="text-align:center">$1, 1, 1, \cdots$</td><td style="text-align:center">$\displaystyle \sum_{n = 0}^\infty{x^n}$</td><td style="text-align:center">$\displaystyle \frac 1{1 - x}$</td></tr><tr><td style="text-align:center">$\displaystyle \binom NN, \binom{N + 1}N, \binom{N + 2}N, \cdots$</td><td style="text-align:center">$\displaystyle \sum_{n = 0}^\infty{\binom{N + n}N x^n}$</td><td style="text-align:center">$\displaystyle \frac 1{(1 - x)^{N + 1}}$</td></tr><tr><td style="text-align:center">$1, 1, 1, \cdots, 1$</td><td style="text-align:center">$\displaystyle \sum_{n = 0}^N{x^n}$</td><td style="text-align:center">$\displaystyle \frac{1 - x^{N + 1}}{1 - x}$</td></tr><tr><td style="text-align:center">$1, 0, 0, 1, 0, 0, 1, \cdots \ (a = 3)$</td><td style="text-align:center">$\displaystyle \sum_{n = 0}^\infty{x^{a n}}$</td><td style="text-align:center">$\displaystyle \frac 1{1 - x^a}$</td></tr></tbody></table></div><p>此外还有一些很 trivial 的东西，比如 OGF 乘以 $x$ 相当于数列右移一位。</p><p>把一个数列的 OGF 乘以 $\displaystyle \frac 1{1 - x}$ 相当于对其求前缀和，乘以 $1 - x$ 相当于对其求差分。详见<a href="https://www.luogu.com.cn/problem/P5488">P5488 差分与前缀和</a>。</p><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>令 $f_n$ 为斐波那契数列，$f_1 = f_2 = 1$，如何求出 $\displaystyle \sum_{n = 0}^\infty{f_n x^n}$ 的闭形式？</p><p>令 $\displaystyle F_n = \sum_{n = 0}^\infty{f_n x^n}$，由 $f_n = f_{n - 1} + f_{n - 2}$ 可以得到 $F(x) = x F(x) + x^2 F(x) + x$。解方程得 $\displaystyle F(x) = \frac x{1 - x - x^2}$。</p><p>$1 - x - x^2$ 怎么因式分解呢？</p><p>待定系数法，设 $(1 + ax)(1 + bx) = (1 - x - x^2)$，解得 $a, b$ 分别是 $\displaystyle \frac{-1 \pm \sqrt 5}2$。此时有</p><script type="math/tex; mode=display">F(x) = \frac x{ \left(1 - \frac{1 + \sqrt 5}2 x \right) \left(1 - \frac{1 - \sqrt 5}2 x \right)}</script><p>考虑裂项和待定系数法，设 $\displaystyle \frac A{1 + ax} + \frac B{1 + bx} = F(x)$。取 $\displaystyle a = \frac{-1 + \sqrt 5}2$，解得 $\displaystyle A = \frac 1{ \sqrt 5}, B = - \frac 1{ \sqrt 5}$。</p><p>这样，我们就得到了</p><script type="math/tex; mode=display">F(x) = \frac 1{ \sqrt 5} \left( \frac 1{1 - \frac{1 + \sqrt 5}2 x} - \frac 1{1 - \frac{1 - \sqrt 5}2 x} \right)</script><p>因为 $\displaystyle \sum_{n = 0}^\infty{a x^n} = \frac 1{1 - ax}$，代入得</p><script type="math/tex; mode=display">f_n = [x^n] F(x) = \frac 1{ \sqrt 5} \left( \left( \frac{1 + \sqrt 5}2 \right)^n - \left( \frac{1 - \sqrt 5}2 \right)^n \right)</script><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>如何求节点数为 $n$ 的二叉树的个数？</p><p>直接大力推式是可以的，但是太麻烦了完全看不懂。</p><p>注意到生成函数本身是具有组合性质的。令 $F(x)$ 表示该问题的生成函数，考虑一棵二叉树可以划分成根节点和左右两个子树，得到 $F(x) = x F^2(x) + 1$。解方程得 $\displaystyle F(x) = \frac{1 - \sqrt{1 - 4x}}{2x}$。</p><p>$\displaystyle F(x) = \sum_{n = 0}^\infty{ \frac{(2n)!}{n! (n + 1)!} x^n}$，证明从略。</p><h2 id="指数型生成函数（EGF）"><a href="#指数型生成函数（EGF）" class="headerlink" title="指数型生成函数（EGF）"></a>指数型生成函数（EGF）</h2><p>数列 $A_0, A_1, \cdots$ 的指数型生成函数为 $\displaystyle \sum_{n = 0}^\infty{A_n \frac{x^n}{n!}}$。</p><p>在处理有标号问题（排列问题）的时候，我们通常使用指数型生成函数。在这样的定义下，加法和乘法依然保持了性质。</p><h3 id="常用的-EGF"><a href="#常用的-EGF" class="headerlink" title="常用的 EGF"></a>常用的 EGF</h3><div class="table-container"><table><thead><tr><th style="text-align:center">数列</th><th style="text-align:center">形式幂级数</th><th style="text-align:center">闭形式</th></tr></thead><tbody><tr><td style="text-align:center">$1, 1, 1, \cdots$</td><td style="text-align:center">$\displaystyle \sum_{n = 0}^\infty{ \frac{x^n}{n!}}$</td><td style="text-align:center">$e^x$</td></tr><tr><td style="text-align:center">$1, 0, 1, \cdots$</td><td style="text-align:center">$\displaystyle \sum_{n = 0}^\infty{ \frac{x^{2n}}{(2n)!}}$</td><td style="text-align:center">$\displaystyle \frac{e^x + e^{-x}}{2}$</td></tr><tr><td style="text-align:center">$0, 1, 0, \cdots$</td><td style="text-align:center">$\displaystyle \sum_{n = 0}^\infty{ \frac{x^{2n + 1}}{(2n + 1)!}}$</td><td style="text-align:center">$\displaystyle \frac{e^x - e^{-x}}{2}$</td></tr></tbody></table></div><h2 id="群论相关"><a href="#群论相关" class="headerlink" title="群论相关"></a>群论相关</h2><p>这里推荐<a href="https://blog.csdn.net/liangzhaoyang1/article/details/72639208">一篇博客</a>，讲的是比我下面抄的课件要清楚的。</p><h3 id="群的定义"><a href="#群的定义" class="headerlink" title="群的定义"></a>群的定义</h3><p>定义集合 $G$ 和作用于 $G$ 中的元素的二元运算 $\oplus$，若其满足以下性质，则称其为一个群，记作 $(G, \oplus)$。</p><ol><li>封闭性<br>对于任意 $a \in G, b \in G$，都有 $a \oplus b \in G$。</li><li>结合律<br>对于任意 $a, b, c$，有 $(a \oplus b) \oplus c = a \oplus (b \oplus c)$。</li><li>单位元<br>存在唯一的 $e \in G$，满足对于任意 $a \in G$ 有 $a \oplus e = e \oplus a = a$。</li><li>逆元<br>对于任意 $a \in G$，存在唯一的 $a’ \in G$ 满足 $a \oplus a’ = a’ \oplus a = e$。</li></ol><h3 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h3><p>置换就是对元素进行重排列。</p><p>置换群指的是一个置换的集合，满足任意两个置换不能复合出一个新的不在集合内的置换。</p><h3 id="Burnside-引理"><a href="#Burnside-引理" class="headerlink" title="Burnside 引理"></a>Burnside 引理</h3><p>令 $X$ 表示某个集合，令 $G$ 表示作用在 $X$ 上的某个置换群。对于任意 $G$ 内的元素 $g$，定义 $f(g)$ 为 $X$ 内经过置换 $g$ 后不变的元素的数量。我们要求的是 $X$ 内本质不同的元素的个数，本质不同指不能通过 $G$ 获得彼此，记为 $|X / G|$。</p><script type="math/tex; mode=display">|X / G| = \frac 1{|G|} \sum_{g \in G}{f(g)}</script><h3 id="Polya-定理"><a href="#Polya-定理" class="headerlink" title="Polya 定理"></a>Polya 定理</h3><p>令 $G$ 是 $X$ 的一个置换群，$|X| = n$，用 $m$ 种颜色染色，本质不同的染色方案是</p><script type="math/tex; mode=display">|X / G| = \frac 1{|G|} \sum_{g \in G}{m^{c(g)}}</script><p>其中 $c(g)$ 表示 $g$ 的循环节数。</p><p>通常我们并不需要枚举所有的 $g$ 计算 $c(g)$，而是枚举 $c(g)$ 快速计算多少 $g$ 满足条件。</p><h2 id="线性代数相关"><a href="#线性代数相关" class="headerlink" title="线性代数相关"></a>线性代数相关</h2><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>一个方阵 $A$ 的行列式表示为 $|A|$ 或 $\det(A)$。</p><script type="math/tex; mode=display">\det(A) = \sum_{p}{(-1)^{ \sigma(p)}}{ \prod_{i = 1}^n{a_{i, p_i}}}</script><p>其中 $p$ 表示一个排列，$\sigma(p)$ 表示 $p$ 的逆序对数。使用高斯消元快速计算行列式的值。</p><h4 id="行列式的性质："><a href="#行列式的性质：" class="headerlink" title="行列式的性质："></a>行列式的性质：</h4><ul><li>对角矩阵 / 上三角矩阵 / 下三角矩阵的行列式是主对角线上元素的乘积。</li><li>交换矩阵的两行，行列式的值取相反数。</li><li>将矩阵的一行的所有元素乘上一个相同的常数 $k$，行列式的值也乘上 $k$。</li><li>将矩阵的一行加到另外一行上去，行列式的值不变。</li><li>由于转置的存在，行列式所有对行成立的性质对列也成立。</li></ul><h3 id="Matrix-Tree-定理"><a href="#Matrix-Tree-定理" class="headerlink" title="Matrix-Tree 定理"></a>Matrix-Tree 定理</h3><p>对于无向图 $G$，定义 $G$ 的度数矩阵 $D$：</p><script type="math/tex; mode=display">D_{i, j} = \begin{cases}\deg_i &, i = j \\0 &, i \ne j\end{cases}</script><p>定义 $G$ 的基尔霍夫矩阵 $L = D - C$，其中 $C$ 代表 $G$ 的邻接矩阵，则图 $G$ 的生成树数量是 $L$ 的任意一个代数余子式。</p><h4 id="简单拓展"><a href="#简单拓展" class="headerlink" title="简单拓展"></a>简单拓展</h4><p>带权图的生成树：</p><p>定义一棵树的权值是树上所有边的总权值。</p><p>我们将度数矩阵中的度数改为与它相连的所有边的边权和，邻接矩阵的连通性改为边权，就可以求出所有生成树的权值和。</p><p>有向图的生成树形图计数：</p><p>我们将度数矩阵中的度数改为入度，邻接矩阵改为有向图的邻接矩阵，那么以 $x$ 为根的树形图个数即为 $L_{x, x}$。</p><h4 id="Best-theorem"><a href="#Best-theorem" class="headerlink" title="Best theorem"></a>Best theorem</h4><p>一个有向图 $G$ 的欧拉回路的数量是</p><script type="math/tex; mode=display">t_1(G) \prod_{i = 1}^n{(\deg(i) - 1)!}</script><p>其中 $t_1(G)$ 表示图 $G$ 的以 $1$ 为根的树形图的数量。</p><h2 id="几道例题"><a href="#几道例题" class="headerlink" title="几道例题"></a>几道例题</h2><h3 id="连通图计数-集训队作业2013-城市规划"><a href="#连通图计数-集训队作业2013-城市规划" class="headerlink" title="连通图计数 - [集训队作业2013]城市规划"></a>连通图计数 - <a href="https://fa555.github.io/2020/2020-Apr-Records/#%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92">[集训队作业2013]城市规划</a></h3><p>这篇题解是刚学多项式求逆的时候写的，学完 OGF 和 EGF 之后重看题解学会了很多东西，并且有了个新方法（待补）</p><h3 id="洛谷模板题"><a href="#洛谷模板题" class="headerlink" title="洛谷模板题"></a><a href="https://www.luogu.com.cn/problem/P4980">洛谷模板题</a></h3><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><p>一个 $n$ 个点 $n$ 条边的环，给点任意染色，求有多少种本质不同的染色方案，对 $10^9 + 7$ 取模。</p><p>两种染色方案本质不同，当且仅当其任意旋转后不能重合。</p><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>有 $n$ 种置换，分别为顺时针旋转 $0 \sim n - 1$ 格。其中对于顺时针旋转 $i$ 格的置换，每个循环节的长度为 $\displaystyle \frac n{ \gcd(i, n)}$，循环节个数为 $\gcd(i, n)$。</p><p>设答案为 $L$，朴素 Polya 定理的式子是 $\displaystyle L = \frac 1n \sum_{i = 1}^n{n^{ \gcd(i, n)}}$，这个显然是要超时的。</p><p>枚举 $\gcd$ 稍微推一下式子得到 $\displaystyle L = \sum_{d | n}{n^{d - 1} \varphi \left(\frac nd\right)}$。</p><p>设 $n$ 的唯一分解 $\displaystyle n = \prod_{i = 1}^m{p_i^{c_i}}$，对所有 $1 \le i \le m$ 预处理 $\varphi(p_i), \varphi(p_i^2), \cdots, \varphi(p_i^{c_i})$。通过枚举 $p_i$ 的指数枚举 $d$ 即可在 $O(1)$ 求 $\displaystyle \varphi\left(\frac nd\right)$。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/34274059">code</a></h4>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组学习笔记</title>
      <link href="/2020/Suffix-Array/"/>
      <url>/2020/Suffix-Array/</url>
      
        <content type="html"><![CDATA[<blockquote><p> <strong>后缀数组是解决字符串问题的有力工具。</strong></p><p>“后缀数组哪里难？后缀难还是数组难？”</p></blockquote><span id="more"></span><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>这玩意挺多写法的，我的数字排序的基数排序板子（洛谷模板题比 <code>std::sort</code> 要快）和后缀数组要用的并不一样。理解下原理就好。</p><h3 id="倍增法求后缀数组"><a href="#倍增法求后缀数组" class="headerlink" title="倍增法求后缀数组"></a>倍增法求后缀数组</h3><p>实现后缀数组的方式主要有两种：倍增法 $O(n \log n)$ 和 DC3 法 $O(n)$。由于我太菜所以只学倍增法。</p><h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><p>$S$：原串，下标从 $1$ 到 $n$。</p><p>$\mathrm{Suf}_i$：$S_{i \dots n}$，即从位置 $i$ 开始的后缀；$\mathrm{Suf}_{i, k}$：$S_{i, i + 2^k - 1}$。</p><p>$\mathrm{Rank}_i$：$\mathrm{Suf}_i$ 的排名；$\mathrm{Rank}_{i, k}$：$\mathrm{Suf}_{i, k}$ 的排名。</p><p><code>sa[i]</code>：排名为 $i$ 的后缀的位置。</p><p><code>rk[i]</code>：$\mathrm{Rank}_{i}$。</p><p><code>t[i]</code>：基数排序第二关键字为 $i$ 的后缀的位置。</p><p><code>c[i]</code>：基数排序辅助数组，$i$ 号元素出现次数。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>目标：对于所有 $\mathrm{Suf}_i$ 排序。</p><p>令第 $k$ 个阶段为所有 $\mathrm{Suf}_{i, k}$ 已排序，则目标为 $k \to O( \log n)$，问题转化为如何对 $\mathrm{Suf}_{i, k + 1}$ 排序。</p><p>注意到 $\mathrm{Suf}_{i, k + 1} = \mathrm{Suf}_{i, k} + \mathrm{Suf}_{i + 2^k, k}$。要比较 $\mathrm{Suf}_{a, k + 1}$ 和 $\mathrm{Suf}_{b, k + 1}$，即比较 $\mathrm{Suf}_{a, k} + \mathrm{Suf}_{a + 2^k, k}$ 和 $\mathrm{Suf}_{b, k} + \mathrm{Suf}_{b + 2^k, k}$。因此 $\mathrm{Suf}_{i, k + 1}$ 可以看作二元组 $(\mathrm{Rank}_{i, k}, \mathrm{Rank}_{i + 2^k, k})$ 进行排序。</p><p>初始时 $\mathrm{Suf}_{i, 0} \ (S_i)$ 一般可以看作二元组 $(S_i, i)$。</p><h3 id="Height-数组"><a href="#Height-数组" class="headerlink" title="Height 数组"></a>Height 数组</h3><p><em>如果你是在复习看到这里，一定要扔下任何事情认真读。这里写得非常非常绕。</em></p><p>定义 Height 数组 <code>H[i]</code> 表示排名为 $i$ 的后缀和排名为 $i - 1$ 的后缀的最长前缀的长度，即 $\operatorname{LCP}(\mathrm{sa}_i, \mathrm{sa}_{i - 1})$。</p><h4 id="前置结论"><a href="#前置结论" class="headerlink" title="前置结论"></a>前置结论</h4><ol><li><p>对于一个位置 $i \ (i &gt; 1)$，$\operatorname{LCP}(i, i - 1) \ge \operatorname{LCP}(i, j) \ (1 \le j &lt; i)$。也就是说，相邻的后缀的 $\operatorname{LCP}$ 最长。</p><ul><li>这个直接反证法即可。如果存在 $\operatorname{LCP}$ 更长的后缀，那它的排名应当更接近。</li></ul></li><li><p><code>H[rk[i]] &gt;= H[rk[i - 1]] - 1</code></p><ul><li>证明：当 $H_{\mathrm{Rank}_{i - 1}} \le 1$ 时显然成立。否则，设 $\mathrm{Rank}_j = \mathrm{Rank}_{i - 1} - 1$，那么将有 $\mathrm{Rank}_{j + 1} &lt; \mathrm{Rank}_i$ 且 $\operatorname{LCP}(i, k + 1) = H_{i - 1} - 1$。由结论 1 得 $H_i \ge H_{i - 1} - 1$。</li></ul></li></ol><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>有了这个结论，计算就很容易了。维护一个 $p$，$p$ 最多自增 $O(n)$ 次，复杂度是 $O(n)$ 的。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SA &#123;</span><br><span class="line">  arr c, rk, sa, t, H;</span><br><span class="line">  <span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">      ++c[rk[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M; ++i)</span><br><span class="line">      c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; --i)</span><br><span class="line">      sa[c[rk[t[i]]]--] = t[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sufSort</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    M = <span class="string">&#x27;z&#x27;</span> - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>; <span class="comment">// the size of charset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">      rk[i] = s[i] - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>, t[i] = i;</span><br><span class="line">    <span class="built_in">radixSort</span>();</span><br><span class="line">    M = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; M &lt; N; w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      M = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = N - w + <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        t[++M] = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">if</span> (sa[i] &gt; w) t[++M] = sa[i] - w;</span><br><span class="line">      <span class="built_in">radixSort</span>();</span><br><span class="line">      <span class="built_in">memcpy</span>(t + <span class="number">1</span>, rk + <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * N);</span><br><span class="line">      rk[sa[<span class="number">1</span>]] = M = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">        rk[sa[i]] = (t[sa[i - <span class="number">1</span>]] == t[sa[i]] &amp;&amp; t[sa[i - <span class="number">1</span>] + w] == t[sa[i] + w]) ? M : ++M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">while</span> (s[i + j] == s[sa[rk[i] - <span class="number">1</span>] + j]) ++j;</span><br><span class="line">      H[rk[i]] = j;</span><br><span class="line">      <span class="keyword">if</span> (j) --j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// SA</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> SA;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="两个后缀的最长公共前缀"><a href="#两个后缀的最长公共前缀" class="headerlink" title="两个后缀的最长公共前缀"></a>两个后缀的最长公共前缀</h4><p>对于两个位置 $x, y \ (x &lt; y)$，$\operatorname{LCP}(x, y) = \min_{i = \mathrm{Rank}_{x + 1}}^{ \mathrm{Rank}_y} H_i$。</p><p>这个可以用 ST 表实现 $O(1)$ 查询。</p><h4 id="可重叠最长重复子串"><a href="#可重叠最长重复子串" class="headerlink" title="可重叠最长重复子串"></a>可重叠最长重复子串</h4><p>求最长的子串使得其至少出现了 $2$ 次，不同出现次数之间可以重叠。</p><p>这个就是 $\max_{i = 1}^n \{ H_i \}$ 了。</p><h4 id="可重叠-k-次最长重复子串"><a href="#可重叠-k-次最长重复子串" class="headerlink" title="可重叠 $k$ 次最长重复子串"></a>可重叠 $k$ 次最长重复子串</h4><p>求最长的子串使得其至少出现了 $k$ 次，不同出现次数之间可以重叠。</p><p>先考虑二分这个答案 $l$，发现 Height 数组大于等于 $l$ 的位置形成了若干个联通块，$O(n)$ <code>check</code> 即可。</p><p><a href="http://poj.org/showsource?solution_id=21696210">POJ3261 code</a></p><p>wucstdio 说连二分都不需要，我是完全不懂哦</p><h4 id="不可重叠最长重复子串"><a href="#不可重叠最长重复子串" class="headerlink" title="不可重叠最长重复子串"></a>不可重叠最长重复子串</h4><p>求最长的子串使得其至少出现了 $2$ 次，不同出现次数之间不能重叠。</p><p>还是二分一个答案 $l$，在 <code>check</code> 的时候判断一下每个连通块中的位置极差是否大于等于 $l$ 即可。注意细节。</p><p><a href="http://poj.org/showsource?solution_id=21696791">POJ1743 code</a></p><h4 id="不同子串的个数"><a href="#不同子串的个数" class="headerlink" title="不同子串的个数"></a>不同子串的个数</h4><p>如果 $H_i = l$，那么长度为 $1 \sim l$ 的所有前缀都会被多算一次，答案减去 $H_i$。总答案为 $n(n + 1) / 2 - \sum_{i = 1}^n{H_i}$。</p><h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><p>给定两个字符串 $S, T, n = |S|, m = |T|$，求它们的最长公共子串。</p><p>把两个串拼在一起，中间加一个特殊字符隔开。那么要求的就是</p><script type="math/tex; mode=display">\max_{i \in [1, n], j \in [n + 2, n + m + 1]}{ \operatorname{LCP}(i, j)}</script><p>取到这个最大值的一定是相邻的后缀，枚举 $i$ 更新答案。</p><p><a href="http://poj.org/showsource?solution_id=21697442">POJ2217 code</a></p><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><p><del>这个 Manacher 就可以线性做</del></p><p>把这个串取反接到原串后面。</p><p>枚举中心点，一个回文子串就是两个位置的 $\operatorname{LCP}$。</p><p><del>这样用后缀数组 + ST 表就可以做到 $O(n \log n)$ 的优秀复杂度</del></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 May Records</title>
      <link href="/2020/2020-May-Records/"/>
      <url>/2020/2020-May-Records/</url>
      
        <content type="html"><![CDATA[<p>菜鸡 fa_555 会把一些动态简要地记在这里。主要还是留给自己以后看的。</p><span id="more"></span><p><em>所有代码不保证包括无关紧要的部分</em></p><hr><h3 id="TJOI2013-松鼠聚会"><a href="#TJOI2013-松鼠聚会" class="headerlink" title="[TJOI2013]松鼠聚会"></a><a href="https://www.luogu.com.cn/problem/P3964">[TJOI2013]松鼠聚会</a></h3><h3 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h3><p>给定平面上的 $n \ (0 \le n \le 10^5)$ 个点 $(x, y) \ (-10^9 \le x, y \le 10^9)$，选出一个点使得其他所有点到这个点的<strong>切比雪夫距离</strong>之和最小，求出这个最小值。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>有结论：</p><ul><li>将所有点 $(x,y)$ 修改为 $(x + y, x − y)$ 后，原坐标系中的曼哈顿距离等于新坐标系中的切比雪夫距离；</li><li>将所有点 $(x,y)$ 修改为 $(\frac{x + y}2, \frac{x - y}2)$ 后，原坐标系中的切比雪夫距离等于新坐标系中的曼哈顿距离。</li></ul><p>于是可以推式子。假设已经将所有点转化为曼哈顿坐标系中的点，且已按照 $x$ 坐标升序排序，对于一个点 $(x_i, y_i)$，有</p><script type="math/tex; mode=display">\begin{align}\sum_{j = 1}^n{|x_i - x_j|} &= \sum_{j = 1}^i{(x_i - x_j)} + \sum_{j = i + 1}^n{(x_j - x_i)} \\&= i x_i - \sum_{j = 1}^i{x_j} + \sum_{j = i + 1}^n{x_j} - (n - i) x_i \\&= (2i - n) x_i + S_n - 2 S_i\end{align}</script><p>其中 $S_i = \sum_{j = 1}^i{x_i}$。$y$ 坐标同理。</p><p>这玩意排序之后 $O(n)$ 整就行了，总复杂度是 $O(n \log n)$ 的。</p><hr><h3 id="HNOI2010-弹飞绵羊"><a href="#HNOI2010-弹飞绵羊" class="headerlink" title="[HNOI2010]弹飞绵羊"></a><a href="https://www.luogu.com.cn/problem/P3203">[HNOI2010]弹飞绵羊</a></h3><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>考虑暴力，维护每个位置弹到哪个位置、需要几步弹飞。这样做修改是 $O(n)$ 的，查询是 $O(1)$ 的。我们要想办法平衡两者的复杂度。</p><p>考虑分块，对于每个位置维护弹到块外的哪个位置、需要几步弹出块。这样修改和查询都是 $O(\sqrt n)$ 的，总复杂度 $O(n \sqrt n)$。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/problem/P3203">code</a></h4><hr><h3 id="教主的魔法"><a href="#教主的魔法" class="headerlink" title="教主的魔法"></a><a href="https://www.luogu.com.cn/problem/P2801">教主的魔法</a></h3><p>区间带修求排名，参见数列分块入门 2。</p><hr><h3 id="Dynamic-Rankings"><a href="#Dynamic-Rankings" class="headerlink" title="Dynamic Rankings"></a><a href="https://www.luogu.com.cn/problem/P2617">Dynamic Rankings</a></h3><p>区间带修求第 k 小模板题。</p><p>区间可以看作 $\log$ 棵线段树和 $\log$ 棵线段树作差。可以通过树状数组套主席树实现。空间 $O(n \log^2 n)$，时间 $O(n \log n)$。</p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/33443620">code</a></h4><hr><h3 id="CF1433N-Monopole-Magnet"><a href="#CF1433N-Monopole-Magnet" class="headerlink" title="CF1433N Monopole Magnet"></a><a href="http://codeforces.com/problemset/problem/1344/B">CF1433N Monopole Magnet</a></h3><h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h4><p>给定一个 $n$ 行 $m$ 列 $(1 \le n, m \le 1000)$ 的棋盘，其中每个格子被染成了黑色或白色。你需要在棋盘格子里放置一些单极磁铁。每个格子可以放任意多个磁铁。</p><p>定义单极磁铁的吸引：任选一对 N 磁铁和 S 磁铁，如果它们处在同一行或同一列中且不处在同一格中，则 N 磁铁向 S 磁铁的方向靠近 1 格。</p><p>磁铁的放置需要满足以下要求：</p><ul><li><p>每行每列都至少要有一个 S 磁铁。</p></li><li><p>对于每个黑色格子，必须有 N 磁铁经过若干次吸引操作后<strong>能够</strong>到达该格。</p></li><li><p>对于每个白色格子，必须有 N 磁铁经过任意次吸引操作后<strong>不能</strong>到达该格。</p></li></ul><p>求最少的 N 磁铁的个数或判断无合法方案。</p><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>考虑黑色格子直接放满 S 磁铁，随便一想发现有解的情况就是求连通块个数，重点在于判断有无合法解。</p><p>再一想发现有且仅有这两种情况无解：</p><ul><li>同一行或同一列的两个黑色格子中间有白色格子。</li><li>某行没有黑色格子<strong>异或</strong>某列没有黑色格子。如果有行和列都没有黑色格子，那么 S 磁铁可以放在它们的交点处。</li></ul><p><del>（情况 1 限制 23）和（情况 2 限制 1）感觉就是两道题强行拼起来的</del></p><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/33468115">code</a></h4><hr><h3 id="CF1344D-Resume-Review"><a href="#CF1344D-Resume-Review" class="headerlink" title="CF1344D Résumé Review"></a><a href="http://codeforces.com/problemset/problem/1344/D">CF1344D Résumé Review</a></h3><h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h4><p>给定一个长为 $n \ (1 \le n \le 10^5)$ 的序列 $a \ (1 \le a_i \le 10^9)$，构造序列 $b$ 满足</p><ul><li>$\forall 1 \le i \le n, \ 0 \le b_i \le a_i$</li><li>$\sum_{i = 1}^n{b_i} = k$</li></ul><p>并最大化 $\sum_{i = 1}^n{b_i (a_i - b_i^2)}$。输出任意一组解。</p><h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>这里大部分抄了 CF 官方题解。</p><p>如果我们对于某个 $b_i$ 从 $x - 1$ 自增到 $x$，那么总价值将会变化</p><script type="math/tex; mode=display">\Delta_i(x) = x (a_i - x^2) - (x - 1)(a_i - (x - 1)^2) = a_i - 3x^2 + 3x - 1</script><p>这个函数在 $x \ge 1$ 时单调减。</p><p>如果初始时令 $b_i = 0$，贪心地增加当前最佳的 $b_i$，那么就能获得最优解，然而至少 $O(k \log n)$ 的复杂度是我们所不能接受的。</p><p>我们可以二分某个 $A$，使得使得 $\Delta_i(x_i) \ge A$ 的 $\sum{x_i}$ 恰好等于 $k$。<code>check</code> 时求 $x_i$ 可以通过求根公式或另一次二分答案得到。总复杂度是 $O(n \log k)$ 或 $O(n \log^2 k)$ 的。</p><h4 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h4><p><a href="https://www.luogu.com.cn/record/33898144">洛谷</a> / <a href="https://codeforces.com/contest/1344/submission/81432655">Codeforces</a></p><hr><h3 id="扩展-KMP-算法（Z-算法）"><a href="#扩展-KMP-算法（Z-算法）" class="headerlink" title="扩展 KMP 算法（Z 算法）"></a>扩展 KMP 算法（Z 算法）</h3><p>咕咕咕</p><hr><h3 id="一般图最大匹配（带花树算法）"><a href="#一般图最大匹配（带花树算法）" class="headerlink" title="一般图最大匹配（带花树算法）"></a>一般图最大匹配（带花树算法）</h3><h4 id="solution-by-Fuyuki"><a href="#solution-by-Fuyuki" class="headerlink" title="solution by Fuyuki"></a><a href="https://www.luogu.com.cn/blog/_post/215158">solution by Fuyuki</a></h4><p>我完全无法复述得更好了。</p><h4 id="code-4"><a href="#code-4" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/33540939">code</a></h4><p><strong>洛谷板题数据非常水，一定要去 UOJ 测，一定要去 UOJ 测，一定要去 UOJ 测</strong></p><hr><h3 id="WC2016-挑战NPC"><a href="#WC2016-挑战NPC" class="headerlink" title="[WC2016]挑战NPC"></a><a href="https://www.luogu.com.cn/problem/P4258">[WC2016]挑战NPC</a></h3><p>一般图最大匹配的应用不多，只找到了这一个题。</p><h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem"></a>problem</h4><p>有 $n \ (1 \le n \le 3m)$ 个球和 $m \ (1 \le m \le 100)$ 个筐子，每个筐子最多可以装三个球。有 $e \ (1 \le e \le nm)$ 个条件，条件 $(u, v)$ 表示编号为 $v$ 的球可以放进编号为 $u$ 的筐子中。</p><p>每个球都必须放进一个筐子中，称放有不超过 $1$ 个球的筐子为半空的。求半空的筐子最多有多少个，并输出一个最优方案。</p><h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h4><p>这题的思路非常妙。建图方式是这样的：对每个篮子拆成 $3$ 个点，在这 $3$ 个点之间两两连边，在对 $e$ 个条件连 $3e$ 条边。为什么这样是对的？</p><p>分别考虑每个篮子放入 $0, 1, 2, 3$ 个球的情况。这时它们对答案的贡献分别是 $1, 2, 2, 3$，而我们希望它们的贡献分别是 $1, 1, 0, 0$。作差得到 $0, 1, 2, 3$，因此这样统计到的贡献减去球的个数就是正确答案！</p><p>注意一个问题，最终的匹配中要优先匹配球再匹配筐，否则会输出错误的方案。<del>因为这个卡了一晚</del></p><h4 id="code-5"><a href="#code-5" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/33544050">code</a></h4><hr><h3 id="PKUWC2018-Slay-the-Spire"><a href="#PKUWC2018-Slay-the-Spire" class="headerlink" title="[PKUWC2018]Slay the Spire"></a><a href="https://www.luogu.com.cn/problem/P5299">[PKUWC2018]Slay the Spire</a></h3><p>由于 fa_555 非常喜欢玩 Slay the Spire，他跑来写（抄）了这题。但是这题和游戏一点关系也没有。</p><h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem"></a>problem</h4><p>有 $n$ 张强化牌 $a_i$ 和 $n$ 张攻击牌 $b_i$，每张牌有一个 $[1, 10^8]$ 之间的权值，每张强化牌能使所有攻击牌的权值乘上这张强化牌的权值。</p><p>任意摸 $m$ 张牌，以最优策略出 $k$ 张牌，求造成伤害的期望乘以 $\binom {2n}m$。答案模 $998244353$。</p><h4 id="solution-转化"><a href="#solution-转化" class="headerlink" title="solution - 转化"></a>solution - 转化</h4><p>首先发现要求的这个东西其实就是所有情况下造成的伤害总和。</p><p>考虑如果现在已经选定了 $m$ 张牌，最优策略是什么？</p><ul><li>如果已经确定用 $x$ 张强化牌和 $y$ 张攻击牌，那么肯定是先用权值最大的 $x$ 张强化牌，再用权值最大的 $y$ 张攻击牌。</li><li>在保证至少出一张攻击牌的情况下，尽量多出强化牌一定不会使答案更劣。<ul><li>这个不必严谨地推式子，只要考虑强化牌至少能使权值最大的攻击牌的权值翻倍，不劣于选其他任何攻击牌即可。</li></ul></li></ul><h4 id="solution-预处理"><a href="#solution-预处理" class="headerlink" title="solution - 预处理"></a>solution - 预处理</h4><p>设 $f_{i, j, 0}$ 表示前 $i$ 张强化牌中选择 $j$ 张且第 $i$ 张被选中的<strong>所有情况</strong>下这 $j$ 张牌的乘积<strong>之和</strong>；$g_{i, j, 0}$ 表示前 $i$ 张攻击牌中选择 $j$ 张且第 $i$ 张被选中的<strong>所有情况</strong>下这 $j$ 张牌的和<strong>之和</strong>。同时设 $f_{i, j, 1} = \sum_{k = j}^i{f_{k, j, 0}}, \ g_{i, j, 1} = \sum_{k = j}^i{g_{k, j, 0}}$，那么可得</p><script type="math/tex; mode=display">\begin{align}f_{i, j, 0} &= a_i \cdot f_{i - 1, j - 1, 1} \\f_{i, j, 1} &= f_{i, j, 0} + f_{i - 1, j, 1} \\g_{i, j, 0} &= b_i \cdot \binom{i - 1}{j - 1} + g_{i - 1, j - 1, 1} \\g_{i, j, 1} &= g_{i, j, 0} + g_{i - 1, j, 1}\end{align}</script><h4 id="solution-统计答案"><a href="#solution-统计答案" class="headerlink" title="solution - 统计答案"></a>solution - 统计答案</h4><p>分两种情况：</p><p><strong>其一，$m$ 张牌中强化牌的数量小于 $k - 1$</strong></p><p>此时必然是出所有强化牌，然后出权值最大的一些攻击牌。</p><p>枚举强化牌有 $i$ 张、选中的最后一张攻击牌是第 $j$ 张。</p><p>如果要保证最优方案是这 $k$ 张牌，剩下的 $m - k$ 张牌还需要满足<strong>全部都是攻击牌，并且都在第 $j$ 张之后</strong>。</p><p>此时对答案的贡献为 $f_{n, i, 1} \cdot g_{j, k - i, 0} \cdot \binom{n - j}{m - k}$。</p><p><strong>其二，$m$ 张牌中强化牌的数量大于等于 $k - 1$</strong></p><p>此时必然是出权值最大的 $k - 1$ 张强化牌，然后出权值最大的一张攻击牌。</p><p>枚举选中的最后一张强化牌是第 $i$ 张，选中的攻击牌是第 $j$ 张。</p><p>如果要保证最优方案是这 $k$ 张牌，剩下的 $m - k$ 张牌还需要满足<strong>所有强化牌都在第 $i$ 张之后，所有攻击牌都在第 $j$ 张之后</strong>。</p><p>此时对答案的贡献为 $f_{i, k - 1, 0} \cdot b_j \cdot \binom{2n - i - j}{m - k}$。</p><h4 id="code-6"><a href="#code-6" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/33571988">code</a></h4><p>它被卡常了，并过不去。</p><hr><h3 id="GSS5-Can-you-answer-these-queries-V"><a href="#GSS5-Can-you-answer-these-queries-V" class="headerlink" title="GSS5 - Can you answer these queries V"></a><a href="https://www.luogu.com.cn/problem/SP2916">GSS5 - Can you answer these queries V</a></h3><h4 id="problem-5"><a href="#problem-5" class="headerlink" title="problem"></a>problem</h4><p>给定一个长为 $n$ 的序列 $a$，每次查询左端点在 $[l_1, r_1]$ 之间，右端点在 $[l_2, r_2]$ 之间的最大子段和。不保证两个区间不相交。</p><h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h4><p>首先考虑两个区间 $[l_1, r_1], [l_2, r_2]$ 不相交或只在端点处相交 $(r_1 \le l_2)$ 的情况，发现答案就是右边区间的最大前缀和减去左边区间的最小前缀和。记这个答案为 $f([l_1, r_1], [l_2, r_2])$。</p><p>那么对于相交 $(l_2 &lt; r_1)$ 的情况也就很容易讨论了：答案是 $[r1, l2]$ 的最大子段和、$f([l_1, r_1], [r_1, r_2])$、$f([l_1, l_2], [l_2, r_2])$ 三者取最大值。</p><h4 id="code-7"><a href="#code-7" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/33581498">code</a></h4><p>只在端点相交的情况两种情况都可以讨论，代码放在了第二种情况里。</p><hr><h3 id="李超树"><a href="#李超树" class="headerlink" title="李超树"></a>李超树</h3><p><a href="https://fa555.github.io/2020/Li-Chao-Tree/">学习笔记在这</a></p><hr><h3 id="CEOI2017-Building-Bridges"><a href="#CEOI2017-Building-Bridges" class="headerlink" title="[CEOI2017]Building Bridges"></a><a href="https://www.luogu.com.cn/problem/P4655">[CEOI2017]Building Bridges</a></h3><h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h4><p>设 $f_i$ 为将第 $1$ 根柱子和第 $i$ 根柱子相连的最小代价，令 $S_i = \sum_{j = 1}^i{w_j}$，则</p><script type="math/tex; mode=display">\begin{align}f_i &= \min_{j = 1}^{i - 1}{ \left \{ f_j + \sum_{k = j + 1}^{i - 1}{w_k} + (h_i - h_j)^2 \right \} } \\ &= \min_{j = 1}^{i - 1}{ \{ f_j + S_{i - 1} - S_j + h_i^2 - 2 h_i h_j + h_j^2 \} } \\&= S_{i - 1} + h_i^2 + \min_{j = 1}^{i - 1}{ \{ f_j - S_j + h_j^2 - 2 h_i h_j \} }\end{align}</script><p>令 $k = -2h_i, b = f_j - S_j + h_j^2$，则可以用李超树维护。</p><p>CDQ 分治少一个 $\log$ 但我不会，不过李超树小常数跑得好像更快（</p><h4 id="code-8"><a href="#code-8" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/33691534">code</a></h4><hr><h3 id="作诗"><a href="#作诗" class="headerlink" title="作诗"></a><a href="https://www.luogu.com.cn/problem/P4135">作诗</a></h3><h4 id="problem-6"><a href="#problem-6" class="headerlink" title="problem"></a>problem</h4><p>给定长为 $n \ (1 \le n \le 10^5)$ 的序列 $a$ 和 $m \ (1 \le m \le 10^5)$ 次询问，每次询问 $a_{l \dots r}$ 中出现次数为正偶数的数字个数。</p><h4 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h4><p>长得跟蒲公英似的（？）</p><p>考虑分块，设 $s_{i, j}$ 表示第 $i$ 块开头到序列结尾数字 $j$ 的出现次数，$f_{i, j}$ 表示第 $i$ 块到第 $j$ 块的答案。</p><p>这样时间复杂度是 $O(n \sqrt n) - O(\sqrt n)$ 的；空间复杂度是 $O(n \sqrt n)$ 的。</p><h4 id="code-9"><a href="#code-9" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/33731933">code</a></h4><hr><h3 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h3><p>学了学 LCT，也没啥好说的，放个板子吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LCT &#123;</span><br><span class="line">  std::bitset&lt;100003&gt; rev;</span><br><span class="line">  <span class="keyword">int</span> z[<span class="number">100003</span>], s[<span class="number">100003</span>], fa[<span class="number">100003</span>], ch[<span class="number">100003</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch[fa[p]][<span class="number">1</span>] == p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">notRt</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch[fa[p]][<span class="number">0</span>] == p || ch[fa[p]][<span class="number">1</span>] == p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">    std::<span class="built_in">swap</span>(ch[p][<span class="number">0</span>], ch[p][<span class="number">1</span>]);</span><br><span class="line">    rev.<span class="built_in">flip</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    s[p] = s[ch[p][<span class="number">0</span>]] ^ s[ch[p][<span class="number">1</span>]] ^ z[p];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev[p]) <span class="built_in">assign</span>(ch[p][<span class="number">0</span>]), <span class="built_in">assign</span>(ch[p][<span class="number">1</span>]), rev.<span class="built_in">reset</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">notRt</span>(p)) <span class="built_in">update</span>(fa[p]);</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[p], g = fa[f], k = <span class="built_in">get</span>(p), r = ch[p][!k];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">notRt</span>(f)) ch[g][<span class="built_in">get</span>(f)] = p;</span><br><span class="line">    ch[f][k] = r, ch[p][!k] = f;</span><br><span class="line">    fa[r] = f, fa[f] = p, fa[p] = g;</span><br><span class="line">    <span class="built_in">pushup</span>(f), <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f; <span class="built_in">notRt</span>(p); <span class="built_in">rotate</span>(p))</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">notRt</span>(f = fa[p])) <span class="built_in">rotate</span>(<span class="built_in">get</span>(f) != <span class="built_in">get</span>(p) ? p : f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; p; p = fa[q = p])</span><br><span class="line">      <span class="built_in">splay</span>(p), ch[p][<span class="number">1</span>] = q, <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeRt</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(p), <span class="built_in">splay</span>(p), <span class="built_in">assign</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findRt</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(p), <span class="built_in">splay</span>(p);</span><br><span class="line">    <span class="keyword">while</span> (ch[p][<span class="number">0</span>]) <span class="built_in">pushdown</span>(p), p = ch[p][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRt</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">findRt</span>(q) != p) fa[p] = q;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRt</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">findRt</span>(q) != p || ch[q][<span class="number">0</span>] || fa[q] != p) <span class="keyword">return</span>;</span><br><span class="line">    fa[q] = ch[p][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRt</span>(p), <span class="built_in">access</span>(q), <span class="built_in">splay</span>(q);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// LCT</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 <code>update(p)</code> 有非递归写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> top, st[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  st[top = <span class="number">1</span>] = p;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">notRt</span>(p)) st[++top] = p = fa[p];</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">pushdown</span>(st[top--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="国家集训队-Tree-II"><a href="#国家集训队-Tree-II" class="headerlink" title="[国家集训队]Tree II"></a><a href="https://www.luogu.com.cn/problem/P1501">[国家集训队]Tree II</a></h3><p>第一道 LCT 的题目。涉及树上区间加、区间乘、区间和和连边断边。</p><p>需要在 Splay 上打区间加法和乘法标记，其他没啥区别。</p><h4 id="code-10"><a href="#code-10" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/33831604">code</a></h4><hr><h3 id="SDOI2011-染色"><a href="#SDOI2011-染色" class="headerlink" title="[SDOI2011]染色"></a><a href="https://www.luogu.com.cn/problem/P2486">[SDOI2011]染色</a></h3><h4 id="problem-7"><a href="#problem-7" class="headerlink" title="problem"></a>problem</h4><p>$n \ (1 \le n \le 10^5)$ 个点的树，每个结点有一个颜色。$m \ (1 \le m \le 10^5)$ 次操作，每次修改一个结点的颜色或查询每条链上的颜色段数。 </p><h4 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a>solution</h4><p>这题维护信息的方式比较怪异（</p><p>记录每个点代表的区间最左端的颜色 <code>lc</code>、最右端的颜色 <code>rc</code>、该点的颜色 <code>c</code> 和颜色分界点的个数 <code>s</code>。注意统计某点的答案时要先 <code>pushdown</code> 一下来更新儿子的信息。</p><p><code>assign</code> 的时候记得把两边儿子的最左端和最右端分别换一下。</p><h4 id="code-11"><a href="#code-11" class="headerlink" title="code"></a><a href="https://www.luogu.com.cn/record/33861957">code</a></h4><hr><h3 id="奶牛浴场-球场-Cricket-Field"><a href="#奶牛浴场-球场-Cricket-Field" class="headerlink" title="奶牛浴场 / 球场 Cricket Field"></a><a href="https://www.luogu.com.cn/problem/P1578">奶牛浴场</a> / <a href="https://www.luogu.com.cn/problem/UVA1312">球场 Cricket Field</a></h3><p>最大子矩形 / 正方形的 $O(s^2)$ 版本，其中 $s$ 为障碍物数量。</p><h4 id="code-12"><a href="#code-12" class="headerlink" title="code"></a>code</h4><p><a href="https://www.luogu.com.cn/record/33896638">奶牛浴场</a> / <a href="https://www.luogu.com.cn/record/33925064">球场 Cricket Field</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c++ 不定参函数初探</title>
      <link href="/2020/cpp%E4%B8%8D%E5%AE%9A%E5%8F%82%E5%87%BD%E6%95%B0%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/cpp%E4%B8%8D%E5%AE%9A%E5%8F%82%E5%87%BD%E6%95%B0%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>这里由于代码需要<del>其实是自己懒</del>，<strong>自行</strong>研究了一下 C++ 的不定参系统。这篇文章对于 OIer 来说应该是够用了。</p><span id="more"></span><p>代码均以求若干个数的模 <code>mod</code> 意义下和为例子。</p><hr><h3 id="va-list-系-C"><a href="#va-list-系-C" class="headerlink" title="va_list 系 (C)"></a><code>va_list</code> 系 (C)</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> argc, ...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  va_list argv;</span><br><span class="line">  <span class="built_in">va_start</span>(argv, argc);</span><br><span class="line">  <span class="keyword">while</span> (argc--)</span><br><span class="line">    ans = (ans + <span class="built_in">va_arg</span>(args, <span class="keyword">int</span>)) % mod;</span><br><span class="line">  <span class="built_in">va_end</span>(argv);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Add</span>(<span class="number">6</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>); <span class="comment">// returns 16 % mod;</span></span><br></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>C 语言只能用这个，就没啥别的优点了（</p><p>这个在 C 库的应用比较广泛，所以应该熟练掌握如何调用（大雾</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>拥有 C 的各种缺点。传参直接面向内存，导致类型转换非常麻烦，容易出错和越界。</p><p>必须传一个参数使得能够推断出参数类型和个数，非常麻烦。比如 <code>printf</code> 就要传一个 <code>const char*</code>，用格式符推断类型和个数。</p><p>格式十分严格，不加 <code>va_end</code> 会引发内存问题。</p><hr><h3 id="模板类-C"><a href="#模板类-C" class="headerlink" title="模板类 (C++)"></a>模板类 (C++)</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (t % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> t, Ts... r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((t + <span class="built_in">Add</span>(r...)) % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>); <span class="comment">// returns 16 % mod</span></span><br></pre></td></tr></table></figure><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p><del>写起来帅。</del>在 C++98 中可用，可读性也比较高。</p><p>调用起来比较省心，不会反直觉，是真正意义上的不定参（</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>只能递归调用，会带来一定的常数。</p><p>写的时候要注意是从右往左推上来的，要细心处理，不然容易错。</p><hr><h3 id="std-initializer-list-C-11"><a href="#std-initializer-list-C-11" class="headerlink" title="std::initializer_list (C++11)"></a><code>std::initializer_list</code> (C++11)</h3><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> std::initializer_list&lt;<span class="keyword">int</span>&gt; &amp;z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x : z)</span><br><span class="line">    ans = (ans + x) % mod;</span><br><span class="line">  <span class="keyword">return</span> (ans % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Add</span>(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>&#125;); <span class="comment">// returns 16 % mod;</span></span><br></pre></td></tr></table></figure><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>写起来<strong>贼</strong>方便，完全符合 C++ 具名规范，容易操作。</p><p>这一个优点就够强了，还要啥自行车（</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>调用的时候那个花括号太难受了（</p><p>感觉上 STL 可能会带个大常数，实际上跟模板写法的递归差不多（O2）。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杜教筛学习笔记</title>
      <link href="/2020/%E6%9D%9C%E6%95%99%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/%E6%9D%9C%E6%95%99%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>杜教筛能够在低于线性复杂度的时间内求出积性函数前缀和。</p><span id="more"></span><hr><p>有两个数论函数 $f, g$，令</p><script type="math/tex; mode=display">h(x) = \sum_{d | x}{f(d) g \left( \frac xd \right)}</script><p>则称 $h$ 是 $f$ 和 $g$ 的 Dirichlet 卷积，即 $h = f * g$。</p><p>两个数论函数的 Dirichlet 卷积也是数论函数。</p><hr><p>对于一个数论函数，要求出 $S(n) = \sum_{i = 1}^n{f(i)}$。</p><p>构造 $g, h$ 使得 $h = f * g$，则</p><script type="math/tex; mode=display">\begin{align}\sum_{i = 1}^n{h(i)} &= \sum_{i = 1}^n{\sum_{d | 1}{g(d) f \left(\frac id \right)}} \\&= \sum_{d = 1}^n g(d){\sum_{d | i}^n f \left(\frac id \right)} \\&= \sum_{d = 1}^n{g(d) \sum_{i = 1}^{\lfloor \frac nd \rfloor}{f(i)}} \\&= \sum_{d = 1}^n{g(d) S \left(\left\lfloor \frac nd \right\rfloor \right)} \\&= g(1)S(n) + \sum_{d = 2}^n{g(d) S \left(\left\lfloor \frac nd \right\rfloor \right)} \\S(n) &= \frac{\sum_{i = 1}^n{h(i)} - \sum_{d = 2}^n{g(d) S \left(\left\lfloor \frac nd \right\rfloor \right)}}{g(1)}\end{align}</script><p>上面的式子实际上是给出了一个关于 $S$ 的递推式。直接这样搞是 $O(n^\frac 34)$ 的。可以线性筛出前 $n^\frac 23$ 个答案，这样总复杂度是 $O(n^\frac 23)$ 的<del>，都不会证</del>。</p><hr><script type="math/tex; mode=display">\mathrm{Id} = \varphi * \mathbf 1 \\S(n) = \frac{n(n + 1)}{2} - \sum_{d = 2}^n{S \left( \left\lfloor \frac nd \right\rfloor \right)} \\\epsilon = \mu * \mathbf 1 \\S(n) = 1 - \sum_{d = 2}^n{S \left( \left\lfloor \frac nd \right\rfloor \right)} \\\mathrm{Id}^2 = (\varphi \times \mathrm{Id}) * \mathrm{Id} \\\varphi = \mu * \mathrm{Id}</script><hr><p>目前网络上的杜教筛代码大都存在两个问题：</p><ol><li><p>用 <code>std::unordered_map</code> 的代码在判断是否存在时直接 touch 一下来判等而不是 <code>::count</code>。<del>违背了 STL 的美学</del>（当然，由于这个值最后总是要插入的，加了个小常数不算啥事）</p></li><li><p>判断 $S_\mu$ 是否计算过时直接和 0 判等。$S_\mu$ 的取值在某些情况下本来就是 0，每次都要重新计算一遍相当于凭空产生常数。（对理论复杂度有无影响不会算）</p></li></ol><p>两个问题很好解决，对于用 <code>std::unordered_map</code> 的时候这两个问题可以用 <code>::count</code> 一起改掉；如果用了数组优化，第二个问题需要用其他手段记录一下。</p><hr><p>给一下<a href="https://www.luogu.com.cn/problemnew/show/P4213">洛谷模板题</a>的代码。</p><p>如果 时空要求都不严格 或是像这题一样多组询问 可以用 <code>std::unordered_map</code> 进行记忆化。</p><p>下面的代码可以 320ms（评测鸭）通过极限数据（10 组询问，2147483638 ~ 2147483647）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> base = <span class="number">1664510</span>;</span><br><span class="line"></span><br><span class="line">std::bitset&lt;1664513&gt; v;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">125641</span>], mu[<span class="number">1664513</span>];</span><br><span class="line">phi[<span class="number">1664513</span>];</span><br><span class="line">std::unordered_map&lt;<span class="keyword">unsigned</span>, ll&gt; mu_, phi_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">unsigned</span> N)</span></span>; <span class="comment">// 普通地线筛出 1~N 的 mu 和 phi 值</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getMu</span><span class="params">(<span class="keyword">unsigned</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= base) <span class="keyword">return</span> mu[N];</span><br><span class="line">  <span class="keyword">if</span> (mu_.<span class="built_in">count</span>(N)) <span class="keyword">return</span> mu_[N];</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> l = <span class="number">2</span>, r, L; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    L = N / l, r = N / L;</span><br><span class="line">    ans += (r - l + <span class="number">1</span>) * <span class="built_in">getMu</span>(L);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mu_[N] = <span class="number">1ll</span> - ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getPhi</span><span class="params">(<span class="keyword">unsigned</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= base) <span class="keyword">return</span> phi[N];</span><br><span class="line">  <span class="keyword">if</span> (phi_.<span class="built_in">count</span>(N)) <span class="keyword">return</span> phi_[N];</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> l = <span class="number">2</span>, r, L; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    L = N / l, r = N / L;</span><br><span class="line">    ans += (r - l + <span class="number">1</span>) * <span class="built_in">getPhi</span>(L);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> phi_[N] = (<span class="number">1ull</span> * N * (N + <span class="number">1ull</span>) &gt;&gt; <span class="number">1</span>) - ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> T, N;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sieve</span>(base);</span><br><span class="line">  <span class="keyword">for</span> (std::cin &gt;&gt; T; T; --T) &#123;</span><br><span class="line">    std::cin &gt;&gt; N;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getPhi</span>(N) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">getMu</span>(N) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>但是，<code>std::unordered_map</code> 的大常数有时令人难以接受。发现对于每次询问，需要的 $S$ 值都是形如 $S \left(\frac nd \right)$ 的，因此不会超过 $\sqrt n$ 个。</p><p>可以再开一个大小为 $\sqrt n$ 的数组进行记忆化。（我的实现中用的是 $n^\frac 23$）</p><p>注意对于每个 $n$，$f \left(\frac nd \right)$ 的值是不一样的，因此每次询问需要清空重新计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单次询问更优，但多次询问在极限数据下只能通过 T = 5</span></span><br><span class="line"><span class="comment">// 不过谷的板题数据很水所以可以过（</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> base = <span class="number">1664510</span>;</span><br><span class="line"></span><br><span class="line">std::bitset&lt;1664513&gt; v, vm, vp;</span><br><span class="line"><span class="keyword">int</span> MX, p[<span class="number">125641</span>]， mu[<span class="number">1664510</span>], mu_[<span class="number">1664510</span>];</span><br><span class="line">ll phi[<span class="number">1664510</span>], phi_[<span class="number">1664510</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">to</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MX / x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">unsigned</span> N)</span></span>; <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(<span class="keyword">unsigned</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= base) <span class="keyword">return</span> mu[N];</span><br><span class="line">  <span class="keyword">if</span> (vm[<span class="built_in">to</span>(N)]) <span class="keyword">return</span> mu_[<span class="built_in">to</span>(N)];</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> l = <span class="number">2</span>, r, L; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    L = N / l, r = N / L;</span><br><span class="line">    ans += (r - l + <span class="number">1</span>) * <span class="built_in">getMu</span>(L);</span><br><span class="line">  &#125;</span><br><span class="line">  vm.<span class="built_in">set</span>(<span class="built_in">to</span>(N));</span><br><span class="line">  <span class="keyword">return</span> mu_[<span class="built_in">to</span>(N)] = <span class="number">1</span> - ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getPhi</span><span class="params">(<span class="keyword">unsigned</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= base) <span class="keyword">return</span> phi[N];</span><br><span class="line">  <span class="keyword">if</span> (vp[<span class="built_in">to</span>(N)]) <span class="keyword">return</span> phi_[<span class="built_in">to</span>(N)];</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> l = <span class="number">2</span>, r, L; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    L = N / l, r = N / L;</span><br><span class="line">    ans += (r - l + <span class="number">1</span>) * <span class="built_in">getPhi</span>(L);</span><br><span class="line">  &#125;</span><br><span class="line">  vp.<span class="built_in">set</span>(<span class="built_in">to</span>(N));</span><br><span class="line">  <span class="keyword">return</span> phi_[<span class="built_in">to</span>(N)] = (<span class="number">1ull</span> * N * (N + <span class="number">1ull</span>) &gt;&gt; <span class="number">1</span>) - ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> T, N;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sieve</span>(base);</span><br><span class="line">  <span class="keyword">for</span> (std::cin &gt;&gt; T; T; --T) &#123;</span><br><span class="line">    vm.<span class="built_in">reset</span>(), vp.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; N;</span><br><span class="line">    MX = N;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getPhi</span>(N) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">getMu</span>(N) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 Apr Records</title>
      <link href="/2020/2020-Apr-Records/"/>
      <url>/2020/2020-Apr-Records/</url>
      
        <content type="html"><![CDATA[<p>菜鸡 fa_555 会把一些动态简要地记在这里。主要还是留给自己以后看的。</p><span id="more"></span><p><em>所有代码不保证包括无关紧要的部分</em></p><hr><h3 id="SCOI2007-k短路"><a href="#SCOI2007-k短路" class="headerlink" title="[SCOI2007]k短路"></a><a href="https://www.luogu.com.cn/problem/P4467">[SCOI2007]k短路</a></h3><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p><del>这是一道卡 A* 的 A* 模板题</del></p><p>简单说一下 A* 算法。对于一个搜索状态，设计函数 $f, g, h, h^\ast$。其中 $g$ 为搜索到当前状态的代价；$h$ 为估计剩余的代价；$h^\ast$ 为实际剩余的代价，$h &lt; h^\ast$，且差距越小效率越高；$f = g + h$，对 $f$ 维护一个优先队列即可。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N, K;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> nxt, to, w; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> G1 &#123;</span><br><span class="line">  std::bitset&lt;51&gt; vis;</span><br><span class="line">  <span class="type">int</span> head[<span class="number">51</span>], dis[<span class="number">51</span>];</span><br><span class="line">  Edge e[<span class="number">2451</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span>;</span><br><span class="line">&#125; <span class="comment">// G1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> G2 &#123;</span><br><span class="line">  <span class="type">int</span> *h = G1::dis, head[<span class="number">51</span>];</span><br><span class="line">  Edge e[<span class="number">2451</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::bitset&lt;51&gt; vis;</span><br><span class="line">    <span class="type">int</span> s, u, len, f;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (f != rhs.f) <span class="keyword">return</span> f &gt; rhs.f;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, mx = std::<span class="built_in">min</span>(z.<span class="built_in">size</span>(), rhs.z.<span class="built_in">size</span>()); i &lt; mx; ++i)</span><br><span class="line">        <span class="keyword">if</span> (z[i] != rhs.z[i]) <span class="keyword">return</span> z[i] &gt; rhs.z[i];</span><br><span class="line">      <span class="keyword">return</span> z.<span class="built_in">size</span>() &gt; rhs.z.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Astar</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;Node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;std::<span class="built_in">bitset</span>&lt;<span class="number">51</span>&gt;(<span class="number">1ll</span> &lt;&lt; s), s, s, <span class="number">0</span>, h[s], std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;()&#125;);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node now, nxt; q.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">      now = q.<span class="built_in">top</span>(), q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (now.u == t &amp;&amp; ++cnt == K) &#123;</span><br><span class="line">        cout &lt;&lt; now.s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u : now.z)</span><br><span class="line">          cout &lt;&lt; -u;</span><br><span class="line">        cout.<span class="built_in">flush</span>();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = head[now.u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now.vis[v = e[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">        nxt = &#123;now.vis, now.s, v, now.len + e[i].w, h[v], now.z&#125;;</span><br><span class="line">        nxt.vis.<span class="built_in">set</span>(v), nxt.z.<span class="built_in">push_back</span>(v), nxt.f += nxt.len;</span><br><span class="line">        q.<span class="built_in">push</span>(nxt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// G2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> M, S, T;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; S &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w; M; --M) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    G1::<span class="built_in">addEdge</span>(v, u, w), G2::<span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">  G1::<span class="built_in">spfa</span>(T), G2::<span class="built_in">Astar</span>(S, T);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="NOI2005-智慧珠游戏"><a href="#NOI2005-智慧珠游戏" class="headerlink" title="[NOI2005]智慧珠游戏"></a><a href="https://www.luogu.com.cn/problem/P4205">[NOI2005]智慧珠游戏</a></h3><p>DLX 是之前学的，这里记一记怎么建出一个精确覆盖模型。</p><ol><li><p>对整个拼盘按照一定的方法编号，每个格子对应一个号码（下面的代码采用先从左到右，再从上到下依次编号）。</p></li><li><p>把所有零件的形状存下来。这里采取的是确定一个关键点，其余点用相对坐标表示的方法。</p></li><li><p>设一个有若干行、每行 67 列的 01 矩阵，每行表示某个零件的一种摆法。其中左 12 列表示 12 个零件种类（第 $i$ 列为 $1$ 表示该行代表第 $i$ 种零件的某种摆法）；右 55 列表示拼盘上的 55 个空位，第 $i$ 列为 $1$ 表示这种摆法占据了第 $i$ 个格子。</p></li><li><p>对于 <strong>12 种</strong>零件分别枚举摆法。</p><ul><li><p>首先枚举上文提到的“关键点”的坐标，一共 <strong>55​ 种</strong>情况。</p></li><li><p>然后要枚举它的旋转、翻转变换。然而旋转操作并不方便编程直接实现，要考虑怎么实现。画一画图发现一共有 <strong>8 种</strong>不同摆法（如图）</p></li><li><p><img src="/files/img/P4205_1.png" alt="我是图"></p></li><li><p>发现可以通过三种简单的变换得到：交换横纵坐标、横坐标取相反数、纵坐标取相反数。</p></li></ul></li><li><p>把枚举出来的所有状态全扔进一个矩阵，DLX 跑个精确覆盖，完事了。统计答案有很多种方法，可以各路神仙八仙过海一下（</p></li><li><p>对于全空拼盘，理论上矩阵最大行数 $12 \times 55 \times 8 = 5280$，实际上由于零件形状的制约只有 <strong>2730 种</strong>，矩阵中的 $1$ 最多 <strong>15083​ 个</strong>。</p></li></ol><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><p>对于上面的三种变换，这里通过状态 $S \in [0, 8)$ 来枚举，$S$ 的最低三位从高到低依次表示是否交换横纵坐标、横坐标是否相反数、纵坐标是否取相反数。</p><p>部分变量解释：</p><ul><li><p><code>siz[i]</code> 表示第 $i$ 种零件的珠子个数</p></li><li><p><code>sh[i][][]</code> 表示第 $i$ 种零件的形状（见上文）</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> siz[] = &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span></span><br><span class="line">&#125;, sh[<span class="number">13</span>][<span class="number">5</span>][<span class="number">2</span>] = &#123;&#123;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;&#125;,</span><br><span class="line">  &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Data = std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;;</span><br><span class="line"></span><br><span class="line">std::bitset&lt;13&gt; used;</span><br><span class="line"><span class="type">char</span> z[<span class="number">13</span>][<span class="number">13</span>];</span><br><span class="line">Data v[<span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DLX &#123;</span><br><span class="line">  <span class="keyword">using</span> iarr = <span class="type">int</span>[<span class="number">15085</span>];</span><br><span class="line"></span><br><span class="line">  std::bitset&lt;69&gt; mp[<span class="number">2733</span>];</span><br><span class="line">  <span class="type">int</span> tot, ans[<span class="number">15</span>], cnt[<span class="number">69</span>], h[<span class="number">2733</span>];</span><br><span class="line">  iarr l, r, u, d, x, y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> M)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> R, <span class="type">int</span> C)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> C)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(<span class="type">int</span> C)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dance</span><span class="params">(<span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!r[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="comment">/* output */</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// DLX</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pos</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> to[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">55</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> to[i - <span class="number">1</span>] + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c, <span class="type">const</span> Data &amp;v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// v 中的元素为颜色 c 某种状态占据的坐标</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> M = <span class="number">0</span>;</span><br><span class="line">  DLX::<span class="built_in">link</span>(++M, c);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;x : v)</span><br><span class="line">    DLX::<span class="built_in">link</span>(M, <span class="number">12</span> + <span class="built_in">pos</span>(x.first, x.second));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;= x &amp;&amp; x &lt;= <span class="number">10</span> &amp;&amp; <span class="number">1</span> &lt;= y &amp;&amp; y &lt;= x &amp;&amp; z[x][y] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">      std::cin &gt;&gt; z[i][j];</span><br><span class="line">      <span class="keyword">if</span> (z[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        used.<span class="built_in">set</span>(z[i][j] &amp; <span class="number">31</span>);</span><br><span class="line">        v[z[i][j] &amp; <span class="number">31</span>].<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  DLX::<span class="built_in">init</span>(<span class="number">67</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">      <span class="built_in">insert</span>(i, v[i]);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v[i].<span class="built_in">resize</span>(siz[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pi = <span class="number">1</span>; pi &lt;= <span class="number">10</span>; ++pi)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> pj = <span class="number">1</span>; pj &lt;= pi; ++pj)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; <span class="number">8</span>; ++S) &#123;</span><br><span class="line">          <span class="type">bool</span> g = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, nx, ny; j &lt; siz[i]; ++j) &#123;</span><br><span class="line">            nx = sh[i][j][<span class="number">0</span>], ny = sh[i][j][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (S &amp; <span class="number">4</span>) std::<span class="built_in">swap</span>(nx, ny);</span><br><span class="line">            <span class="keyword">if</span> (S &amp; <span class="number">2</span>) nx = -nx;</span><br><span class="line">            <span class="keyword">if</span> (S &amp; <span class="number">1</span>) ny = -ny;</span><br><span class="line">            nx += pi, ny += pj;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">valid</span>(nx, ny)) &#123; g = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            v[i][j] = &#123;nx, ny&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!g) <span class="built_in">insert</span>(i, v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DLX::<span class="built_in">dance</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>); <span class="comment">// 有解的情况在 DLX 中直接退出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>在 CSG 那里学习了一个。</p><p>本来想搞多项式，结果被数论水平限制了，去从零重学数论，没想到一学就是好长好长好长时间 /kk</p><p><a href="https://fa555.github.io/2020/%E6%9D%9C%E6%95%99%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习杜教筛</a></p><p><a href="https://www.luogu.com.cn/problem/P4450">双亲数</a>发现了自己以前题解的错误并<a href="https://fa555.github.io/2019/%E9%A2%98%E8%A7%A3-P4450-%E3%80%90%E5%8F%8C%E4%BA%B2%E6%95%B0%E3%80%91/">重写</a></p><p><a href="https://www.luogu.com.cn/problem/P5170">类欧几里得算法</a>花两天边颓边<a href="https://fa555.github.io/2020/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%8A%84%E5%BC%8F%E5%AD%90%E7%AC%94%E8%AE%B0/">抄了一遍式子</a>又花一天写出来代码，<del>因为懒</del><a href="https://fa555.github.io/2020/cpp%E4%B8%8D%E5%AE%9A%E5%8F%82%E5%87%BD%E6%95%B0%E5%88%9D%E6%8E%A2//">研究了各种不定参的写法</a>。</p><hr><h3 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h3><p>学了 BSGS 和 exBSGS。<del>好难啊直接背吧</del></p><p>内附一个 Hash 表板子，机制类似于 <code>std::unordered_map</code> 但是跑得快（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Hmod = <span class="number">1000003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hash</span> &#123;</span><br><span class="line">  std::bitset&lt;Hmod&gt; vis;</span><br><span class="line">  <span class="type">int</span> tv[Hmod], tp[Hmod];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vis.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = p % Hmod;</span><br><span class="line">    <span class="keyword">for</span> (; vis[k]; ++k %= Hmod)</span><br><span class="line">      <span class="keyword">if</span> (tp[k] == p) &#123;</span><br><span class="line">        tv[k] = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    vis.<span class="built_in">set</span>(k), tv[k] = v, tp[k] = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = p % Hmod; vis[k]; ++k %= Hmod)</span><br><span class="line">      <span class="keyword">if</span> (tp[k] == p) <span class="keyword">return</span> tv[k];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSGS</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p, <span class="type">int</span> sd)</span> </span>&#123;</span><br><span class="line">  z.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">int</span> v = <span class="number">1</span>, t = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i, v = <span class="number">1ll</span> * v * a % p)</span><br><span class="line">    z.<span class="built_in">insert</span>(<span class="number">1ll</span> * v * b % p, i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j, v_ = v, v = sd; i &lt;= t; ++i, v = <span class="number">1ll</span> * v * v_ % p)</span><br><span class="line">    <span class="keyword">if</span> ((j = z.<span class="built_in">query</span>(v)) != <span class="number">-1</span> &amp;&amp; i * t &gt;= j) <span class="keyword">return</span> i * t - j;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exBSGS</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  a %= p, b %= p;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">1</span> || p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>, sd = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> d; (d = std::__gcd(a, p)) != <span class="number">1</span>; ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ++cnt, b /= d, p /= d;</span><br><span class="line">    sd = <span class="number">1ll</span> * sd * a / d % p;</span><br><span class="line">    <span class="keyword">if</span> (sd == b) <span class="keyword">return</span> cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="built_in">BSGS</span>(a, b, p, sd);</span><br><span class="line">  <span class="keyword">if</span> (ans != <span class="number">-1</span>) ans += cnt;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><p>关于原根的笔记<a href="https://fa555.github.io/2020/%E5%8E%9F%E6%A0%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">在这里</a></p><hr><h3 id="SDOI2010-古代猪文"><a href="#SDOI2010-古代猪文" class="headerlink" title="[SDOI2010]古代猪文"></a><a href="https://www.luogu.com.cn/problemnew/solution/P2480">[SDOI2010]古代猪文</a></h3><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><p>给定正整数 $n, g \ (n, g \le 10^9)$，求 $g^{ \sum_{d \mid n}{ \binom nd}} \bmod 999911659$。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>本能考虑欧拉定理，则答案等于 $g^{ \sum_{d \mid n}{ \binom nd} \bmod 999911658} \bmod 999911659$。</p><p>设 $x = \sum_{d \mid n}{ \binom nd} \bmod 999911658$，重点在于求出 $x$。怎么求呢？</p><h5 id="Extended-Lucas"><a href="#Extended-Lucas" class="headerlink" title="Extended Lucas"></a>Extended Lucas</h5><p>这个指数可以直接无脑上 Extended Lucas 嘛对不对（</p><p>这个复杂度上天的做法在 LOJ 是最劣解第一，在谷直接 TLE 成了 70 分（</p><h5 id="Lucas-CRT"><a href="#Lucas-CRT" class="headerlink" title="Lucas + CRT"></a>Lucas + CRT</h5><p>考虑对模数进行质因数分解，$999911658 = 2 \times 3 \times 4679 \times 35617$。发现四个因子都是质数而不是质数的幂，因此可以使用 Lucas 计算出</p><script type="math/tex; mode=display">\begin{cases}x \equiv r_1 \pmod 2 \\x \equiv r_2 \pmod 3 \\x \equiv r_3 \pmod{4679} \\x \equiv r_4 \pmod{35617}\end{cases}</script><p>中的 $r_1, r_2, r_3, r_4$，再使用 CRT 合并得到 $x$。</p><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><p>这个做法我的实现在 LOJ 得到了最优解第二。<del>如果我早交 11 个小时就能当第一</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> m[<span class="number">5</span>] = &#123;<span class="number">999911659</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4679</span>, <span class="number">35617</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r[<span class="number">5</span>], fac[<span class="number">5</span>][<span class="number">35619</span>], invF[<span class="number">5</span>][<span class="number">35619</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pow</span><span class="params">(ll b, ll p, ll m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">()</span></span>; <span class="comment">// 在 fac[k][i] 和 invF[k][i] 中求出模 m[k] 意义下 i 的阶乘及其逆元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lucas</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> k)</span></span>; <span class="comment">// 求 C(N, M) % m[k]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; ++k)</span><br><span class="line">    r[k] = (r[k] + <span class="built_in">Lucas</span>(N, i, k)) % m[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CRT</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> *r, <span class="type">const</span> <span class="type">int</span> *m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> p = *m - <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= N; ++k)</span><br><span class="line">    ans = (ans + <span class="number">1ll</span> * r[k] * (p / m[k]) % p * <span class="built_in">Pow</span>(p / m[k], m[k] - <span class="number">2</span>, m[k]) % p) % p;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> g)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (g % *m == <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">prework</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (N % i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">calc</span>(N, i);</span><br><span class="line">      <span class="keyword">if</span> (i * i != N) <span class="built_in">calc</span>(N, N / i);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Pow</span>(g, <span class="built_in">CRT</span>(<span class="number">4</span>, r, m), *m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="HAOI2011-Problem-b"><a href="#HAOI2011-Problem-b" class="headerlink" title="[HAOI2011]Problem b"></a><a href="https://www.luogu.com.cn/problem/P2522">[HAOI2011]Problem b</a></h3><h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h4><p>$T \ (1 \le T \le 5 \times 10^4)$ 组数据，给定 $a, b, c, d, k \ (1 \le a, b, c, d, k \le 5 \times 10^4)$，求 $\sum<em>{i = a}^b{ \sum</em>{j = c}^d{[\gcd(i, j) = k]}}$。</p><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>我以前写过<a href="https://www.luogu.org/problem/P4450">这道题</a>的<a href="https://fa555.github.io/2019/%E9%A2%98%E8%A7%A3-P4450-%E3%80%90%E5%8F%8C%E4%BA%B2%E6%95%B0%E3%80%91/">题解</a>对吧（</p><p>一模一样，套个傻逼容斥就完了，总复杂度 $O(n + T \sqrt n)$，带一个不小的常数。</p><hr><h3 id="LCMSUM"><a href="#LCMSUM" class="headerlink" title="LCMSUM"></a><a href="https://www.luogu.com.cn/problem/SP5971">LCMSUM</a></h3><h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h4><p>$T \ (1 \le T \le 3 \times 10^5)$ 组数据，给定 $n \ (1 \le n \le 10^6)$，求 $\sum_{i = 0}^n{ \mathrm{lcm}(i, n)}$。</p><h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>设 $d’ = n / d$，则</p><script type="math/tex; mode=display">\begin{align}\sum_{i = 0}^n{ \mathrm{lcm}(i, n)} &= \sum_{i = 1}^n \frac{in}{ \gcd(i, n)} \\&= \frac 12 \left( \sum_{i = 1}^{n - 1}{ \frac{in}{ \gcd(i, n)} + \sum_{i = n - 1}^1{ \frac{in}{ \gcd(i, n)}}} \right) + n \\&= \frac 12 \left( \sum_{i = 1}^{n - 1}{ \frac{in}{ \gcd(i, n)} + \sum_{i = n - 1}^1{ \frac{in}{ \gcd(n - i, n)}}} \right) + n \\&= \frac 12 \sum_{i = 1}^{n - 1}{ \frac{n^2}{ \gcd(i, n)}} + n \\&= \frac 12 \sum_{i = 1}^n{ \frac{n^2}{ \gcd(i, n)}} + \frac n2 \\&= \frac 12 \sum_{d \mid n}{\frac{n^2 \varphi(d')}d} + \frac n2 \\&= \frac n2 \left( \sum_{d \mid n}{d' \varphi(d') + 1} \right)\end{align}</script><p>设 $f(n) = \sum_{d \mid n} d \ \varphi(d)$。</p><p>$f$ 是积性函数，可以 $O(n) - O(1)$，总复杂度 $O(n + T)$。$O(n)$ 筛这个函数的操作好像很骚的样子，不过也有 $O(n \log n)$ 的用 $\varphi$ 间接求的算法。</p><h4 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;1000003&gt; v;</span><br><span class="line"><span class="type">int</span> p[<span class="number">78501</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">1000003</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sieve = ([]() &#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">  <span class="type">int</span> M = <span class="number">0</span>;</span><br><span class="line">  v.<span class="built_in">set</span>(<span class="number">1</span>), f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) p[++M] = i, f[i] = <span class="number">1ll</span> * i * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M &amp;&amp; i * p[j] &lt;= N; ++j) &#123;</span><br><span class="line">      v.<span class="built_in">set</span>(i * p[j]);</span><br><span class="line">      <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i / p[j] % p[j] == <span class="number">0</span>)</span><br><span class="line">          f[i * p[j]] = f[i] + (f[i] - f[i / p[j]]) * p[j] * p[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          f[i * p[j]] = f[i] + f[i / p[j]] * (p[j] - <span class="number">1</span>) * p[j] * p[j] * p[j];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      f[i * p[j]] = f[i] * f[p[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (f[N] * N + N) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="Crash的数字表格"><a href="#Crash的数字表格" class="headerlink" title="Crash的数字表格"></a><a href="https://www.luogu.org/problem/P1829">Crash的数字表格</a></h3><h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem"></a>problem</h4><p>给定 $n, m \ (1 \le n, m, \le 10^7)$，求 $\sum<em>{i = 1}^n{ \sum</em>{j = 1}^m{ \mathrm{lcm}(i, j)}}$ 在模意义下的值。</p><h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h4><p>不妨设 $n \le m$。</p><script type="math/tex; mode=display">\begin{align}\sum_{i = 1}^n{ \sum_{j = 1}^m{ \mathrm{lcm}(i, j)}} &= \sum_{i = 1}^n{ \sum_{j = 1}^m{ \frac{ij}{ \gcd(i, j)}}} \\&= \sum_{i = 1}^n{ \sum_{j = 1}^m{ \sum_{d \mid \gcd(i, j), \left[ \frac id \perp \frac jd \right]}{ \frac{ij}d}}} \\&= \sum_{d = 1}^n{d \sum_{i = 1}^{ \lfloor n / d \rfloor}{ \sum_{j = 1}^{ \lfloor m / d \rfloor}{[i \perp j] \ ij}}}\end{align}</script><p>令 $S(n, m) = \sum<em>{i = 1}^n{ \sum</em>{j = 1}^m{[i \perp j] \ ij}}$，则</p><script type="math/tex; mode=display">\begin{align}S(n, m) &= \sum_{i = 1}^n{ \sum_{j = 1}^m{ \epsilon( \gcd(i, j)) ij}} \\&= \sum_{d = 1}^n{ \sum_{d \mid i}^n{ \sum_{d \mid j}^m{ \mu(d)ij}}} \\&= \sum_{d = 1}^n{ \mu(d)d^2 \sum_{i = 1}^{n / d}{ \sum_{j = 1}^{m / d}{ij}}}\end{align}</script><p>令 $f(n, m) = \sum<em>{i = 1}^n{ \sum</em>{j = 1}^m ij} = \frac{n(n + 1)}2 \times \frac{m(m + 1)}2$，则</p><script type="math/tex; mode=display">S(n, m) = \sum_{d = 1}^n{ \mu(d) · d^2 · f \left( \left\lfloor \frac nd \right\rfloor, \left\lfloor \frac md \right\rfloor \right)}</script><p>可以数论分块 $O \left( \left\lfloor \frac{n}{ \lfloor n / d \rfloor} \right\rfloor \right)$ 求 $S(n, m)$。则原答案为</p><script type="math/tex; mode=display">\sum_{d = 1}^n{d · S \left( \left\lfloor \frac nd \right\rfloor, \left\lfloor \frac md \right\rfloor \right)}</script><hr><h4 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h4><p>注意代码中有两处 <code>assert</code>，改变其数量，在评测鸭实测速度 2 &gt; 0 &gt; 1，不知为何。<del>可能是玄学</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">20101009</span>;</span><br><span class="line"></span><br><span class="line">std::bitset&lt;10000003&gt; v;</span><br><span class="line"><span class="type">int</span> p[<span class="number">664581</span>], mu[<span class="number">10000003</span>], g[<span class="number">10000003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 筛出 mu[1..N] */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    g[i] = (g[i - <span class="number">1</span>] + <span class="number">1ll</span> * i * i % mod * (mu[i] + mod) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1ll</span> * N * (N + <span class="number">1</span>) / <span class="number">2</span> % mod) * (<span class="number">1ll</span> * M * (M + <span class="number">1</span>) / <span class="number">2</span> % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">S</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(N &lt;= M);</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r, n, m; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    n = N / l, m = M / l;</span><br><span class="line">    r = std::<span class="built_in">min</span>(N / n, M / m);</span><br><span class="line">    ans = (ans + <span class="number">1ll</span> * (g[r] - g[l - <span class="number">1</span>] + mod) * <span class="built_in">f</span>(n, m) % mod) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(N &lt;= M);</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r, n, m; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    n = N / l, m = M / l;</span><br><span class="line">    r = std::<span class="built_in">min</span>(N / n, M / m);</span><br><span class="line">    ans = (ans + <span class="number">1ll</span> * (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span> % mod * <span class="built_in">S</span>(n, m) % mod) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> N, M;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="keyword">if</span> (N &gt; M) std::<span class="built_in">swap</span>(N, M);</span><br><span class="line">  <span class="built_in">sieve</span>(N);</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">solve</span>(N, M);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="SDOI2015约数个数和"><a href="#SDOI2015约数个数和" class="headerlink" title="[SDOI2015约数个数和]"></a><a href="https://www.luogu.com.cn/problem/P3327">[SDOI2015约数个数和]</a></h3><h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem"></a>problem</h4><p>$T \ (1 \le T \le 50000)$ 组数据，给定 $n, m \ (1 \le n, m \le 50000)$，求 $\sum<em>{i = 1}^n{ \sum</em>{j = 1}^m{ \mathrm d(ij)}}$。其中 $\mathrm d$ 为约数个数函数。</p><h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h4><p>首先有个很少人会证的结论</p><script type="math/tex; mode=display">\mathrm d(ij) = \sum_{x \mid i}{ \sum_{y \mid j}{[x \perp y]}}</script><p>然后可以通过一系列简单的操作得到答案为（设 $n \le m$）</p><script type="math/tex; mode=display">\sum_{d = 1}^n{ \mu(d) · S_\mathrm d \left( \left\lfloor \frac nd \right\rfloor \right) · S_\mathrm d \left( \left\lfloor \frac md \right\rfloor \right)}</script><p>其中 $S_\mathrm d$ 为 $\mathrm d$ 的前缀和函数。外层显然数论分块，总复杂度是 $O(n + T \sqrt n)$。</p><hr><h3 id="ZJOI2014-力"><a href="#ZJOI2014-力" class="headerlink" title="[ZJOI2014]力"></a><a href="https://www.luogu.com.cn/problem/P3338">[ZJOI2014]力</a></h3><h4 id="problem-5"><a href="#problem-5" class="headerlink" title="problem"></a>problem</h4><p>给出 $n \ (1 \le n \le 10^5)$ 个数 $q_i \ (1 \le q_i &lt; 10^9)$，定义</p><script type="math/tex; mode=display">F_i = \sum_{j = 1}^{i - 1}{\frac{q_i q_j}{(i - j)^2}} - \sum_{j = i + 1}^n \frac{q_i q_j}{(i - j)^2} \\E_i = \frac{F_i}{q_i}</script><p>求 $E_{1 \dots n}$。</p><h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h4><script type="math/tex; mode=display">E_i = \frac{F_i}{q_i} = \sum_{j = 1}^{i - 1}{\frac{q_j}{(i - j)^2}} - \sum_{j = i + 1}^n \frac{q_j}{(i - j)^2}</script><p>令</p><script type="math/tex; mode=display">f_i = \begin{cases}0 & , i = 0 \\q_i & , i > 0\end{cases}, \quad g_i = \begin{cases}0 & , i = 0 \\\frac 1{i^2} & , i > 0\end{cases}</script><p>则</p><script type="math/tex; mode=display">\begin{align}E_i &= \sum_{j = 0}^{i}{f_j g_{i - j}} - \sum_{j = i}^n{f_j g_{j - i}} \\&= \sum_{j = 0}^{i}{f_j g_{i - j}} - \sum_{j = 0}^{n - i}{f_{i + j} g_{j}}\end{align}</script><p>令 $f’<em>i = f</em>{n - i}, t = n - i$，则</p><script type="math/tex; mode=display">E_i = \sum_{j = 0}^{i}{f_j g_{i - j}} - \sum_{j = 0}^t{f'_{t - j} g_{j}}</script><p>式子推完了，开始整多项式。令（注意此处 $F$ 与题目给出的 $F$ 不同）</p><script type="math/tex; mode=display">\begin{align}A(x) &= \sum_{i = 0}^n{f_i x^i} \\B(x) &= \sum_{i = 0}^n{f'_i x^i} \\C(x) &= \sum_{i = 0}^n{g_i x^i} \\F(x) &= A(x) \ast C(x) \\G(x) &= B(x) \ast C(x) \\E_i &= F_i - G_{n - i}\end{align}</script><h4 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> ans[<span class="number">50003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span>* <span class="title">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">double</span> *p)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim, l;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (lim = <span class="number">1</span>, l = <span class="number">-1</span>; lim &lt;= N &lt;&lt; <span class="number">1</span>; lim &lt;&lt;= <span class="number">1</span>, ++l);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    to[i] = (to[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    A[i].x = B[N - i].x = p[i];</span><br><span class="line">    C[i].x = <span class="number">1.</span> / (<span class="number">1.</span> * i * i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FFT</span>(lim, A, <span class="number">1</span>), <span class="built_in">FFT</span>(lim, B, <span class="number">1</span>), <span class="built_in">FFT</span>(lim, C, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    A[i] = A[i] * C[i], B[i] = B[i] * C[i];</span><br><span class="line">  <span class="built_in">FFT</span>(lim, A, <span class="number">-1</span>), <span class="built_in">FFT</span>(lim, B, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    ans[i] = A[i].x - B[N - i].x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="AHOI2017-HNOI2017-礼物"><a href="#AHOI2017-HNOI2017-礼物" class="headerlink" title="[AHOI2017/HNOI2017]礼物"></a><a href="https://www.luogu.com.cn/problem/P3723">[AHOI2017/HNOI2017]礼物</a></h3><h4 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h4><p>枚举对第一个手环整体加 $c \ (-m &lt; c &lt; m)$，那么两个手环之间的差异值为</p><script type="math/tex; mode=display">\begin{align}& \sum_{i = 1}^n{(a_i + c - b_i)^2} \\=& \sum_{i = 1}^n{(a_i^2 + b_i^2 + c^2 + 2 a_i c - 2 b_i c - 2 a_i b_i)} \\=& \sum_{i = 1}^n{(a_i^2 + b_i^2)} + 2 c \sum_{i = 1}^n{(a_i - b_i)} - 2 \sum_{i = 1}^n{a_i b_i} + nc^2\end{align}</script><p>发现除了最后一项以外都是确定的。那么只要令 $\sum_{i = 1}^n{a_i b_i}$ 最大就可以得到最小值了。</p><p>首先把 $a$ 序列反向一下，得到 $\sum<em>{i = 1}^n{a</em>{n - i + 1}^n b_i}$，然后在反向后的 $a$ 倍长破环成链，与 $b$ 卷起来得到的新多项式的第 $n + 1\sim 2n$ 项中找最大值即可。</p><h4 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> *a, <span class="type">int</span> M, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim, l, ans = <span class="number">0x3f3f3f3f</span>, ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>, ans3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (lim = <span class="number">1</span>, l = <span class="number">-1</span>; lim &lt;= N * <span class="number">3</span>; lim &lt;&lt;= <span class="number">1</span>, ++l);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    to[i] = (to[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t; i &lt; N; ++i) &#123;</span><br><span class="line">    t = a[i + <span class="number">1</span>];</span><br><span class="line">    A[N - i].x = A[(N &lt;&lt; <span class="number">1</span>) - i].x = t;</span><br><span class="line">    ans1 += t * t, ans2 += t &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t; i &lt;= N; ++i) &#123;</span><br><span class="line">    t = b[i];</span><br><span class="line">    B[i].x = t;</span><br><span class="line">    ans1 += t * t, ans2 -= t &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FFT</span>(lim, A, <span class="number">1</span>), <span class="built_in">FFT</span>(lim, B, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    A[i] = A[i] * B[i];</span><br><span class="line">  <span class="built_in">FFT</span>(lim, A, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = N + <span class="number">1</span>; i &lt;= N &lt;&lt; <span class="number">1</span>; ++i)</span><br><span class="line">    ans3 = std::<span class="built_in">max</span>(ans3, <span class="built_in">int</span>(A[i].x + <span class="number">0.5</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = -M; i &lt;= M; ++i)</span><br><span class="line">    ans = std::<span class="built_in">min</span>(ans, i * ans2 + N * i * i);</span><br><span class="line">  ans += ans1 - (ans3 &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="SP4882-DAGCNT2-Counting-in-a-DAG"><a href="#SP4882-DAGCNT2-Counting-in-a-DAG" class="headerlink" title="SP4882 DAGCNT2 - Counting in a DAG"></a><a href="https://www.luogu.com.cn/jump/spoj/4882">SP4882 DAGCNT2 - Counting in a DAG</a></h3><h4 id="problem-6"><a href="#problem-6" class="headerlink" title="problem"></a>problem</h4><p>$T \ (1 \le T \le 2)$ 组数据，给定 $n \ (1 \le n \le 2 \times 10^4)$ 个点 $m \ (1 \le m \le 5 \times 10^5)$ 条边的 DAG，点带权，求每个点出发所能到达的点的点权和。</p><h4 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a>solution</h4><p>啊，这个问题的复杂度已经被证明下界是 $O(n^2)$ 的了（</p><p>我非常好奇怎么过这个数据范围，于是在网上找到一篇神仙状压的代码并抄了一遍（</p><h4 id="code-7"><a href="#code-7" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> iarrN = <span class="type">int</span>[<span class="number">20003</span>];</span><br><span class="line"></span><br><span class="line">std::bitset&lt;20003&gt; vis;</span><br><span class="line"><span class="type">int</span> top, f[<span class="number">20003</span>][<span class="number">627</span>];</span><br><span class="line">iarrN mp, rmp, s, w, outd, ans;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; G[<span class="number">20003</span>], R[<span class="number">20003</span>], D[<span class="number">20003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  vis.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="built_in">memset</span>(outd + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">  <span class="built_in">memset</span>(ans + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    G[i].<span class="built_in">clear</span>(), R[i].<span class="built_in">clear</span>(), D[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">memset</span>(f[i], <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * ((i &gt;&gt; <span class="number">5</span>) + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis.<span class="built_in">set</span>(u);</span><br><span class="line">  f[u][u &gt;&gt; <span class="number">5</span>] |= <span class="number">1</span> &lt;&lt; (u &amp; <span class="number">31</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : D[u])</span><br><span class="line">    <span class="keyword">if</span> (!(f[u][v &gt;&gt; <span class="number">5</span>] &amp; (<span class="number">1</span> &lt;&lt; (v &amp; <span class="number">31</span>)))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v]) <span class="built_in">dfs</span>(v);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= v &gt;&gt; <span class="number">5</span>; ++j)</span><br><span class="line">        f[u][j] |= f[v][j];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= u &gt;&gt; <span class="number">5</span>; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">      <span class="keyword">if</span> (f[u][j] &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        ans[rmp[u]] += w[rmp[(j &lt;&lt; <span class="number">5</span>) + i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> T, N, M;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> _T = <span class="number">0</span>; _T &lt; T; ++_T) &#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">if</span> (_T) <span class="built_in">init</span>(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">      cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= M; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">      G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">      R[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">      ++outd[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">      <span class="keyword">if</span> (!outd[i]) s[++top] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u; top; ) &#123;</span><br><span class="line">      u = s[top--], mp[u] = i, rmp[i] = u, ++i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> v : R[u])</span><br><span class="line">        <span class="keyword">if</span> (!--outd[v]) s[++top] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= N; ++u)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> v : G[u])</span><br><span class="line">        D[mp[u]].<span class="built_in">push_back</span>(mp[v]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">      std::<span class="built_in">sort</span>(D[i].<span class="built_in">rbegin</span>(), D[i].<span class="built_in">rend</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N; i; --i)</span><br><span class="line">      <span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">      cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="残缺的字符串"><a href="#残缺的字符串" class="headerlink" title="残缺的字符串"></a><a href="https://www.luogu.com.cn/problem/P4173">残缺的字符串</a></h3><h4 id="problem-7"><a href="#problem-7" class="headerlink" title="problem"></a>problem</h4><p>应该叫<strong>【模板】带通配符的单模式串匹配</strong>（</p><p>给定长为 $m$ 的模式串 $A$ 和长为 $n$ 的模式串 $B \ (1 \le m, n \le 3 \times 10^5)$。字符集小写字母和*，*可以匹配任意字符。</p><p>求 $B$ 串每个可以完全匹配 $A$ 串的位置。</p><h4 id="solution-单模式串匹配"><a href="#solution-单模式串匹配" class="headerlink" title="solution - 单模式串匹配"></a>solution - 单模式串匹配</h4><p>如果不带通配符，kmp 算法可以在 $O(n + m)$ 的时间内解决这个问题。对于带通配符的问题，我们使用多项式卷积来解决。</p><p>首先从不带通配符开始考虑。方便起见，字符串的下标均从 $0$ 开始。</p><p>定义完全匹配函数 $P(x) = \sum<em>{i = 0}^{m - 1}{(A_i - B</em>{x - m + i + 1})^2}$，其中平方是为了保证每一位的取值非负；那么若 $P(x) = 0$，则 $B_{x - m + 1 \dots x}$ 与 $A$ 完全匹配。为了制造卷积形式，把 $A$ 串翻转得到串 $S$，那么匹配函数</p><script type="math/tex; mode=display">\begin{align}P(x) &= \sum_{i = 0}^{m - 1}{(S_{m - i - 1} - B_{x - m + i + 1})^2} \\&= \sum_{i = 0}^{m - 1}{S_{m - i - 1}^2} + \sum_{i = 0}^{m - 1}{B_{x - m + i + 1}^2} - 2 \sum_{i = 0}^{m - 1}{S_{m - i - 1} B_{x - m + i + 1}}\end{align}</script><p>第一项可以 $O(m)$ 求得，第二项可以 $O(n)$ 预处理前缀和，需要求的只有第三项。发现第三项两个下标的和恰好等于 $x$，因此可以写成 $- 2 \sum_{i + j = x}{S_i B_j}$（想一想，为什么？）</p><p>设 $T = \sum<em>{i = 0}^{m - 1} S_i^2, f(x) = \sum</em>{i = 0}^x{B<em>i^2}, g(x) = \sum</em>{i + j = x}{S_i B_j}$，则有 $P(x) = T + f(x) - f(x - m) - 2 g(x)$。这个直接 FFT 一下就好了。</p><h4 id="solution-带通配符的单模式串匹配"><a href="#solution-带通配符的单模式串匹配" class="headerlink" title="solution - 带通配符的单模式串匹配"></a>solution - 带通配符的单模式串匹配</h4><p>由于出现了通配符，需要定义一个新的匹配函数。设通配符的数值为 0，定义完全匹配函数 $P(x) = \sum<em>{i = 0}^{m - 1}(A_i - B</em>{x - m + i + 1})^2 A<em>i B</em>{x - m + i + 1}$。把 $A$ 串翻转得到串 $S$，那么匹配函数</p><script type="math/tex; mode=display">\begin{align}P(x) &= \sum_{i = 0}^{m - 1}{(S_{m - i - 1} - B_{x - m + i + 1})^2 S_{m - i - 1} B_{x - m + i + 1}} \\&= \sum_{i = 0}^{m - 1}{S_{m - i - 1}^3 B_{x - m + i + 1}} + \sum_{i = 0}^{m - 1}{S_{m - i - 1} B_{x - m + i + 1}^3} - 2 \sum_{i = 0}^{m - 1}{S_{m - i - 1}^2 B_{x - m + i + 1}^2}\end{align}</script><p>发现所有的项的两个下标的和都为 $x$，则有</p><script type="math/tex; mode=display">P(x) = \sum_{i + j = x}{S_i^3 B_j} + \sum_{i + j = x}{S_i B_j^3} - 2 \sum_{i + j = x}{S_i^2 B_j^2}</script><p>6 次 DFT 和 1 次 IDFT 即刻求出。</p><h4 id="code-8"><a href="#code-8" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Complex F[<span class="number">1</span>&lt;&lt;<span class="number">20</span>|<span class="number">1</span>], G[<span class="number">1</span>&lt;&lt;<span class="number">20</span>|<span class="number">1</span>], P[<span class="number">1</span>&lt;&lt;<span class="number">20</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> A[<span class="number">1</span>&lt;&lt;<span class="number">20</span>|<span class="number">1</span>], B[<span class="number">1</span>&lt;&lt;<span class="number">20</span>|<span class="number">1</span>], to[<span class="number">1</span>&lt;&lt;<span class="number">20</span>|<span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="type">int</span> M, <span class="type">char</span> *s1, <span class="type">int</span> N, <span class="type">char</span> *s2)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim, l, tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (lim = <span class="number">1</span>, l = <span class="number">-1</span>; lim &lt;= M + N; lim &lt;&lt;= <span class="number">1</span>, ++l);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    to[i] = (to[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">    A[M - i - <span class="number">1</span>] = s1[i] == <span class="string">&#x27;*&#x27;</span> ? <span class="number">0</span> : s1[i] &amp; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    B[i] = s2[i] == <span class="string">&#x27;*&#x27;</span> ? <span class="number">0</span> : s2[i] &amp; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    F[i] = <span class="built_in">Complex</span>(A[i] * A[i] * A[i], <span class="number">0</span>), G[i] = <span class="built_in">Complex</span>(B[i], <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">FFT</span>(lim, F, <span class="number">1</span>), <span class="built_in">FFT</span>(lim, G, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    P[i] = P[i] + F[i] * G[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    F[i] = <span class="built_in">Complex</span>(A[i], <span class="number">0</span>), G[i] = <span class="built_in">Complex</span>(B[i] * B[i] * B[i], <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">FFT</span>(lim, F, <span class="number">1</span>), <span class="built_in">FFT</span>(lim, G, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    P[i] = P[i] + F[i] * G[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    F[i] = <span class="built_in">Complex</span>(A[i] * A[i], <span class="number">0</span>), G[i] = <span class="built_in">Complex</span>(B[i] * B[i], <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">FFT</span>(lim, F, <span class="number">1</span>), <span class="built_in">FFT</span>(lim, G, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    P[i] = P[i] - <span class="built_in">Complex</span>(<span class="number">2</span>, <span class="number">0</span>) * F[i] * G[i];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FFT</span>(lim, P, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = M - <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(P[i].x) &lt; eps) <span class="comment">// 本题 eps 取 1e-1 可过</span></span><br><span class="line">      ans.<span class="built_in">push_back</span>(i - M + <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="集训队作业2013-城市规划"><a href="#集训队作业2013-城市规划" class="headerlink" title="[集训队作业2013]城市规划"></a><a href="https://www.luogu.com.cn/problem/P4841">[集训队作业2013]城市规划</a></h3><h4 id="problem-8"><a href="#problem-8" class="headerlink" title="problem"></a>problem</h4><p>求 $n \ (1 \le n \le 130000)$ 个点的有标号简单无向连通图的个数，答案对 $1004535809$ 取模。</p><h4 id="solution-9"><a href="#solution-9" class="headerlink" title="solution"></a>solution</h4><p>设 $f(n)$ 表示有 $n$ 个点的有标号简单无向连通图的个数，$g(n)$ 表示 $n$ 个点的有标号简单无向图的个数，显然有 $g(n) = 2^{\binom n2}$。</p><p>一个有标号简单无向图是由若干个连通分量构成的，为了避免重复计数，我们枚举 $1$ 号点所在的连通块的大小（其他点任意连边，不会重复）</p><script type="math/tex; mode=display">\begin{align}g(n) &= \sum_{i = 1}^n{\binom{n - 1}{i - 1} f(i) g(n - i)} \\2^{\binom n2} &= \sum_{i = 1}^n{\binom{n - 1}{i - 1} f(i) 2^{\binom{n - i}2}} \\\frac{2^{\binom n2}}{(n - 1)!} &= \sum_{i = 1}^n{\frac{f(i)}{(i - 1)!} \times \frac{2^{ \binom{n - i}2}}{(n - i)!}}\end{align}</script><p>定义形式幂级数</p><script type="math/tex; mode=display">\begin{align}F(x) &= \sum_{n = 0}^\infty \frac{f(n)}{(n - 1)!} x^n \\G(x) &= \sum_{n = 0}^\infty \frac{2^{ \binom n2}}{n!} x^n \\H(x) &= \sum_{n = 0}^\infty \frac{2^{ \binom n2}}{(n - 1)!} x^n\end{align}</script><p>那么有</p><script type="math/tex; mode=display">\begin{align}H(x) & \equiv F(x) G(x) \pmod{x^{n + 1}} \\F(x) & \equiv H(x) G^{-1}(x) \pmod{x^{n + 1}}\end{align}</script><p>把 $H(x)$ 和 $G(x)$ 的逆卷一块就得到了 $F(x)$，再乘上一个 $(n - 1)!$ 就完事了。总复杂度 $O(n \log n)$。</p><h4 id="code-9"><a href="#code-9" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> Poly_t = <span class="type">int</span>[<span class="number">1</span>&lt;&lt;<span class="number">18</span>|<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1004535809</span>, g = <span class="number">3</span>, invG = <span class="number">334845270</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Pow</span><span class="params">(ll b, ll p = mod - <span class="number">2</span>, ll m = mod)</span></span>;</span><br><span class="line"></span><br><span class="line">Poly_t F, G, G_, to;</span><br><span class="line"><span class="type">int</span> *H = F, fac[<span class="number">130003</span>], invF[<span class="number">130003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">  invF[N] = <span class="built_in">Pow</span>(fac[N]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = N; i; --i)</span><br><span class="line">    invF[i - <span class="number">1</span>] = <span class="number">1ll</span> * invF[i] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> *a, <span class="type">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PolyInv</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim, l;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; N;</span><br><span class="line">  <span class="built_in">prework</span>(N);</span><br><span class="line">  G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    G[i] = <span class="number">1ll</span> * <span class="built_in">Pow</span>(<span class="number">2</span>, <span class="number">1ll</span> * i * (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) * invF[i] % mod;</span><br><span class="line">    H[i] = <span class="number">1ll</span> * <span class="built_in">Pow</span>(<span class="number">2</span>, <span class="number">1ll</span> * i * (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) * invF[i - <span class="number">1</span>] % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">PolyInv</span>(N + <span class="number">1</span>, G, G_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (lim = <span class="number">1</span>, l = <span class="number">-1</span>; lim &lt;= N &lt;&lt; <span class="number">1</span>; lim &lt;&lt;= <span class="number">1</span>, ++l);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    to[i] = (to[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NTT</span>(lim, H, <span class="number">1</span>), <span class="built_in">NTT</span>(lim, G_, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    F[i] = <span class="number">1ll</span> * G_[i] * H[i] % mod;</span><br><span class="line">  <span class="built_in">NTT</span>(lim, F, <span class="number">-1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span> * F[N] * fac[N - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="CF662C-Binary-Table"><a href="#CF662C-Binary-Table" class="headerlink" title="CF662C Binary Table"></a><a href="http://codeforces.com/problemset/problem/662/C">CF662C Binary Table</a></h3><h4 id="problem-9"><a href="#problem-9" class="headerlink" title="problem"></a>problem</h4><p>给定一个 $n \ (1 \le n \le 20)$ 行 $m \ (1 \le m \le 10^6)$ 列的 01 矩阵，每次操作可以选定一行或一列并将其中所有元素取反，求若干次操作后可能的最少的 1 的个数。</p><h4 id="solution-10"><a href="#solution-10" class="headerlink" title="solution"></a>solution</h4><p>暴力是这样子的：$2^n$ 枚举每一行是否翻转，每种状态的答案是每一列 0/1 个数的较小值之和。总复杂度 $O(m 2^n)$。</p><p>枚举状态 $S$ 表示每一行是否翻转，设 $a_i$ 表示初始矩阵中有多少列状态为 $i$，$b_i$ 表示状态 $i$ 的 0/1 的个数的较小值，$f_i$ 表示枚举到状态 $i$ 时的答案，那么</p><script type="math/tex; mode=display">f_S = \sum_{i = 0}^{2^n - 1}{a_i b_{i \oplus S}}</script><p>也即</p><script type="math/tex; mode=display">f_S = \sum_{i \oplus j = S}{a_i b_j}</script><p>发现这是异或卷积的形式，可以用 FWT 在 $O(n \log n)$ 的时间内求出 $f_{1 \cdots 2^n}$，取最小值就是答案。</p><h4 id="code-10"><a href="#code-10" class="headerlink" title="code"></a>code</h4><p>FWT 实现看多项式笔记。本题不需要也不应该取模。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> Poly_t = ll[<span class="number">1</span>&lt;&lt;<span class="number">20</span>|<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z[<span class="number">100003</span>];</span><br><span class="line">Poly_t a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> N, N_, M;</span><br><span class="line">  ll* f = a;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">      <span class="keyword">if</span> (cin.<span class="built_in">get</span>())</span><br><span class="line">        z[j] |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">    ++a[z[i]];</span><br><span class="line">  N_ = N, N = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    b[i] = b[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    b[i] = std::<span class="built_in">min</span>(b[i], N_ - b[i]);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">XOR</span>(N, a, <span class="number">1</span>), <span class="built_in">XOR</span>(N, b, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    f[i] = a[i] * b[i];</span><br><span class="line">  <span class="built_in">XOR</span>(N, f, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; *std::<span class="built_in">min_element</span>(f, f + N);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="CF850E-Random-Elections"><a href="#CF850E-Random-Elections" class="headerlink" title="CF850E Random Elections"></a><a href="https://www.luogu.com.cn/problem/CF850E">CF850E Random Elections</a></h3><h4 id="problem-10"><a href="#problem-10" class="headerlink" title="problem"></a>problem</h4><p>A, B, C 三人比赛，$2^n \ (1 \le n \le 20)$ 个人投票。<strong>每个人有一个确定的顺序</strong>，他们把票投给顺序靠前的人。</p><p>有一个函数 $f(S)$，接受一个长度 $n = 2^k$ 的二进制串 $S$ 并返回 true/false。保证 $f(\neg S_1, \neg S_2, \cdots, \neg S_n) = \neg f(S_1, S_2, \cdots, S_n)$。</p><p>比赛结果由 $n$ 个人投票决定，给定 $S$，$S_i$ 表示 $f(i)$ 的取值。询问单循环的三场比赛满足有同一个人连胜两场的方案数。</p><h4 id="solution-11"><a href="#solution-11" class="headerlink" title="solution"></a>solution</h4><p>假设 A 连胜两场，答案乘以 $3$ 即可。</p><p>设某人两场比赛的决策是 $(x_1, x_2)$，那么可以得到他的决策序列：</p><ul><li>$(0, 0) \to \text{BCA, CBA}$</li><li>$(0, 1) \to \text{BAC}$</li><li>$(1, 0) \to \text{CAB}$</li><li>$(1, 1) \to \text{ABC, ACB}$</li></ul><p>发现如果 $x_1 \oplus x_2 = 0$ 就可以对方案数造成 $2$ 的贡献。所有位压在一起那么方案就是 $2^{n - \operatorname{popcount}(S_1 \oplus S_2)}$。</p><p>直接枚举是 $O(4^n)$ 的，可以 FWT 预处理出异或值等于 $1 \cdots 2^n$ 的数对个数再统计贡献。</p><h4 id="code-11"><a href="#code-11" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1&#x27;000&#x27;000&#x27;007</span>, inv2 = <span class="number">500&#x27;000&#x27;004</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N_, <span class="type">int</span>* F)</span> </span>&#123; <span class="comment">// F[0...2^N_)</span></span><br><span class="line">  <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; N_, ans = <span class="number">0</span>, *popcnt = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">XOR</span>(N, F, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    F[i] = <span class="number">1ll</span> * F[i] * F[i] % mod;</span><br><span class="line">  <span class="built_in">XOR</span>(N, F, inv2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    popcnt[i] = popcnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    ans = (ans + <span class="number">1ll</span> * F[i] * (<span class="number">1</span> &lt;&lt; (N_ - popcnt[i]))) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3ll</span> * ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="P5816-CQOI2010-内部白点"><a href="#P5816-CQOI2010-内部白点" class="headerlink" title="P5816 [CQOI2010]内部白点"></a><a href="https://www.luogu.com.cn/problem/P5816">P5816 [CQOI2010]内部白点</a></h4><h4 id="problem-11"><a href="#problem-11" class="headerlink" title="problem"></a>problem</h4><p>初始时网格图里有 $n \ (1 \le n \le 10^5)$ 个黑点，所有其他整数点都是白色的。每秒钟所有<strong>内部白点</strong>同时变黑，直到不存在内部白点为止。计算最终网格图中的黑点个数或判断变化不会结束。</p><p><strong>内部白点的定义</strong>：一个白色的整点是内部白点当且仅当其所在的水平线的左边和右边各至少有一个黑点，且所在竖直线的上边和下边各至少有一个黑点。形式化地，点 $P(x, y)$ 是黑点当且仅当存在黑点 $(x_1, y), (x_2, y), (x, y_1), (x, y_2)$ 满足 $x_1 &lt; x &lt; x_2, y_1 &lt; x &lt; y_2$。</p><h4 id="solution-12"><a href="#solution-12" class="headerlink" title="solution"></a>solution</h4><p>👴又回来整 DS 🌶！</p><p>首先这题变化是一定会结束的，并且会在一次变化内结束<del>（好像很显然的样子）</del>，因为 新产生的黑点能够产生的黑点 一定是 原有黑点能产生的黑点 的子集。</p><p>我们对于每个 $x$ 坐标，记录 $y$ 坐标最小和最大的点，对于 $y$ 最小/最大的点打标记 $1 / -1$，再对每对 $x$ 坐标相同的点连一条水平线段。</p><p>这样从下向上扫描，对于每个标记修改相应位置的点值；对于每条线段统计区间和，即可得到答案。</p><h4 id="code-12"><a href="#code-12" class="headerlink" title="code"></a>code</h4><p>这个做法除去 ds 外时间常数并不好；空间常数会好一些；在碰到重复点时会暴毙，好在这题保证了没有重复点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">&#125; z[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(Point lhs, Point rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">tie</span>(lhs.x, lhs.y) &lt; std::<span class="built_in">tie</span>(rhs.x, rhs.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(Point lhs, Point rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">tie</span>(lhs.y, lhs.x) &lt; std::<span class="built_in">tie</span>(rhs.y, rhs.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r, y, k;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Line rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tie</span>(y, k) &lt; std::<span class="built_in">tie</span>(rhs.y, rhs.k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; e[<span class="number">300003</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N_, z_[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">  <span class="type">int</span> t[<span class="number">100003</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> p)</span></span>;</span><br><span class="line">&#125; <span class="comment">// BIT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> N, M = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; z[i].x &gt;&gt; z[i].y;</span><br><span class="line">    z_[i] = z[i].x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(z_ + <span class="number">1</span>, z_ + N + <span class="number">1</span>);</span><br><span class="line">  N_ = std::<span class="built_in">unique</span>(z_ + <span class="number">1</span>, z_ + N + <span class="number">1</span>) - z_ - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    z[i].x = std::<span class="built_in">lower_bound</span>(z_ + <span class="number">1</span>, z_ + N_ + <span class="number">1</span>, z[i].x) - z_;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(z + <span class="number">1</span>, z + N + <span class="number">1</span>, cmpx);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (z[i].x == z[i + <span class="number">1</span>].x) &#123;</span><br><span class="line">      e[++M] = &#123;z[i].x, <span class="number">0</span>, z[i].y, <span class="number">1</span>&#125;;</span><br><span class="line">      e[++M] = &#123;z[i + <span class="number">1</span>].x, <span class="number">0</span>, z[i + <span class="number">1</span>].y, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(z + <span class="number">1</span>, z + N + <span class="number">1</span>, cmpy);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (z[i].y == z[i + <span class="number">1</span>].y)</span><br><span class="line">      e[++M] = &#123;z[i].x, z[i + <span class="number">1</span>].x, z[i].y, <span class="number">0</span>&#125;;</span><br><span class="line">  std::<span class="built_in">sort</span>(e + <span class="number">1</span>, e + M + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    <span class="keyword">if</span> (e[i].k) BIT::<span class="built_in">Modify</span>(e[i].l, e[i].k);</span><br><span class="line">    <span class="keyword">else</span> ans += BIT::<span class="built_in">Query</span>(e[i].r - <span class="number">1</span>) - BIT::<span class="built_in">Query</span>(e[i].l);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans + N &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写于 2020/4/30 22:46</p><p>这个月结束了，可以说是放假来最不颓的一个月（其实颓得也蛮多的）</p><p>先整了几道题，又重学了数论、从零开始学了多项式，统共码了 2w+ 字的博文。</p><p>基础算法和思维比较薄弱，希望下个月能加强下。</p><p>下个月这时候说不定就要退役了。</p><p>希望能够不辜负自己吧。</p>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>某 AtCoder 的 dp 场</title>
      <link href="/2020/%E6%9F%90At%E7%9A%84dp%E5%9C%BA/"/>
      <url>/2020/%E6%9F%90At%E7%9A%84dp%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><del>Typical DP Contest，13 年的远古比赛了</del></p><p><a href="https://tdpc.contest.atcoder.jp/">比赛地址</a></p><p>本文为部分翻译+题解</p><p>谷的翻译大部分（所有正确使用了 $\LaTeX$ 的）是我搞的。很惭愧，就做了一点微小的贡献。</p><span id="more"></span><hr><h3 id="A-コンテスト"><a href="#A-コンテスト" class="headerlink" title="A - コンテスト"></a>A - コンテスト</h3><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><p>有一场有 $n \ (1 \le n \le 100)$ 个问题的比赛，其中第 $i$ 个问题的分数为 $p_i \ (1 \le p_i \le 100)$。某个参赛者的分数为他做出的题目的分数之和。有多少种可能的得分？</p><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>傻逼背包，连优化都不用的那种（</p><hr><h3 id="B-ゲーム"><a href="#B-ゲーム" class="headerlink" title="B - ゲーム"></a>B - ゲーム</h3><h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h4><p>Alice 和 Bob 在玩游戏。初始时有两座山，左边的山上有 $A$ 个物品，从上到下的第 $i$ 个价值为 $a_i$；右边的山上有 $B$ 个物品，从上到下的第 $i$ 个价值为 $b_i$。Alice 先手，Alice 和 Bob 交替进行操作，可行的操作如下：</p><ul><li>如果两座山都空了，游戏结束。</li><li>如果只有某一座山空了，取走另一座山上的最上面的物品。</li><li>如果两座山都没有空，选择任意一座山，并取走其最上面的物品。</li></ul><p>两人都想取得更大的价值。假设两人都采取最优策略，请求出 Alice 能取得的物品的价值总和。</p><p>输入的所有数字都是 $[1, 1000]$ 中的整数。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>考虑从终局向前逆推。设 $f_{i, j}$ 表示 $A$ 被取走第 $i \sim A$ 个物品， $B$ 被取走第 $j \sim B$ 个物品时的价值。</p><p>对 $i + j$ 为偶数/奇数，即 Alice/Bob 操作时分类转移：</p><script type="math/tex; mode=display">f_{i, j} = \begin{cases}\max(f_{i + 1, j} + a_i, f_{i, j + 1} + b_j) & , (i + j) \equiv 0 \pmod 2 \\\min(f_{i + 1, j}, f_{i, j + 1}) & , (i + j) \equiv 1 \pmod 2\end{cases}</script><p>边界条件 $f_{i, B + 1} = f_{A + 1, j} = 0$。</p><p>答案即为 $f_{1, 1}$。总复杂度 $O(AB)$。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>实现时要尤其注意边界情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">1003</span>][<span class="number">1003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span>* a, <span class="keyword">int</span> B, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// a, b 下标均从 1 开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = A + <span class="number">1</span>; i; --i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = B + <span class="number">1</span>; j; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; A &amp;&amp; j &gt; B) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; A)</span><br><span class="line">          f[i][j] = f[i][j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; B)</span><br><span class="line">          f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          f[i][j] = std::<span class="built_in">min</span>(f[i + <span class="number">1</span>][j], f[i][j + <span class="number">1</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; A)</span><br><span class="line">          f[i][j] = f[i][j + <span class="number">1</span>] + b[j];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; B)</span><br><span class="line">          f[i][j] = f[i + <span class="number">1</span>][j] + a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          f[i][j] = std::<span class="built_in">max</span>(f[i + <span class="number">1</span>][j] + a[i], f[i][j + <span class="number">1</span>] + b[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> f[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="C-トーナメント"><a href="#C-トーナメント" class="headerlink" title="C - トーナメント"></a>C - トーナメント</h3><h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h4><p>有 $2^k \ (1 \le k \le 10)$ 人参加一场锦标赛，这场锦标赛按以下的形式进行。</p><p><em>译者注：我知道可读性很差，但是很好理解，日语原题面就是这样的</em></p><ul><li>第 1 轮，1 和 2，3 和 4，… 进行比赛。</li><li>第 2 轮，(1 和 2 的胜者)和(3 和 4 的胜者)，(5 和 6 的胜者)和(7 和 8 的胜者)，… 进行比赛。</li><li>第 3 轮，((1 和 2 的胜者)和(3 和 4 的胜者)的胜者)和((5 和 6 的胜者)和(7 和 8 的胜者)的胜者)，((9 和 10 的胜者)和(11 和 12 的胜者)的胜者)和((13 和 14 的胜者)和(15 和 16 的胜者)的胜者)，… 进行比赛。</li><li>重复相同的过程，直到第 $K$ 轮。</li></ul><p>第 $K$ 轮结束后将会决出优胜者。如果第 $i$ 个人的 Elo Rating 为 $R_i \ (1 \le R_i \le 4000)$，求出每个人成为优胜者的概率。</p><p>规定：如果 Elo Rating 为 $R_P$ 的人 $P$ 和 Elo Rating 为 $R_Q$ 的人 $Q$ 对战，人 $P$ 的获胜概率为 $1 / (1 + 10^{(R_Q - R_P) / 400})$。假设不同的比赛的胜负是互相独立的。</p><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>显然是道概率 dp（</p><p>设 $f_{k, i}$ 表示第 $k$ 轮比赛中第 $i$ 个人获胜的概率。不难得到这样的转移方程：</p><script type="math/tex; mode=display">f_{k, i} = f_{k - 1, i} \times \sum_{j \in S}{(f_{k - 1, j} \times P)}</script><p>其中 $S$ 表示第 $k$ 轮中可能与 $i$ 比赛的人；$P$ 表示第 $j$ 个人此时获胜的概率。</p><p>边界条件 $f_{i, 0} = 1$。</p><p>答案即为 $f_{K, i} \ (1 \le i \le 2^K)$。总复杂度 $O(K \times 2^K)$。</p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> db = <span class="keyword">double</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R[<span class="number">1</span>&lt;&lt;<span class="number">10</span>|<span class="number">1</span>];</span><br><span class="line">db f[<span class="number">11</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>|<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">calc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + <span class="built_in">pow</span>(<span class="number">10.</span>, (R[q] - R[p]) / <span class="number">400.</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> K, N;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; K;</span><br><span class="line">  N = <span class="number">1</span> &lt;&lt; K;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    cin &gt;&gt; R[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, len; k &lt;= K; ++k) &#123;</span><br><span class="line">    len = <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, mn, mx, mid, l, r; i &lt;= N; ++i) &#123;</span><br><span class="line">      db now = <span class="number">0</span>;</span><br><span class="line">      mx = (i - <span class="number">1</span>) / len * len + len, mn = mx - len + <span class="number">1</span>;</span><br><span class="line">      mid = ((mn + mx) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i &lt; mid) l = mid, r = mx;</span><br><span class="line">      <span class="keyword">else</span> l = mn, r = mid - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 此处的 l ~ r 为可能此时和第 j 个人比赛的编号区间</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; ++j)</span><br><span class="line">        now += f[k - <span class="number">1</span>][j] * <span class="built_in">calc</span>(i, j);</span><br><span class="line">      f[k][i] = now * f[k - <span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>, f[K][i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="D-サイコロ"><a href="#D-サイコロ" class="headerlink" title="D - サイコロ"></a>D - サイコロ</h3><h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem"></a>problem</h4><p>将六个面的骰子掷 $N \ (1 \le N \le 100)$ 次，求每一次掷得的点数的乘积是 $D \ (1 \le D \le 10^{18})$ 的倍数的概率。</p><h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>考虑骰子掷出点数的乘积的质因子只可能有 $2, 3, 5$。考虑直接从这三个因数进行转移。</p><p>设 $f_{i, a, b, c}$ 表示第 $i$ 次掷骰子后点数的乘积中因子 $2$ 有 $a$ 个，$3$ 有 $b$ 个，$5$ 有 $c$ 个的可能性。</p><p>直接枚举每次掷骰子的过程转移即可。</p><p>边界条件 $f_{0, 0, 0, 0} = 1$。</p><p>答案即为 $f_{N, a, b, c}$。总复杂度 $O(Nabc)$。</p><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><p>实现看了看霓虹国神仙 Suikaba 的（小声</p><p>这个 dp 数组甚至可以滚动数组压掉一维，不过这里没写。</p><p>变量名和上文略有不同。数组大小奇怪是因为是压着上界开的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> s2[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> s3[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> s5[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> f[<span class="number">101</span>][<span class="number">61</span>][<span class="number">39</span>][<span class="number">27</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">long</span> <span class="keyword">long</span> D)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> d2 = <span class="number">0</span>, d3 = <span class="number">0</span>, d5 = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (D % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    D /= <span class="number">2</span>, ++d2;</span><br><span class="line">  <span class="keyword">while</span> (D % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">    D /= <span class="number">3</span>, ++d3;</span><br><span class="line">  <span class="keyword">while</span> (D % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    D /= <span class="number">5</span>, ++d5;</span><br><span class="line">  <span class="keyword">if</span> (D != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt;= d2; ++i2)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i3 = <span class="number">0</span>; i3 &lt;= d3; ++i3)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i5 = <span class="number">0</span>; i5 &lt;= d5; ++i5)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t2, t3, t5; j &lt;= <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            t2 = <span class="built_in">min</span>(d2, i2 + s2[j]);</span><br><span class="line">            t3 = <span class="built_in">min</span>(d3, i3 + s3[j]);</span><br><span class="line">            t5 = <span class="built_in">min</span>(d5, i5 + s5[j]);</span><br><span class="line">            f[i + <span class="number">1</span>][t2][t3][t5] += f[i][i2][i3][i5] / <span class="number">6</span>;</span><br><span class="line">          &#125;</span><br><span class="line">  <span class="keyword">return</span> f[N][d2][d3][d5];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="E-数"><a href="#E-数" class="headerlink" title="E - 数"></a>E - 数</h3><h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem"></a>problem</h4><p>求出在 $1 \sim N$ 中有多少个整数的数码和是 $D$ 的倍数。答案对 $10^9 + 7$ 取模。</p><h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h4><p>这里是一篇记忆化搜索实现数位 dp 的题解。</p><p>设 $f_{i, j}$ 为最低位到从低到高第 $i$，模 $D$ 余数为 $j$ 时的合法方案数。</p><p>考虑搜索转移，深搜函数原型 <code>int dfs(int pos, int rem, bool lim)</code>，其中 <code>pos</code> 表示当前在从低到高第 <code>pos</code> 位，要搜索的余数为 <code>rem</code>，是否贴紧原数上界（<code>lim == 1/0</code>）。转移时按照含义即可。</p><p>注意有些题目需要特判前导零、考虑连续的几位数等特殊情况（本题不需要）。</p><p>dp 数组初始值要为一个小于零的数（想一想，为什么？）</p><h4 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h4><p>理论上记忆化搜索实现要比递推转移常数大一点，但就这题来看这份代码跑得比大多数递推还要快（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, D, num[<span class="number">10003</span>], f[<span class="number">10003</span>][<span class="number">101</span>];</span><br><span class="line">std::string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> rem, <span class="keyword">bool</span> lim)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!pos) <span class="keyword">return</span> !rem;</span><br><span class="line">  <span class="keyword">if</span> (!lim &amp;&amp; f[pos][rem] != <span class="number">-1</span>) <span class="keyword">return</span> f[pos][rem];</span><br><span class="line">  <span class="keyword">int</span> mx = lim ? num[pos] : <span class="number">9</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mx; ++i)</span><br><span class="line">    ans = (ans + <span class="built_in">dfs</span>(pos - <span class="number">1</span>, (rem + i) % D, lim &amp;&amp; i == mx)) % mod;</span><br><span class="line">  <span class="keyword">if</span> (!lim) f[pos][rem] = ans;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; D &gt;&gt; s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">rbegin</span>(); it != s.<span class="built_in">rend</span>(); ++it)</span><br><span class="line">    num[++N] = *it &amp; <span class="number">15</span>;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">dfs</span>(N, <span class="number">0</span>, <span class="number">1</span>) - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="F-準急"><a href="#F-準急" class="headerlink" title="F - 準急"></a>F - 準急</h3><h4 id="problem-5"><a href="#problem-5" class="headerlink" title="problem"></a>problem</h4><p>有一条有 $N$ 个站的电车线路。你要在这条线路上送外卖。</p><ul><li>你需要在 $1$ 号站停靠，在 {$2$ 号站，…，$N - 1$ 号站} 的子集停靠，在 $N$ 号站停靠。</li><li>你不会在连续超过 $K$ 个车站停靠。</li></ul><p>求有多少种可能的停靠方案数。答案对 $10^9 + 7$ 取模。</p><h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h4><p>设 $f_{i, 0/1}$ 表示前 $i$ 个车站不停靠/停靠的方案数。显然有 $f_{i, 0} = f_{i - 1, 0} + f_{i - 1, 1}$。</p><p>对于 $f_{i, 1}$，需要减去不合法的方案数，即前 $K - 1$ 个车站都停靠的方案数。<del>显然</del>这个等于 $f_{i - K, 0}$。</p><p>边界条件 $f_{0, 0} = f_{0, 1} = f_{1, 1} = 1, f_{1, 0} = 0$。</p><p>答案即为 $f_{N, 1}$。总复杂度 $O(N)$。</p><h4 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1000003</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; K; ++i)</span><br><span class="line">    f[i][<span class="number">0</span>] = f[i][<span class="number">1</span>] = (f[i - <span class="number">1</span>][<span class="number">0</span>] + f[i - <span class="number">1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt;= N; ++i) &#123;</span><br><span class="line">    f[i][<span class="number">0</span>] = f[i][<span class="number">1</span>] = (f[i - <span class="number">1</span>][<span class="number">0</span>] + f[i - <span class="number">1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">    f[i][<span class="number">1</span>] = (f[i][<span class="number">1</span>] - f[i - K][<span class="number">0</span>] + mod) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[N][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="G-辞書順"><a href="#G-辞書順" class="headerlink" title="G - 辞書順"></a>G - 辞書順</h3><h4 id="problem-6"><a href="#problem-6" class="headerlink" title="problem"></a>problem</h4><p>求字符串 $s \ (1 \le |s| \le 10^6)$ 的字典序第 $K \ (1 \le K \le 10^{18})$ 小的非空<strong>子序列</strong>或判断不存在。相同的子序列只计算一次。字符集小写拉丁字母。</p><h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h4><blockquote><p>と，色々書いたけどわかりにくい解説だな…．<br>自分もかなり苦手な問題なので…．<br>—— Suikaba 的原话</p></blockquote><p>看了 Suikaba 神仙的题解，尝试来自己胡一胡（</p><p>设 $\mathrm{nxt}_{i, c}$ 为 $s$ 中第 $i$ 个位置之后第一个出现 $c$ 的位置；$f_i$ 为使用第 $i$ 个位置的字符，其后子序列的个数。那么有</p><script type="math/tex; mode=display">f_i = 1 + \sum_{c \in |T|} f_{\mathrm{nxt}_{i, c}}</script><p>其中 $T$ 表示字符集。加上的 $1$ 表示当前字符单独成串。</p><p>考虑如何找到字典序第 $K$ 小的集合。设一个向后跳的指针，初始指向字符串起始位置。从小到大枚举 $T$ 中的字符，向后边跳指针边统计答案即可。实现细节见代码。</p><h4 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">1000003</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">1000003</span>][<span class="number">27</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> K, f[<span class="number">1000003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld&quot;</span>, s + <span class="number">1</span>, &amp;K);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  std::<span class="built_in">fill</span>(nxt[N + <span class="number">1</span>] + <span class="number">1</span>, nxt[N + <span class="number">1</span>] + <span class="number">27</span>, N + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(nxt[i] + <span class="number">1</span>, nxt[i + <span class="number">1</span>] + <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * <span class="number">26</span>);</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++j) &#123;</span><br><span class="line">      f[i] += f[nxt[i][j]];</span><br><span class="line">      f[i] = std::<span class="built_in">min</span>(f[i], K + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nxt[i][s[i] &amp; <span class="number">31</span>] = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> g = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i, p = <span class="number">1</span>; K &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i)</span><br><span class="line">      <span class="keyword">if</span> (f[nxt[p][i]] &lt; K)</span><br><span class="line">        K -= f[nxt[p][i]];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        --K;</span><br><span class="line">        p = nxt[p][i] + <span class="number">1</span>;</span><br><span class="line">        g = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(i - <span class="number">1</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">26</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(g ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;Eel&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="H-ナップザック"><a href="#H-ナップザック" class="headerlink" title="H - ナップザック"></a>H - ナップザック</h3><h4 id="problem-7"><a href="#problem-7" class="headerlink" title="problem"></a>problem</h4><p>有 $U \ (1 \le U \le 100)$ 个物品，第 $i$ 个的质量、价值、颜色分别为 $w_i, v_i, c_i \ (1 \le w_i, v_i \le 10000, 1 \le c_i \le 50)$。有一个背包，能容纳总质量为 $W \ (1 \le W \le 10000)$，颜色种类数为 $C \ (1 \le C \le 50)$ 的物品。求能容纳的物品的最大总价值。</p><h4 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h4><p>设 $f_{i, j}$ 表示使用不超过 $i$ 种颜色，总质量为 $j$ 时的最大价值。</p><p>需要枚举颜色个数和所有颜色，以每个颜色为整体进行转移。</p><p>转移时直接套用 01 背包转移方程 $F_i = max{\{F_{i - w_j} + v_j\}}$ 即可。其中 $F$ 代表 $f$ 的第一维。</p><p>初始状态 $f_{i, j} = - \infty, f_{0, 0} = 0$。</p><p>答案即为 $\max{\{f_{C, i}\}}$。总复杂度 $O(UCW)$，不过常数很小。</p><h4 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> w, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10003</span>], f[<span class="number">53</span>][<span class="number">10003</span>];</span><br><span class="line">vector&lt;Node&gt; z[<span class="number">53</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, W, C;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N &gt;&gt; W &gt;&gt; C;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, w, v, c; i &lt;= N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; w &gt;&gt; v &gt;&gt; c;</span><br><span class="line">    z[c].<span class="built_in">push_back</span>(&#123;w, v&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0xc0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">50</span>; ++c)</span><br><span class="line">    <span class="keyword">if</span> (z[c].<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = C; i; --i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(t, f[i - <span class="number">1</span>], <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (W + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (Node x : z[c])</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= x.w; --j)</span><br><span class="line">            t[j] = <span class="built_in">max</span>(t[j], t[j - x.w] + x.v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; ++j)</span><br><span class="line">          f[i][j] = <span class="built_in">max</span>(f[i][j], t[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  cout &lt;&lt; *<span class="built_in">max_element</span>(f[C], f[C] + W + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="I-イウィ"><a href="#I-イウィ" class="headerlink" title="I - イウィ"></a>I - イウィ</h3><h4 id="problem-8"><a href="#problem-8" class="headerlink" title="problem"></a>problem</h4><p>给定一个仅由字符 $\texttt{i}$ 和 $\texttt{w}$ 构成的字符串 $s \ (1 \le |s| \le 300)$。你可以进行若干次操作，每次从串中选取连续的三个字符 $\texttt{iwi}$ 并删除。删除后这三个字符的左侧和右侧会连接在一起，得到一个长度比原来小 $3$ 的新串。求可能的最大操作次数。</p><h4 id="solution-amp-code-1"><a href="#solution-amp-code-1" class="headerlink" title="solution &amp; code 1"></a>solution &amp; code 1</h4><p>设 $f_{l, r}$ 表示 $s$ 的子串 $s_{l..r}$ 的答案。这个可以直接枚举分界点 $m \in [l, r)$ 分治转移。</p><p>套上记忆化，总复杂度是 $O(n^2)$ 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">303</span>][<span class="number">303</span>];</span><br><span class="line">std::string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// [l, r]</span></span><br><span class="line">  <span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (f[l][r] != <span class="number">-1</span>) <span class="keyword">return</span> f[l][r];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = l; m &lt; r; ++m) &#123;</span><br><span class="line">    ans = std::<span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(l, m) + <span class="built_in">dfs</span>(m + <span class="number">1</span>, r));</span><br><span class="line">    <span class="keyword">if</span> (s[l] == <span class="string">&#x27;i&#x27;</span> &amp;&amp; s[m] == <span class="string">&#x27;w&#x27;</span> &amp;&amp; s[r] == <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dfs</span>(l + <span class="number">1</span>, m - <span class="number">1</span>) == m - l - <span class="number">1</span> &amp;&amp; <span class="built_in">dfs</span>(m + <span class="number">1</span>, r - <span class="number">1</span>) == r - m - <span class="number">1</span>)</span><br><span class="line">        ans = r - l + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[l][r] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="solution-amp-code-2"><a href="#solution-amp-code-2" class="headerlink" title="solution &amp; code 2"></a>solution &amp; code 2</h4><p>其实这题大可不必 dp。考虑删去一个串 $\texttt{iwi}$ 后当且仅当它的左侧或右侧是 $\texttt{i}$ 才有可能出现一个新的串 $\texttt{iwi}$。</p><p>可以首先删去所有的 $\texttt{iwii}$ 和 $\texttt{iiwi}$ 的子串 $\texttt{iwi}$。</p><p>总复杂度也是 $O(n^2)$，带一个很小的常数<del>，具体多小取决于数据强度</del>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> N = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string::size_type p = <span class="number">0</span>; ; )</span><br><span class="line">    <span class="keyword">if</span> ((p = s.<span class="built_in">find</span>(<span class="string">&quot;iiwi&quot;</span>)) != std::string::npos)</span><br><span class="line">      s.<span class="built_in">erase</span>(p + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((p = s.<span class="built_in">find</span>(<span class="string">&quot;iwii&quot;</span>)) != std::string::npos)</span><br><span class="line">      s.<span class="built_in">erase</span>(p, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string::size_type p = <span class="number">0</span>; (p = s.<span class="built_in">find</span>(<span class="string">&quot;iwi&quot;</span>, p)) != std::string::npos; )</span><br><span class="line">    s.<span class="built_in">erase</span>(p, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (N - s.<span class="built_in">size</span>()) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="J-ボール"><a href="#J-ボール" class="headerlink" title="J - ボール"></a>J - ボール</h3><h4 id="problem-9"><a href="#problem-9" class="headerlink" title="problem"></a>problem</h4><p>有 $N \ (1 \le N \le 16)$ 个物品，其中第 $i$ 个在 $x_i \ (0 \le x_i \le 15)$ 坐标处。向坐标 $x$ 扔球时，分别有 $\frac{1}{3}$ 的概率击中坐标 $x - 1, x, x + 1$ 中的一个；如果打中的坐标上有物品，将其打倒。求出在最优策略下期望扔球多少次将所有物品打倒。保证 $x_i$ 两两不同。</p><p>赛时补充：<strong>每次扔球时可以先看到上一次扔球击中的位置再决定向哪里扔球。</strong></p><h4 id="problem-10"><a href="#problem-10" class="headerlink" title="problem"></a>problem</h4><p>看到这个数据范围，盲猜状压。</p><p>设 $E(S)$ 为状态 $S$ 时的期望次数。考虑如何转移。一般这种题需要列出一个关于 $E(S)$ 的方程，把它反解出来。</p><p>考虑向 $x$ 扔球的情况，能列出这样的一个方程：</p><script type="math/tex; mode=display">E(S) = 1 + \sum{(P(u) \times E(T))} + (1 - \sum{P(u)}) \times E(S)</script><p>其中 $P(x) = \frac{1}{3}$ 表示击中坐标 $x$ 的概率，$u \in \{x - 1, x, x + 1 \}$，<code>T = S &amp; ~u</code>。化简可得</p><script type="math/tex; mode=display">E(S) = \frac{1 + \sum{(P(u) \times E(T))}}{\sum P(u)}</script><p>就可以枚举 $x$ 进行转移了。</p><p>显然可以记忆化一下。设 $f_S = E(S)$，初始状态 $f_0 = 0$。</p><p>答案即为 $E(S)$。总复杂度 $O(N \times 2^N)$。</p><h4 id="code-7"><a href="#code-7" class="headerlink" title="code"></a>code</h4><p>代码可能换了一些奇怪的写法，但是跟上面式子是等价的（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> f[<span class="number">1</span>&lt;&lt;<span class="number">16</span>|<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (f[S] &gt;= <span class="number">0.</span>) <span class="keyword">return</span> f[S];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> ans = <span class="number">1</span> &lt;&lt; <span class="number">16</span>, E;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, c; x &lt; <span class="number">16</span>; ++x) &#123;</span><br><span class="line">    <span class="keyword">int</span> T[] = &#123;</span><br><span class="line">      S &amp; ~((<span class="number">1</span> &lt;&lt; x) &lt;&lt; <span class="number">1</span>),</span><br><span class="line">      S &amp; ~(<span class="number">1</span> &lt;&lt; x),</span><br><span class="line">      S &amp; ~((<span class="number">1</span> &lt;&lt; x) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    c = <span class="number">0</span>, E = <span class="number">1.</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">      <span class="keyword">if</span> (S != T[i])</span><br><span class="line">        E += <span class="built_in">dfs</span>(T[i]) / <span class="number">3.</span>, ++c;</span><br><span class="line">    ans = std::<span class="built_in">min</span>(ans, <span class="number">3</span> * E / c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[S] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, S = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">  std::<span class="built_in">fill</span>(f + <span class="number">1</span>, f + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>), <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t; N; --N) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    S |= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="K-ターゲット"><a href="#K-ターゲット" class="headerlink" title="K - ターゲット"></a>K - ターゲット</h3><h4 id="problem-11"><a href="#problem-11" class="headerlink" title="problem"></a>problem</h4><p>对于一个含 $K$ 个圆的序列 $C_1, C_2, \cdots, C_K$，如果对于每个 $i$ 都有圆 $C_{i + 1}$ <strong>严格</strong>位于圆 $C_i$ 的内部，那么它们可以成为一个大小为 $K$ 的靶子。</p><p>平面直角坐标系里有 $N \ (1 \le N \le 10^6)$ 个圆，第 $i$ 个的圆心为 $(x_i, 0) \ (1 \le x_i \le 10^9)$，半径为 $r_i \ (1 \le r_i \le 10^9)$。选出若干个圆并重新排列构成靶子，求出可能构成的靶子的最大大小。</p><h4 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a>solution</h4><p>对于每个圆 $i$ 构造一个二元组 $(x_i + r_i, x_i - r_i)$，按升序排序，再对第二关键字求出最长下降子序列的长度就是答案。</p><p>想象一下一堆圆画在这里是什么样子的、取出合法的部分是什么样子的，这个就很显然了（</p><h4 id="code-8"><a href="#code-8" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100003</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, N_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, r; i &lt;= N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; r;</span><br><span class="line">    p[i] = &#123;x + r, x - r&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(p + <span class="number">1</span>, p + N + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  f[<span class="number">1</span>] = -p[<span class="number">1</span>].second;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (f[N_] &lt; -p[i].second) f[++N_] = -p[i].second;</span><br><span class="line">    <span class="keyword">else</span> *<span class="built_in">lower_bound</span>(f + <span class="number">1</span>, f + N_ + <span class="number">1</span>, -p[i].second) = -p[i].second;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N_);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="L-猫"><a href="#L-猫" class="headerlink" title="L - 猫"></a>L - 猫</h3><h4 id="problem-12"><a href="#problem-12" class="headerlink" title="problem"></a>problem</h4><p>有 $N \ (1 \le N \le 1000)$ 只猫，猫 $i$ 和猫 $j$ 的友好值为 $z_{i, j} \ (1 \le z_{i, j} \le 1000)$。猫的幸福度是与距离不超过 $1$ 的所有猫的友好值之和。把猫按照 $1 \sim N$ 的顺序置于一条线上（设猫 $i$ 的坐标为 $x_i$，则 $\forall i \in [1, N), x_i &lt; x_{i + 1}$）。$x_i$ 可以为任意实数。求猫的幸福度之和的最大值。</p><p>保证 $z_{i, i} = 0, z_{i, j} = z_{j, i}$。</p><h4 id="solution-9"><a href="#solution-9" class="headerlink" title="solution"></a>solution</h4><p>设 $f_{i, j} \ (j \le i)$ 表示猫 $j$ 和猫 $i$ 在 $1$ 距离以内时前 $i$ 只猫的最大幸福度（两两之间计算一次）。则</p><script type="math/tex; mode=display">f_{i, j} = \max_{k = 1}^j{\{f_{i - 1, k}\}} + \sum_{l = j}^i z_{i, l}</script><p>这个转移是 $O(N)$ 的，太慢了，要想办法优化掉。</p><p>令 $\mathrm{mx}_{i, k} = \max_{k = 1}^j{\{f_{i - 1, k}\}}, s_{i, j} = \sum_{k = j}^i z_{i, k}$，则 $f_{i, j} = \mathrm{mx}_{i, j} + s_{i, i} - s_{i, j - 1}$，转移成了 $O(1)$ 的。</p><p>答案即为 $2 \times \max{\{f_{N, i}\}}$。总复杂度 $O(N^2)$。</p><h4 id="code-9"><a href="#code-9" class="headerlink" title="code"></a>code</h4><p>这里把三个数组都压了一维。其中 $\mathrm{mx}$ 先使用 $\mathrm{mx}_{i}$ 而后统计 $\mathrm{mx}_{i + 1}$。</p><p>注意这个写法下 $\mathrm{mx}_{i, 0}$ 要初始化成负无穷大。</p><p>这份代码目前在 AtC 是时间并列第一。空间有神仙用 <code>std::vector</code> 卡到 256KB 的，实在卡不过（</p><p>听说有写法还能省掉一个数组，不管了不管了.jpg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s[<span class="number">1003</span>], mx[<span class="number">1003</span>], f[<span class="number">1003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  mx[<span class="number">0</span>] = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">      cin &gt;&gt; s[j], s[j] += s[j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">      f[j] = mx[j] + s[i] - s[j - <span class="number">1</span>];</span><br><span class="line">      mx[j] = std::<span class="built_in">max</span>(mx[j - <span class="number">1</span>], f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[i + <span class="number">1</span>] = mx[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *std::<span class="built_in">max_element</span>((f + <span class="number">1</span>, f + N + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="M-家"><a href="#M-家" class="headerlink" title="M - 家"></a>M - 家</h3><h4 id="problem-13"><a href="#problem-13" class="headerlink" title="problem"></a>problem</h4><p>一栋房子有 $H \ (2 \le H \le 10^9)$ 层，每层的结构相同，都有 $R \ (1 \le R \le 16)$ 个房间。每层的构造用矩阵 $g$ 表示。如果 $g_{i, j} = 1$，则房间 $i$ 和房间 $j$ 之间有一条双向通路。对于任意的 $h \ (1 &lt; h \le H)$ 和 $r \ (1 \le r \le R)$，可以通过 $h$ 层房间 $r$ 下楼到 $h - 1$ 层房间 $r$，不能上楼。求从 $H$ 层房间 $1$ 到 $1$ 层房间 $1$ 的不自交的路径条数。</p><p>保证 $g_{i, j} \in \{0, 1\}, g_{i, i} = 0, g_{i, j} = g_{j, i}$。答案对 $10^9 + 7$ 取模。</p><h4 id="solution-10"><a href="#solution-10" class="headerlink" title="solution"></a>solution</h4><p><del>看到大得离谱的 $H$ 直接推测矩阵+快速幂相关，看到小得离谱的 $R$ 直接推测状压相关</del></p><p>设矩阵 $M_{i, j}$ 表示在同一层中房间 $i$ 到房间 $j$ 的不自交的路径数。</p><p>这个可以状压求，设 $f_{s, i, S}$ 为从房间 $s$ 出发，经过总点集为 $S$ 到达 $i$ 的不自交的路径数。直接枚举转移没啥问题。那么 $M_{s, i} = \sum{f_{s, i, T}}$。</p><p>初始状态 $f_{i, s, 2^s} = 1$。</p><p>答案即为 $(M^H)_{0, 0}$。总复杂度 $O((2^R + \log H)R^3)$，时限 8s 足够了。</p><h4 id="code-10"><a href="#code-10" class="headerlink" title="code"></a>code</h4><p>对于每个 $s$，$f$ 后两维的值互相独立，可以直接去掉第一维。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _Add(<span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">  <span class="keyword">return</span> (m + n) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  m = _Add(m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> S, z[<span class="number">17</span>][<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Matrix</span>(<span class="keyword">int</span> _S, <span class="keyword">bool</span> e=<span class="number">0</span>); <span class="comment">// e=1 时构造单位矩阵</span></span><br><span class="line">  Matrix <span class="keyword">operator</span>*(Matrix rhs);</span><br><span class="line">  <span class="keyword">friend</span> Matrix <span class="keyword">operator</span>^(Matrix b, <span class="keyword">int</span> p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H, R, z[<span class="number">17</span>][<span class="number">17</span>], f[<span class="number">16</span>][<span class="number">1</span>&lt;&lt;<span class="number">16</span>|<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; H &gt;&gt; R;</span><br><span class="line">  <span class="function">Matrix <span class="title">M</span><span class="params">(R)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; R; ++j)</span><br><span class="line">      std::cin &gt;&gt; z[i][j];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; R; ++s) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[s][<span class="number">1</span> &lt;&lt; s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; <span class="number">1</span> &lt;&lt; R; ++S)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i)</span><br><span class="line">        <span class="keyword">if</span> (f[i][S]) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; R; ++j)</span><br><span class="line">          <span class="keyword">if</span> (!((S &gt;&gt; j) &amp; <span class="number">1</span>) &amp;&amp; z[i][j])</span><br><span class="line">            <span class="built_in">Add</span>(f[j][S | (<span class="number">1</span> &lt;&lt; j)], f[i][S]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i)</span><br><span class="line">      M.z[s][i] = std::<span class="built_in">accumulate</span>(f[i], f[i] + (<span class="number">1</span> &lt;&lt; R), <span class="number">0</span>, _Add);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; (M ^ H).z[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="N-木"><a href="#N-木" class="headerlink" title="N - 木"></a>N - 木</h3><h4 id="problem-14"><a href="#problem-14" class="headerlink" title="problem"></a>problem</h4><p>给定一棵 $N \ (1 \le N \le 1000)$ 个点的树。现在你有 $N$ 个点，需要重新画出这棵树。要求在连边过程中仍然是一棵树。求加边的方案数。</p><h4 id="solution-11"><a href="#solution-11" class="headerlink" title="solution"></a>solution</h4><p>是看的<a href="https://www.luogu.com.cn/blog/ylxmf2005/solution-at690">这个神仙</a>的题解。</p><p>显然可以枚举每个点树形 dp 一遍。假设现在 dfs 到了点 $u$，考虑怎么转移。</p><p>设 $f_u$ 为以 $u$ 为根的子树的方案数，$s_u$ 为这棵子树中有多少条边。</p><p>从 $u$ 的儿子向上转移。假设现在处理到 $v$，需要在当前的加边序列中<strong>相对顺序不变地</strong>加入 $v$ 子树中的边。也即 <code>s[u] += s[v], f[u] = f[u] * f[v] * C(s[u], s[v])</code>。</p><p>最终答案是以每个点为根时的答案总和的一半，因为每条边会被两个端点计算一次，导致方案两两本质相同。</p><p>预处理出组合数，总复杂度 $O(n^2)$。</p><h4 id="code-11"><a href="#code-11" class="headerlink" title="code"></a>code</h4><p>代码中 <code>siz[]</code> 即为上文的 $s$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>, inv2 = <span class="number">500000004</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1003</span>], siz[<span class="number">1003</span>], head[<span class="number">1003</span>], C[<span class="number">1003</span>][<span class="number">1003</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; e[<span class="number">2003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  f[u] = <span class="number">1</span>, siz[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((v = e[i].to) == t) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    siz[u] += siz[v];</span><br><span class="line">    f[u] = <span class="number">1ll</span> * f[u] * f[v] % mod * C[siz[u]][siz[v]] % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  ++siz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="built_in">addEdge</span>(u, v), <span class="built_in">addEdge</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    C[i][<span class="number">0</span>] = C[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">      C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">    ans = (ans + f[i]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span> * ans * inv2 % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="O-文字列"><a href="#O-文字列" class="headerlink" title="O - 文字列"></a>O - 文字列</h3><h4 id="problem-15"><a href="#problem-15" class="headerlink" title="problem"></a>problem</h4><p>构造一个小写字母构成的字符串，其中字母 $\alpha$ 出现了 $z_\alpha \ (0 \le z_\alpha \le 10)$ 次，且相同字母不相邻。求构造方案数。答案对 $10^9 + 7$ 取模。</p><h4 id="solution-12"><a href="#solution-12" class="headerlink" title="solution"></a>solution</h4><p>抄了<a href="https://www.luogu.com.cn/blog/ylxmf2005/solution-at693">这里</a>。</p><h4 id="code-12"><a href="#code-12" class="headerlink" title="code"></a>code</h4><p>c++14。和题解的略有不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _Add(<span class="keyword">int</span> m, <span class="keyword">int</span> n);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;m, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> z[<span class="number">27</span>], f[<span class="number">27</span>][<span class="number">263</span>], C[<span class="number">263</span>][<span class="number">263</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">26</span>, t; i; --i) &#123;</span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">if</span> (t) z[++N] = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">260</span>; ++i) &#123;</span><br><span class="line">    C[i][<span class="number">0</span>] = C[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">      C[i][j] = _Add(C[i - <span class="number">1</span>][j - <span class="number">1</span>], C[i - <span class="number">1</span>][j]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> l = z[<span class="number">1</span>];</span><br><span class="line">  f[<span class="number">1</span>][z[<span class="number">1</span>] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; l; ++k)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= std::<span class="built_in">min</span>(z[i], k); ++b)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>, j; a + b &lt;= z[i] &amp;&amp; a &lt;= l + <span class="number">1</span> - k; ++a) &#123;</span><br><span class="line">          j = k - b + z[i] - a - b;</span><br><span class="line">          <span class="built_in">Add</span>(f[i][j], <span class="number">1ll</span> * f[i - <span class="number">1</span>][k] * C[k][b] % mod * C[l + <span class="number">1</span> - k][a] % mod * C[z[i] - <span class="number">1</span>][a + b - <span class="number">1</span>] % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    l += z[i];</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; f[N][<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="P-うなぎ"><a href="#P-うなぎ" class="headerlink" title="P - うなぎ"></a>P - うなぎ</h3><h4 id="problem-16"><a href="#problem-16" class="headerlink" title="problem"></a>problem</h4><p>有一棵 $N \ (1 \le N \le 1000)$ 个点的树，第 $i$ 条边连接 $a_i$ 和 $b_i$。求出有多少种方案能够选出包含 $K \ (1 \le K \le 50)$ 条互不相交的路径的集合。注意集合是无序的。</p><p>此处两条路径不相交定义为两条路径的点集的交集为端点的并集的子集。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 Mar Records</title>
      <link href="/2020/2020-Mar-Records/"/>
      <url>/2020/2020-Mar-Records/</url>
      
        <content type="html"><![CDATA[<p>菜鸡 fa_555 会把一些动态简要地记在这里。主要还是留给自己以后看的。</p><span id="more"></span><p><em>所有代码不保证包括无关紧要的部分</em></p><hr><p>这个傻逼现在精神状态和身体状态都不好。脑子里啥东西都没有，连续爆零了好几场比赛。</p><p>咕咕咕。</p><!-- 0xf5fc0c --><hr><h3 id="模板-单调队列优化多重背包"><a href="#模板-单调队列优化多重背包" class="headerlink" title="[模板]单调队列优化多重背包"></a><a href="https://www.luogu.com.cn/problem/P1776">[模板]单调队列优化多重背包</a></h3><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><p>一个背包，容积为 $C$。$n$ 种物品，第 $i$ 种的价值、体积、数量分别为 $v_i, c_i, s_i$。</p><p>选出若干个物品，使得它们的体积之和不超过背包容积，且最大化它们的价值之和。求出这个最大价值。</p><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>首先可以把第 $i$ 种物品拆成 $s_i$，当成 01 背包来做。复杂度是 $O(nC^2)$ 的。</p><p>考虑优化。一种简单的优化是二进制拆分，即对于一个 $s_i$，一定能拆分成 $2^0, 2^1, 2^2, \cdots, 2^k, s_i - \sum_{j = 1}^k {2^j}$ 的 $O(\log s_i)$ 个数。可以证明 $\forall i \in [1, s_i]$ 都可以由这些数中的若干个相加得到。复杂度是 $O(nC \log C)$ 的。</p><p>二进制优化不是最优秀的。利用单调队列优化，可以将复杂度优化到 $O(nC)$。令 $f_{i, j}$ 为前 $i$ 种物品占用体积为 $j$ 时的最大价值，考虑状态转移方程：</p><script type="math/tex; mode=display">f(i, j) = \max{ \{f(i - 1, j - kc_i) + kv_i\}} \ (0 \le k \le s_i)</script><p>换一下下标，假设已经求出 $f_{s - 1}$，现在要求 $f_s$。<br>$f_s(i) = f_{s - 1}(i - kv) + kw \ (0 \le k \le a)$<br>$f_{s - 1}(0), f_{s - 1}(v), f_{s - 1}(2v), \cdots$ 可以更新 $f_s(0), f_s(v), f_s(2v), \cdots$<br>$f_{s - 1}(1), f_{s - 1}(v + 1), f_{s - 1}(2v + 1), \cdots$ 可以更新 $f_s(1), f_s(v + 1), f_s(2v + 1), \cdots$<br>任意两组之间不会影响。我们把第一组重编号，得到如下的新转移：<br>$f_s(i) = f_{s - 1}(i - k) + kw \ (0 \le k \le a)$<br>现在决策区间变成连续的了，可以使用 单调队列求出答案。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct Deque &#123; ... &#125; q, w; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">40003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, C, ans = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; N &gt;&gt; C;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v, c, s; N; --N) &#123;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; c &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (!c) &#123; tmp += s * v; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    <span class="built_in">dmin</span>(s, C / c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, K; j &lt; c; ++j) &#123;</span><br><span class="line">      K = (C - j) / c;</span><br><span class="line">      q.<span class="built_in">clear</span>(), w.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, now; k &lt;= K; ++k) &#123;</span><br><span class="line">        now = f[j + k * c] - k * v;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; now &gt;= q.<span class="built_in">back</span>())</span><br><span class="line">          q.<span class="built_in">pop_back</span>(), w.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(now), w.<span class="built_in">push_back</span>(k);</span><br><span class="line">        <span class="keyword">while</span> (k - w.<span class="built_in">front</span>() &gt; s)</span><br><span class="line">          q.<span class="built_in">pop_front</span>(), w.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="built_in">dmax</span>(f[j + k * c], q.<span class="built_in">front</span>() + k * v);</span><br><span class="line">        <span class="built_in">dmax</span>(ans, f[j + k * c]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans + tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="AGC034E-Complete-Compress"><a href="#AGC034E-Complete-Compress" class="headerlink" title="AGC034E Complete Compress"></a><a href="https://agc034.contest.atcoder.jp/tasks/agc034_e">AGC034E Complete Compress</a></h3><h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h4><p>给定一颗 $n$ 个结点的树，某些结点上有棋子（恰好一颗）。</p><p>可以进行若干次操作，每次操作将两颗不相邻的棋子均向中间移动一步。</p><p>判断能否通过若干次操作使得所有的棋子都在一个点上。如果能，求最小操作次数。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>口古口古口古</p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> iarrN = <span class="keyword">int</span>[<span class="number">2003</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">2003</span>];</span><br><span class="line"><span class="keyword">int</span> tot, ans = inf;</span><br><span class="line">iarrN mn, mx, siz, head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  mx[u] = mn[u] = <span class="number">0</span>, siz[u] = c[u] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  <span class="keyword">int</span> son = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((v = e[i].to) == f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    siz[u] += siz[v], mx[u] += mx[v];</span><br><span class="line">    <span class="keyword">if</span> (mx[v] &gt; mx[son]) son = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mn[son] &gt; mx[u] - mx[son])</span><br><span class="line">    mn[u] = mn[son] + mx[son] - mx[u] + siz[u];</span><br><span class="line">  <span class="keyword">else</span> mn[u] = siz[u] + (mx[u] &amp; <span class="number">1</span>);</span><br><span class="line">  mx[u] += siz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;N, c + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="built_in">addEdge</span>(u, v), <span class="built_in">addEdge</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mn[i] - siz[i] == <span class="number">0</span>)</span><br><span class="line">      ans = std::<span class="built_in">min</span>(ans, (mx[i] - siz[i]) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans == inf ? <span class="number">-1</span> : ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="POI2011-Lightning-Conductor"><a href="#POI2011-Lightning-Conductor" class="headerlink" title="[POI2011]Lightning Conductor"></a><a href="https://www.luogu.com.cn/problem/P3515">[POI2011]Lightning Conductor</a></h3><h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h4><p>给定长度为 $n$ 的序列 $a$，对于每个 $i \in [1, n]$，求出一个最小的非负整数 $p$ 使得 $\forall j \in [1, n], a_j \le a_i + p - \sqrt{|i - j|}$。</p><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p><del>肉眼可见决策单调性。然而还是不会维护，抄了题解。</del></p><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> l, r, x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, z[<span class="number">500003</span>];</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">500003</span>], _sqrt[<span class="number">500003</span>];</span><br><span class="line">std::deque&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> z[x] + _sqrt[k - x] &gt; z[y] + _sqrt[k - y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  q.<span class="built_in">clear</span>();</span><br><span class="line">  Node now&#123;<span class="number">1</span>, N, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, l, r, mid; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (z[i] &lt; z[now.x]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (l = i, r = N; l &lt;= r; ) &#123;</span><br><span class="line">      mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">check</span>(now.x, i, mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; N) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; now.l) &#123;</span><br><span class="line">      now = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop_front</span>();</span><br><span class="line">      --i;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    now.r = r;</span><br><span class="line">    q.<span class="built_in">push_front</span>(now);</span><br><span class="line">    now = &#123;l, N, i&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  q.<span class="built_in">push_front</span>(now);</span><br><span class="line">  now = q.<span class="built_in">back</span>();</span><br><span class="line">  q.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now.r &lt; i) now = q.<span class="built_in">back</span>(), q.<span class="built_in">pop_back</span>();</span><br><span class="line">    f[i] = std::<span class="built_in">max</span>(f[i], z[now.x] + _sqrt[i - now.x]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; z[i], f[i] = z[i];</span><br><span class="line">    _sqrt[i] = <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">process</span>();</span><br><span class="line">  std::<span class="built_in">reverse</span>(z + <span class="number">1</span>, z + N + <span class="number">1</span>);</span><br><span class="line">  std::<span class="built_in">reverse</span>(f + <span class="number">1</span>, f + N + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">process</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    cout &lt;&lt; std::<span class="built_in">max</span>((<span class="keyword">int</span>)<span class="built_in">ceil</span>(f[i]) - z[i], <span class="number">0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="AGC035D-Add-and-Remove"><a href="#AGC035D-Add-and-Remove" class="headerlink" title="AGC035D Add and Remove"></a><a href="https://agc035.contest.atcoder.jp/tasks/agc035_d">AGC035D Add and Remove</a></h3><h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>爆搜就完事了嗷</p><hr><h3 id="P3978-TJOI2015-概率论"><a href="#P3978-TJOI2015-概率论" class="headerlink" title="P3978 [TJOI2015]概率论"></a><a href="https://www.luogu.com.cn/problem/P3978">P3978 [TJOI2015]概率论</a></h3><h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem"></a>problem</h4><p>求 $n$ 个结点的有根二叉树的叶子个数的期望。</p><h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h4><p>自己并不会做<del>，考虑抄仓鼠的题解</del>。</p><p>对于一个叶子，可以用一个 pair 描述：去掉该叶子的二叉树，在该二叉树的哪个位置添加这个叶子。</p><p>每个叶子和每个 pair 一一对应，考虑计数这个 pair。</p><p>去掉该叶子的二叉树有 $N - 1$ 个点，数目为 $\mathrm{Cat}_{N - 1}$。</p><p>对于一个 $N - 1$ 个点的二叉树，考虑又多少个空位可以放。总共有 $2(N - 1)$ 个空位，但是有 $N - 2$ 个点已经占据了一个空位。所以有 $N$ 个空位可以添加叶子。</p><p>两个方案数相乘，再除以 $\mathrm{Cat}_N$，化简一下发现答案是 $N(N + 1) / (4N - 2)$。</p><hr><h3 id="P2900-USACO08MAR-Land-Acquisition-G"><a href="#P2900-USACO08MAR-Land-Acquisition-G" class="headerlink" title="P2900 [USACO08MAR]Land Acquisition G"></a><a href="https://www.luogu.com.cn/problem/P2900">P2900 [USACO08MAR]Land Acquisition G</a></h3><h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem"></a>problem</h4><p>给定 $n$ 个二元组，第 $i$ 个为 $(a_i, b_i)$，将这些二元组分成若干组，每组的费用是其中 $\max{ \{a_i b_i\}}$。求最小总费用。</p><h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h4><p>可以发现，若两个二元组 $i, j$ 满足 $a_i \ge a_j \wedge b_i \ge b_j$，则 $j$ 不会对答案有贡献。可以将数据处理成 $a$ 递增 $b$ 递减的形式，则最优解每一组一定是连续的一段。</p><p>可以得到一个 $O(n^2)$ 的转移方程</p><script type="math/tex; mode=display">f_i = \min{ \{f_j + a_{j + 1}b_i\}} \ (0 \le j < i)</script><p>这个方程是有决策单调性的，考虑斜率优化。假设 $j, k$ 满足 $0 \le k &lt; j &lt; i$，若 $j$ 比 $k$ 更优，那么有</p><script type="math/tex; mode=display">f_j + a_{j + 1}b_i < f_k + a_{k + 1}b_i \\f_j - f_k < b_i(a_{k + 1} - a_{j + 1}) \\b_i > \frac{f_j - f_k}{a_{k + 1} - a_{j + 1}}</script><p>维护一个下凸壳就可以斜率优化了。总复杂度 $O(n \log n)$。</p><h4 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> top, q[<span class="number">50003</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">50003</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">&#125; z[<span class="number">50003</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> * (f[i] - f[j]) / (z[j + <span class="number">1</span>].a - z[i + <span class="number">1</span>].a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, N_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    cin &gt;&gt; z[i].a &gt;&gt; z[i].b;</span><br><span class="line">  std::<span class="built_in">sort</span>(z + <span class="number">1</span>, z + N + <span class="number">1</span>, [](Node lhs, Node rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.a != rhs.a) <span class="keyword">return</span> lhs.a &gt; rhs.a;</span><br><span class="line">    <span class="keyword">return</span> lhs.b &gt; rhs.b;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (z[i].b &gt; z[N_].b) z[++N_] = z[i];</span><br><span class="line">  N = N_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, h = <span class="number">1</span>, t = <span class="number">1</span>; i &lt;= N; ++i) &#123; <span class="comment">// q: []</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; t &amp;&amp; <span class="built_in">slope</span>(q[h], q[h + <span class="number">1</span>]) &lt;= z[i].b) ++h;</span><br><span class="line">    f[i] = f[q[h]] + <span class="number">1ll</span> * z[q[h] + <span class="number">1</span>].a * z[i].b;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; t &amp;&amp; <span class="built_in">slope</span>(q[t - <span class="number">1</span>], q[t]) &gt;= <span class="built_in">slope</span>(q[t], i)) --t;</span><br><span class="line">    q[++t] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[N]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="P3195-HNOI2008-玩具装箱"><a href="#P3195-HNOI2008-玩具装箱" class="headerlink" title="P3195 [HNOI2008]玩具装箱"></a><a href="https://www.luogu.com.cn/problem/P3195">P3195 [HNOI2008]玩具装箱</a></h3><h4 id="problem-5"><a href="#problem-5" class="headerlink" title="problem"></a>problem</h4><p>给定长为 $n$ 的序列 $a$，将序列分成若干段，若 $i \sim j$ 为一段，花费为 $(j - i + \sum_{k = i}^j{a_k} - L)^2$。</p><h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h4><p>容易写出这样的状态转移方程：</p><script type="math/tex; mode=display">f_i = \min{ \{f_j + (s_i - s_j + i - j - 1 - L)^2\}}</script><p>其中 $s_i = \sum_{j = 1}^i{a_i}$。这个方程直接维护是 $O(n^2)$ 的。</p><p>令 $S_i = s_i + i, L’ = L + 1$ 得</p><script type="math/tex; mode=display">f_i = f_j + (S_i - S_j - L')^2 \\2S_i(S_j + L') + f_i = f_j + S_i^2+(S_j + L')^2</script><p>令 $f_i = b, 2S_i = k$，就出现了若干条直线</p><script type="math/tex; mode=display">y = kx + b</script><p>其中 $x_j = S_j + L’, y_j = f_j + x_i^2$，$S_i$ 对于每个 $i$ 是确定的。我们要做的就是最小化截距 $b$，即要维护一个下凸壳。可以用单调队列 $O(n)$ 地维护。</p><h4 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> db = <span class="keyword">double</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L, q[<span class="number">50003</span>];</span><br><span class="line">db f[<span class="number">50003</span>], S[<span class="number">50003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">sqr</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> S[i] + L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f[i] + <span class="built_in">sqr</span>(S[i] + L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">Y</span>(i) - <span class="built_in">Y</span>(j)) / (<span class="built_in">X</span>(i) - <span class="built_in">X</span>(j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N &gt;&gt; L;</span><br><span class="line">  ++L;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    S[i] = t + S[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    S[i] += i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, h = <span class="number">1</span>, t = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; t &amp;&amp; <span class="built_in">slope</span>(q[h], q[h + <span class="number">1</span>]) &lt;= <span class="number">2</span> * S[i]) ++h;</span><br><span class="line">    f[i] = f[q[h]] + <span class="built_in">sqr</span>(S[i] - <span class="built_in">X</span>(q[h]));</span><br><span class="line">    <span class="keyword">while</span> (h &lt; t &amp;&amp; <span class="built_in">slope</span>(q[t - <span class="number">1</span>], q[t]) &gt;= <span class="built_in">slope</span>(q[t], i)) --t;</span><br><span class="line">    q[++t] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="AGC002E-Candy-Piles"><a href="#AGC002E-Candy-Piles" class="headerlink" title="AGC002E Candy Piles"></a><a href="https://www.luogu.com.cn/problem/AT1999">AGC002E Candy Piles</a></h3><h4 id="problem-6"><a href="#problem-6" class="headerlink" title="problem"></a>problem</h4><p>桌上有 $n \ (1 \le n \le 10^5)$ 堆糖果，第 $i$ 堆有 $a_i \ (1 \le a_i \le 10^9)$ 个。</p><p>两人轮流进行操作：</p><ol><li>将当前最大的一堆全部吃完；</li><li>将每堆吃掉一个。</li></ol><p>吃完的人输。判断先手或后手必胜。</p><h4 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h4><p>将序列降序排序（图 1）。两个操作分别代表去掉最左边一行或最下面一列。</p><p><img src="/files/img/AGC002E_1.png" alt="图 1"></p><p>我们将原图转化为网格图。这样，操作就转化为了两个玩家向右/上移动一步（图 2），接触到边界的人输。</p><p><img src="/files/img/AGC002E_2.png" alt="图 2"></p><p>根据博弈论的一般规律可以整一个 $O(\sum a_i)$ 的 dp 出每个点的结果（图 3，’x’ 代该点表先手必败，’o’ 表示该点先手必胜），但这显然过不去。</p><p><img src="/files/img/AGC002E_3.png" alt="图 3"></p><p>有一个 $O(n)$ 的做法：从原点向右上扩张出一个可行的最大的正方形，然后分别向右/上移动。如果最大步数均为偶数，则先手必败；否则先手必胜。</p><h4 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> *z)</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">sort</span>(z + <span class="number">1</span>, z + N + <span class="number">1</span>, std::greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (z[i + <span class="number">1</span>] &lt; i + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span> (z[j + <span class="number">1</span>] &gt;= i) ++j;</span><br><span class="line">      <span class="keyword">return</span> ((z[i] - i) | (j - i)) &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><a href="https://www.luogu.com.cn/problem/SP11414">SP11414 COT3 - Combat on a tree</a></p><hr><p><a href="https://www.luogu.com.cn/problem/UVA1697">UVA1697 Baggage</a></p><p>这是一道 ACM WF 的 A 题。</p><hr><p><a href="http://codeforces.com/problemset/problem/611/H">CF611H New Year and Forgotten Tree</a></p><hr><h3 id="P2860-USACO06JAN-Redundant-Paths-G"><a href="#P2860-USACO06JAN-Redundant-Paths-G" class="headerlink" title="P2860 [USACO06JAN]Redundant Paths G"></a><a href="https://www.luogu.com.cn/problem/P2860">P2860 [USACO06JAN]Redundant Paths G</a></h3><h4 id="problem-7"><a href="#problem-7" class="headerlink" title="problem"></a>problem</h4><p>给定一个 $n$ 个结点 $m$ 条边的无向连通图。要求在这张图上加入一些边，使得任意两个结点间都有至少两条没有公共边的路径，求所有合法方案中加入边数的最小值。</p><h4 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a>solution</h4><p>考虑钦定一个点为根向外 dfs，转化为有向图，并将边双连通分量进行缩点，形成一棵 dfs 树。答案显然为这棵树的叶子个数的一半上取整。</p><h4 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h4><p>实现时注意一些细节，比如双向边可以按照编号奇偶性划为一组同时标记。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> iarrN = <span class="keyword">int</span>[<span class="number">5003</span>];</span><br><span class="line"></span><br><span class="line">std::bitset&lt;20013&gt; vis;</span><br><span class="line"><span class="keyword">int</span> N, M, top, tot = <span class="number">1</span>, dft, cntDCC;</span><br><span class="line">iarrN U, V, s, bel, dfn, low, deg, head;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125; e[<span class="number">20013</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  s[++top] = u;</span><br><span class="line">  dfn[u] = low[u] = ++dft;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!dfn[v = e[i].to]) &#123;</span><br><span class="line">      vis.<span class="built_in">set</span>(i), vis.<span class="built_in">set</span>(i ^ <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">tarjan</span>(v);</span><br><span class="line">      vis.<span class="built_in">reset</span>(i ^ <span class="number">1</span>), vis.<span class="built_in">reset</span>(i ^ <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">dmin</span>(low[u], low[v]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">dmin</span>(low[u], dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">    ++cntDCC;</span><br><span class="line">    <span class="keyword">do</span> bel[s[top]] = cntDCC; <span class="keyword">while</span> (s[top--] != u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; U[i] &gt;&gt; V[i];</span><br><span class="line">    <span class="built_in">addEdge</span>(U[i], V[i]), <span class="built_in">addEdge</span>(V[i], U[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    <span class="keyword">if</span> (bel[U[i]] != bel[V[i]])</span><br><span class="line">      ++deg[bel[U[i]]], ++deg[bel[V[i]]];</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntDCC; ++i)</span><br><span class="line">    <span class="keyword">if</span> (deg[i] == <span class="number">1</span>) ++ans;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (ans + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>妙妙问题合集</title>
      <link href="/2020/intriguing-problems/"/>
      <url>/2020/intriguing-problems/</url>
      
        <content type="html"><![CDATA[<p>Last update: Oct 1, 2023</p><span id="more"></span><h2 id="1"><a href="#1" class="headerlink" title="#1"></a>#1</h2><p>这是一道来自学弟学妹组合数学课鸽巢原理部分的作业题。</p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote><p>“随意地给正 n 边形的 n 个顶点编上号 1,2,…,n, 求证：必有一个顶点及与之相邻的两顶点之和不小于 f(n)，并且 f(n) 是不可改进的。给出 f(n) 表达式再进行证明。”</p></blockquote><h3 id="Problem-Abstract"><a href="#Problem-Abstract" class="headerlink" title="Problem Abstract"></a>Problem Abstract</h3><p>原题的表述很奇怪，我们把它抽象一下，同时加一点形式化的表述：</p><blockquote>对于所有前 $n \ (n \ge 3)$ 个自然数的排列 $P_{n}$，求最小可能的 $\displaystyle \max_{i = 1}^n(P_{i - 1} + P_i + P_{i + 1})$，记为 $f(n)$。补充定义 $P_0 = P_n$，$P_{n+1} = P_1$。</blockquote><p>好懂多了。</p><h3 id="Solution-Probably-Desired"><a href="#Solution-Probably-Desired" class="headerlink" title="Solution Probably Desired"></a>Solution Probably Desired</h3><p>利用鸽巢原理很容易求出 $f(n) \ge \left\lceil \dfrac{3n}2 + \dfrac32 \right\rceil$：</p>考虑 $\displaystyle \sum_{i = 1}^n(P_{i - 1} + P_i + P_{i + 1})$，排列里的每个值都会被计算三次，因此它就等于 $3\displaystyle \sum_{i = 1}^n P_i = \dfrac{3n(n + 1)}2$。显然 $f(n) \ge \dfrac{3n(n + 1)}{2n} = \dfrac{3(n + 1)}2$。<p>这个值可能不是整数，违背现实意义，所以套一层上取整得到 $f(n) \ge \left\lceil \dfrac{3n}2 + \dfrac32 \right\rceil$。</p><h3 id="De-Facto-Solution"><a href="#De-Facto-Solution" class="headerlink" title="De Facto Solution"></a>De Facto Solution</h3><!-- 上面的解答只能粗略估计一个下界，但没办法证明这是下确界。实际上这也的确不是。根据 OEIS A066385，答案如下：𝑓(𝑛)=⎧⎩⎨⎪⎪⎪⎪6⌈3𝑛2⌉+2⌈3𝑛2⌉+3,𝑛=3,𝑛=5,6,9,15,otherwise容易编程验证 𝑛比较小时这个通项是正确的。𝑛>15后是猜想，目前没有人能给出过数学证明。原题里那句“并且 𝑓(𝑛)是不可改进的”极其诡异，感觉是老师一拍大腿加上的，把这题变成了不可做题。 --><p>上面的解答只能粗略估计一个下界，但没办法证明这是下确界。实际上这也的确不是。根据 <a href="https://oeis.org/A066385">OEIS A066385</a>，答案如下：</p><script type="math/tex; mode=display">f(n) = \begin{cases}6 & , n = 3 \\\left\lceil \dfrac{3n}2 \right\rceil + 2 & , n = 5, 6, 9, 15 \\\left\lceil \dfrac{3n}2 \right\rceil + 3 & , \text{otherwise}\end{cases}</script><p>容易编程验证 $n$ 比较小时这个通项是正确的。$n &gt; 15$ 时是猜想，目前没有人能给出过数学证明。</p><p>原题里那句“并且 $f(n)$ 是不可改进的”极其诡异，感觉是老师一拍大腿加上的，把这题变成了不可做题。</p><h2 id="2-PE-306"><a href="#2-PE-306" class="headerlink" title="#2 - PE 306"></a>#2 - PE 306</h2><h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem"></a>Problem</h3><blockquote><p>原题链接 <a href="https://projecteuler.net/problem=306">Project Euler Problem 306 - Paper-strip Game</a></p></blockquote><p>Alice 和 Bob 在一组排列成长条型的 $n$ 个格子上玩游戏，两人交替进行操作。</p><p>每回合中一个玩家选择两个连续的空白格子涂黑，最先不能进行操作的玩家输。</p><p>Alice 先手。</p><ul><li><p>$n = 1$ 时 Alice 没有合法操作，直接输掉。</p></li><li><p>$n = 2$ 时，Alice 只有一种合法操作，操作后 Bob 输。</p></li><li><p>$n = 3$ 时，Alice 有两种合法操作，但不论哪种操作过后 Bob 都会输。</p></li><li><p>$n = 4$ 时，Alice 有三种合法操作，她可以涂黑最中间的两个格子使 Bob 无法操作。</p></li><li><p>$n = 5$ 时如图 2.1，Alice 有四种合法操作（红色）；但无论他怎么操作，Bob（蓝色）都会赢。</p></li></ul><p><img src="https://projecteuler.net/project/images/p306_pstrip.gif" alt="img"></p><p>因此，对于 $1 \le n \le 5$ 的情况，有 $3$ 种 $n$ 的取值使得 Alice 必胜。</p><p>类似地，对于 $1 \le n \le 50$ 的情况，有 $40$ 种 $n$ 的取值使得 Alice 必胜。</p><p>假设 Bob 和 Alice 都绝对聪明，永远会采取最优策略。</p><p>Bob 非常想让 Alice 赢，但他不想放水。他想知道：对于 $1 \le n \le 1000000$ 的情况，有多少种 $n$ 的取值使得 Alice 必胜？</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这是一个找规律做法。</p><p>博弈论问题，直接考虑要求出每个 $n$ 的 sg 函数。</p><p>枚举所有可能的操作（将原游戏分为大小为 $j$ 和 $i - j - 2$ 的两个游戏），容易得到这样一个式子：</p><script type="math/tex; mode=display">\mathrm{sg}(i) = \mathrm{mex}_{j = 0}^{i - 2}{\{ \mathrm{sg}(j) \oplus \mathrm{sg}(i - j - 2) \}} (i \ge 2)</script><p>$n \in {0, 1}$ 时先手必败，$\mathrm{sg}(0) = \mathrm{sg}(1) = 0$。</p><p>打表得到 $1 \le n \le 204$ 时的 $\mathrm{sg}$ 函数值（每行 $34$ 个）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 2 0 3 1 1 0 3 3 2 2 4 0 5 2 2 3 3 0 1 1 3 0 2 1 1 0 4 5 2 7 4</span><br><span class="line">0 1 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 2 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4</span><br><span class="line">8 1 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4</span><br><span class="line">8 1 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4</span><br><span class="line">8 1 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4</span><br><span class="line">8 1 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4</span><br></pre></td></tr></table></figure><p>容易发现除前两行特殊（共 $13$ 个 $0$）以外，以后的每一行都有恰好 $5$ 个 $0$。</p><p>之后幼儿园级别找规律，答案是 $852938$。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>题解 SP10395 ABA12D - Sum of divisors!</title>
      <link href="/2020/%E9%A2%98%E8%A7%A3-SP10395-ABA12D-Sum-of-divisors/"/>
      <url>/2020/%E9%A2%98%E8%A7%A3-SP10395-ABA12D-Sum-of-divisors/</url>
      
        <content type="html"><![CDATA[<p>under 题解 <a href="https://www.luogu.com.cn/problem/SP10395">SP10395</a></p><p>本文章同步发表于<a href="https://www.luogu.com.cn/blog/fa555/solution-sp10395">洛谷博客</a></p><span id="more"></span><hr><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1"></a>solution 1</h4><p>首先我们有约数和函数 $\sigma$，它是<strong>积性函数</strong>，可以用线筛在线性时间内求出，加个前缀和就做完了，总复杂度 $O(\max{B} + T)$，即 $O(n + q)$。</p><p>其实这题就是个线筛求 $\sigma$ 的板子。</p><hr><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution 2"></a>solution 2</h4><p>不过，抛开这种做法，我们会发现满足要求的数字的一些性质：<strong>满足要求的数都是质数的幂，且除 $2$ 外都是平方数。</strong><a href="http://oeis.org/A000203">证明在这里</a></p><p>用这两条性质做能做到更小的常数，不过由于上一种做法足够优秀，在此就不讨论了。<del>其实是我看不懂证明</del></p><hr><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>代码中 <code>s[i]</code> 表示 $\sigma(i)$，<code>ans[i]</code> 表示答案的前缀和。</p><p><del>关于代码中数组的大小这么奇怪的原因就留作习题吧</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4390848</span>;</span><br><span class="line"></span><br><span class="line">std::bitset&lt;4390849&gt; v;</span><br><span class="line"><span class="keyword">int</span> T, p[<span class="number">308755</span>], s[<span class="number">4390849</span>], ans[<span class="number">1000003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve_sigma</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> M = <span class="number">0</span>;</span><br><span class="line">  v.<span class="built_in">set</span>(<span class="number">1</span>), s[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) p[++M] = i, s[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M &amp;&amp; i * p[j] &lt;= N; ++j) &#123;</span><br><span class="line">      v.<span class="built_in">set</span>(i * p[j]);</span><br><span class="line">      <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">        s[i * p[j]] = s[i] + p[j] * (s[i] - s[i / p[j]]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      s[i * p[j]] = s[i] * s[p[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; ++i)</span><br><span class="line">    ans[i] = ans[i - <span class="number">1</span>] + !v[s[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sieve_sigma</span>();</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l, r; T; --T) &#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; ans[r] - ans[l - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h4><p>这题还是我 半年差一天前（19-08-12）交的翻译来着www</p><p>原题中有这么一句话：“如果你真的想通过这道题来学些东西，不要打表！”</p><p>但唯一的一篇题解还是裸打表（摊手），所以我就写了这篇题解。</p><p>但是写这篇题解真是太棒了，学到许多 /cy</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 Feb Records</title>
      <link href="/2020/2020-Feb-Records/"/>
      <url>/2020/2020-Feb-Records/</url>
      
        <content type="html"><![CDATA[<p>菜鸡 fa_555 会把一些动态简要地记在这里。主要还是留给自己以后看的。</p><span id="more"></span><p><em>所有代码不保证包括无关紧要的部分</em></p><hr><h3 id="【模板】三维偏序"><a href="#【模板】三维偏序" class="headerlink" title="【模板】三维偏序"></a><a href="https://www.luogu.com.cn/problem/P3810">【模板】三维偏序</a></h3><p>CDQ 分治模板。</p><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><p>有 $n$ 个三元组 $(a_i, b_i, c_i)$，设 $f(i) = \sum \limits_{j \ne i} [a_j \le a_i \land b_j \le b_i \land c_j \le c_i]$。</p><p>对于每个 $d \in [0, n)$，求 $f(i) = d$ 的数量。</p><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>求序列逆序对还会吧？我们用归并排序进行分治，每次把区间 $[l, r]$ 分成 $[l, mid], (mid, r]$ 进行递归，在递归时计算 $[l, mid]$ 中对 $(mid, r]$ 的贡献。把下标和权值分别看作两个关键字，这就是二维偏序问题。</p><p>首先将序列按 $a$ 排序。分治时每次将左、右两区间分别按 $b$ 排序。此时左半边的 $a$ 均小于等于右半边。类似二维偏序，随便找个数据结构维护一下 $c$ 即可。</p><p>出现了新的问题：完全相同的元素，原本应当互相有贡献，但 cdq 分治只会计算左侧对右侧的贡献。给每个元素一个权值 $w$（同时维护这个值）。至于最后统计答案，想清楚统计的是什么。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N, M, K, ans[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a, b, c, w, cnt;</span><br><span class="line">&#125; s[<span class="number">100003</span>], z[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Node &amp;l, <span class="keyword">const</span> Node &amp;r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l.a != r.a) <span class="keyword">return</span> l.a &lt; r.a;</span><br><span class="line">  <span class="keyword">if</span> (l.b != r.b) <span class="keyword">return</span> l.b &lt; r.b;</span><br><span class="line">  <span class="keyword">return</span> l.c &lt; r.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> Node &amp;l, <span class="keyword">const</span> Node &amp;r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l.b != r.b) <span class="keyword">return</span> l.b &lt; r.b;</span><br><span class="line">  <span class="keyword">return</span> l.c &lt; r.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">200003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> BIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">CDQ</span>(l, m), <span class="built_in">CDQ</span>(m + <span class="number">1</span>, r);</span><br><span class="line">  std::<span class="built_in">sort</span>(s + l, s + m + <span class="number">1</span>, cmp2);</span><br><span class="line">  std::<span class="built_in">sort</span>(s + m + <span class="number">1</span>, s + r + <span class="number">1</span>, cmp2);</span><br><span class="line">  <span class="keyword">int</span> i = l;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = m + <span class="number">1</span>; j &lt;= r; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; s[i].b &lt;= s[j].b &amp;&amp; i &lt;= m; ++i)</span><br><span class="line">      <span class="built_in">add</span>(s[i].c, s[i].w);</span><br><span class="line">    s[j].cnt += <span class="built_in">query</span>(s[j].c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; i; ++j)</span><br><span class="line">    <span class="built_in">add</span>(s[j].c, -s[j].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; M &gt;&gt; K;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    cin &gt;&gt; z[i].a &gt;&gt; z[i].b &gt;&gt; z[i].c;</span><br><span class="line">  std::<span class="built_in">sort</span>(z + <span class="number">1</span>, z + M + <span class="number">1</span>, cmp1);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= M; ++i, ++j)</span><br><span class="line">    <span class="keyword">if</span> (z[i].a != z[i + <span class="number">1</span>].a || z[i].b != z[i + <span class="number">1</span>].b</span><br><span class="line">     || z[i].c != z[i + <span class="number">1</span>].c)</span><br><span class="line">      s[++N] = z[i], s[N].w = j, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CDQ</span>(<span class="number">1</span>, N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    ans[s[i].cnt + s[i].w - <span class="number">1</span>] += s[i].w;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">    cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="【模板】基数排序"><a href="#【模板】基数排序" class="headerlink" title="【模板】基数排序"></a>【模板】基数排序</h3><p>没啥好说的。不过我跟别人写得都不一样\dk。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N, l[<span class="number">11</span>], z[<span class="number">100003</span>], c[<span class="number">10</span>][<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="keyword">int</span> *z, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>, mx = *std::<span class="built_in">max_element</span>(z + <span class="number">1</span>, z + N + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">do</span> ++ans; <span class="keyword">while</span> (mx /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rsort</span><span class="params">(<span class="keyword">int</span>* z, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> d = <span class="built_in">maxbit</span>(z, N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>, n; d; --d, r *= <span class="number">10</span>) &#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(l, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= N; ++i) &#123;</span><br><span class="line">      t = z[i] / r % <span class="number">10</span>;</span><br><span class="line">      c[t][++l[t]] = z[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l[i]; ++j)</span><br><span class="line">        z[++n] = c[i][j], c[i][j] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="【模板】后缀排序"><a href="#【模板】后缀排序" class="headerlink" title="【模板】后缀排序"></a><a href="https://www.luogu.com.cn/problem/P3809">【模板】后缀排序</a></h3><p><del>没看懂，背代码</del></p><p>咕咕咕 // <strong>TODO</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> iarrN = <span class="keyword">int</span>[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100003</span>];</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">iarrN c, rnk, sa, t, H;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(c + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * M);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    ++c[rnk[i]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M; ++i)</span><br><span class="line">    c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; --i)</span><br><span class="line">    sa[c[rnk[t[i]]]--] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sufSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M = <span class="string">&#x27;z&#x27;</span> - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>; <span class="comment">// 75</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    rnk[i] = s[i] - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>, t[i] = i;</span><br><span class="line">  <span class="built_in">rSort</span>();</span><br><span class="line">  M = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; M &lt; N; w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    M = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - w + <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">      t[++M] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">      <span class="keyword">if</span> (sa[i] &gt; w) t[++M] = sa[i] - w;</span><br><span class="line">    <span class="built_in">rSort</span>();</span><br><span class="line">    <span class="built_in">memcpy</span>(t + <span class="number">1</span>, rnk + <span class="number">1</span>, N &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    rnk[sa[<span class="number">1</span>]] = M = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">      rnk[sa[i]] = (t[sa[i - <span class="number">1</span>]] == t[sa[i]]</span><br><span class="line">        &amp;&amp; t[sa[i - <span class="number">1</span>] + w] == t[sa[i] + w]) ? M : ++M;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rnk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i + j] == s[sa[rnk[i] - <span class="number">1</span>] + j])</span><br><span class="line">      ++j;</span><br><span class="line">    H[rnk[i]] = j;</span><br><span class="line">    <span class="keyword">if</span> (j) --j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fread</span>(s + <span class="number">1</span>, <span class="number">1</span>, <span class="number">100000</span>, stdin);</span><br><span class="line">  N = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (s[N] &lt; <span class="number">48</span>) --N;</span><br><span class="line">  <span class="built_in">sufSort</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    std::cout &lt;&lt; sa[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i)</span><br><span class="line">    std::cout &lt;&lt; H[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="NOI2015-品酒大会"><a href="#NOI2015-品酒大会" class="headerlink" title="[NOI2015]品酒大会"></a><a href="https://www.luogu.com.cn/problem/P2178">[NOI2015]品酒大会</a></h3><p>咕咕咕 // <strong>TODO</strong></p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct IO &#123; ... &#125; cout; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> iarrN = <span class="keyword">int</span>[<span class="number">300003</span>];</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">300003</span>];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v[<span class="number">300003</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SA &#123;</span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line">iarrN H, sa, rnk, c, t, z;</span><br><span class="line">ll now, sum = -inf, ans1[<span class="number">300003</span>], ans2[<span class="number">300003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rSort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sufSort</span><span class="params">()</span></span>;</span><br><span class="line">&#125; <span class="comment">// SA</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> SA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">iarrN fa, siz, mx, mn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span>; <span class="comment">// 路径压缩</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">  now += <span class="number">1ll</span> * siz[u] * siz[v];</span><br><span class="line">  sum = std::<span class="built_in">max</span>(sum, (std::<span class="built_in">max</span>(<span class="number">1ll</span> * mx[u] *  mx[v], <span class="number">1ll</span> * mn[u] * mn[v])));</span><br><span class="line">  <span class="keyword">if</span> (siz[u] &gt; siz[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">  fa[u] = v, siz[v] += siz[u];</span><br><span class="line">  mx[v] = std::<span class="built_in">max</span>(mx[u], mx[v]);</span><br><span class="line">  mn[v] = std::<span class="built_in">min</span>(mn[u], mn[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// DSU</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DSU;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个并查集属实没想出来</span></span><br><span class="line">  <span class="comment">// 感谢 @Nemlit 的题解，太棒了，学到许多</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;N);</span><br><span class="line">  <span class="built_in">fread</span>(s + <span class="number">1</span>, <span class="number">1</span>, N, stdin);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, z + i);</span><br><span class="line">  <span class="built_in">sufSort</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    fa[i] = i, siz[i] = <span class="number">1</span>;</span><br><span class="line">    mx[i] = mn[i] = z[sa[i]];</span><br><span class="line">    v[H[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k : v[i]) <span class="built_in">merge</span>(k, k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (now) ans1[i] = now, ans2[i] = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    cout &lt;&lt; ans1[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans2[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="【模板】单调栈"><a href="#【模板】单调栈" class="headerlink" title="【模板】单调栈"></a><a href="https://www.luogu.com.cn/problem/P5788">【模板】单调栈</a></h3><p>水题。随手写了一发<del>，目前(02-06 23:40)最优解第五。</del>，目前(02-23 21:50) 更新了数据，重交后最优解第一。</p><h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h4><p>给定一个长为 $N$ 的序列 $a$。对于每个元素，求其后第一个大于 $a_i$ 的元素的下标。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>对序列中元素的下标和值维护一个栈。对于每个元素，每当栈顶小于当前元素，记录栈顶所在当前下标的答案并弹栈；最后将当前元素压入栈。</p><hr><h3 id="【模板】乘法逆元2"><a href="#【模板】乘法逆元2" class="headerlink" title="【模板】乘法逆元2"></a><a href="https://www.luogu.com.cn/problem/P5431">【模板】乘法逆元2</a></h3><p><del>鱼说是卡常，实际上是卡了个能过的高复杂度</del></p><p><del>卡完之后这题和逆元几乎没关系了</del></p><h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h4><p>给定长为 $n$ 的正整数序列 $a$ 与常数 $k, p(p \in \mathbb{P})$，求</p><script type="math/tex; mode=display">\sum_{i = 1}^n \frac{k^i}{a_i}</script><p>在模 $p$ 意义下的值。</p><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>直接算复杂度是 $O(n \log p)$，差不多能过<del>，但是完全被卡掉了</del>。</p><p>考虑瞎推式子。设 $\mathrm{Pre}_i$ 表示前 $i$ 个数的前缀积，$\mathrm{Suf}_i$ 表示后 $i$ 个数的后缀积。暴力通分可得所求答案为</p><script type="math/tex; mode=display">\frac{\sum \limits_{i = 1}^n k^i \mathrm{Pre}_{i - 1} \mathrm{Suf}_{i + 1}}{\mathrm{Pre}^n}</script><p>。时间复杂度 $O(n)$。跑得挺快<del>，然而大空间选手震怒</del>。</p><hr><h3 id="抄来的-O-1-龟速乘（？）"><a href="#抄来的-O-1-龟速乘（？）" class="headerlink" title="抄来的 $O(1)$ 龟速乘（？）"></a>抄来的 $O(1)$ 龟速乘（？）</h3><p><del>抄的 scape 抄的 dls 的</del></p><p>前两个特判是为了避免 $m$ 较小时出错。</p><p>适用于两个 ll 范围内的数相乘模一个 ll 范围内的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> ldb = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">  a %= m, b %= m;</span><br><span class="line">  <span class="keyword">if</span> (m &lt;= <span class="number">1000000000</span>) <span class="keyword">return</span> a * b % m;</span><br><span class="line">  <span class="keyword">if</span> (m &lt;= <span class="number">1000000000000</span>)</span><br><span class="line">    <span class="keyword">return</span> (((a * (b &gt;&gt; <span class="number">20</span>) % m) &lt;&lt; <span class="number">20</span>) + a * (b &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">20</span>) - <span class="number">1</span>))) % m;</span><br><span class="line">  ll d = <span class="built_in">floor</span>(a * (ldb)b / m + <span class="number">0.5</span>);</span><br><span class="line">  ll ans = (a * b - d * m) % m;</span><br><span class="line">  <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += m;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="【模板】Johnson-全源最短路"><a href="#【模板】Johnson-全源最短路" class="headerlink" title="【模板】Johnson 全源最短路"></a><a href="https://www.luogu.com.cn/problem/P5905">【模板】Johnson 全源最短路</a></h3><h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem"></a>problem</h4><p>给定一个有向图，求任意两点间的最短路。</p><p>这个图有以下特点：</p><ul><li>有负权、重边和自环。需要判断有无负环。</li><li>数据范围 floyd 过不去。</li><li>跑 n 次 spfa 会被卡。</li></ul><h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><ol><li>建立一个超级源点 $S$，向每个点 $i$ 连边 $(S, i, 0)$。<ul><li>相当于在 spfa 开始直接将所有点入队。</li></ul></li><li>用 spfa（或 Bellman-Ford）求出求出 $S$ 到其他各点 $i$ 的最短路 $d_i$。判断负环在这一步进行。</li><li>将每条边 $(u, v, w)$ 改为 $(u, v, w + h_u - h_v)$。<ul><li>此时图中不存在负权。</li></ul></li><li>用 $n$ 次 dijkstra 求出任意两点间的最短路。<ul><li>别忘了把真实的边权改回去。若求出的距离为 <code>dis_[u][v]</code>，实际距离为 <code>dis[u][v]</code>，则 <code>dis[u][v] = dis_[u][v] - h[u] + h[v]</code>。</li></ul></li></ol><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><p>有一说一，有点细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">std::bitset&lt;3003&gt; vis;</span><br><span class="line"><span class="keyword">int</span> N, M, tot, cnt[<span class="number">3003</span>], head[<span class="number">3003</span>], dis[<span class="number">3003</span>], d[<span class="number">3003</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nxt, to, w;</span><br><span class="line">&#125; e[<span class="number">6003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w; M; --M) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">spfa</span>()) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i, u = <span class="number">1</span>; u &lt;= N; ++u)</span><br><span class="line">    <span class="keyword">for</span> (i = head[u]; i; i = e[i].nxt)</span><br><span class="line">      e[i].w += d[u] - d[e[i].to];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="built_in">dijkstra</span>(i);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">      <span class="keyword">if</span> (dis[j] == inf) ans += j * <span class="number">1000000000ll</span>;</span><br><span class="line">      <span class="keyword">else</span> ans += <span class="number">1ll</span> * j * (dis[j] - d[i] + d[j]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="【模板】康托展开"><a href="#【模板】康托展开" class="headerlink" title="【模板】康托展开"></a><a href="https://www.luogu.com.cn/problem/P5367">【模板】康托展开</a></h3><h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem"></a>problem</h4><p>给定 $1 \sim N$ 的一个排列 $P$，求它在 $1 \sim N$ 的所有排列中的排名。</p><h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h4><p>从前向后枚举 $P$ 的每个位置。对于第 $i$ 个位置，若它是还未使用的数中第 $j$ 小的，则对答案的贡献为 $(N - i)! \times (j - 1)$。</p><p>由于最终答案要求排名，所以要加 $1$。</p><hr><h3 id="【模板】树上-k-级祖先"><a href="#【模板】树上-k-级祖先" class="headerlink" title="【模板】树上 k 级祖先"></a><a href="https://www.luogu.com.cn/problem/P5903">【模板】树上 k 级祖先</a></h3><p>长链剖分，久仰大名。<del>其实跟重剖也没啥区别</del></p><h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h4><ul><li>预处理，$O(n \log n)$<ol><li>树上倍增求出每个点的 $2^n$ 级祖先。$O(n \log n)$。</li><li>对树进行长剖，对于每个点记录所在链的顶点和深度；对于每条链，若其长度为 $l$，则在其顶点处记录向上的 $l$ 个祖先和向下的 $l$ 个链上的儿子。$O(n)$。<ul><li>可以使用 <code>std::vector</code> 实现。</li><li>也可利用 dfs 序，魔改 <code>dfs</code>，通过两个数组保存。速度当然是要比 <code>vector</code> 快的。</li></ul></li></ol></li><li>询问 $u$ 的 $k$ 级祖先，单次 $O(1)$<ol><li>先利用倍增数组跳到 $u$ 的 $2^{\lfloor \log_2 k \rfloor}$ 级祖先。其中 $\lfloor \log_2 k \rfloor$ 也可 $O(n)$ 预处理出。</li><li>若剩余 $k’$ 级，显然有 $k’ &lt; 2^{\lfloor \log_2 k \rfloor}$。则当前链长 $\ge 2^{\lfloor \log_2 k \rfloor} &gt; k’$。因此可以先跳到此时所在链的顶点。根据剩余 $k$ 的正负，分别用向上、向下的数组求出答案。</li></ol></li></ul><p>总复杂度 $O(n \log n + q)$。</p><h4 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h4><p>这个魔改的邪教 <code>dfs2</code> 传了三个参。注意由于原题性质，这里 dfs 时没有判爹。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; ++i)</span><br><span class="line">    fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">  mxd[u] = dep[u] = dep[fa[u][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="built_in">dfs1</span>(v = e[i].to);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dmax</span>(mxd[u], mxd[v])) son[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> up)</span> </span>&#123;</span><br><span class="line">  top[u] = t;</span><br><span class="line">  dfn[u] = ++dft, D[dft] = u, U[dft] = up;</span><br><span class="line">  <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[u], t, fa[up][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">    <span class="keyword">if</span> ((v = e[i].to) != son[u])</span><br><span class="line">      <span class="built_in">dfs2</span>(v, v, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!k) <span class="keyword">return</span> u;</span><br><span class="line">  u = fa[u][lg[k]];</span><br><span class="line">  k -= (<span class="number">1</span> &lt;&lt; lg[k]) + dep[u] - dep[top[u]];</span><br><span class="line">  u = top[u];</span><br><span class="line">  <span class="keyword">return</span> k &gt;= <span class="number">0</span> ? U[dfn[u] + k] : D[dfn[u] - k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="【模板】无向图三元环计数"><a href="#【模板】无向图三元环计数" class="headerlink" title="【模板】无向图三元环计数"></a><a href="https://www.luogu.com.cn/problem/P1989">【模板】无向图三元环计数</a></h3><h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h4><p>首先给每条边定向：度数小的连向度数大的，度数相等则编号小的连向编号大的。</p><p>枚举每个点、它的出边、它的出边的出边，暴力统计答案。</p><p>复杂度是 $O(m \sqrt m)$ 的<del>，不会证不会证</del>。</p><hr><h3 id="SP10395-ABA12D-Sum-of-divisors"><a href="#SP10395-ABA12D-Sum-of-divisors" class="headerlink" title="SP10395 ABA12D - Sum of divisors!"></a><a href="https://www.luogu.com.cn/problem/SP10395">SP10395 ABA12D - Sum of divisors!</a></h3><p>这题有一些很棒的东西，不过这篇题解的做法中规中矩。</p><p>有时间探索一下那个奇妙的做法。</p><hr><p>46789 51939 54515 49653 48818</p><hr><h3 id="【模板】笛卡尔树"><a href="#【模板】笛卡尔树" class="headerlink" title="【模板】笛卡尔树"></a><a href="https://www.luogu.com.cn/problem/P5854">【模板】笛卡尔树</a></h3><h4 id="problem-5"><a href="#problem-5" class="headerlink" title="problem"></a>problem</h4><p>给定一个 $1 \sim n$ 的排列 $p$，构建一棵二叉树，满足：</p><ol><li>每个结点的编号满足二叉搜索树的性质。</li><li>结点 $i$ 的权值为 $p_i$​，每个结点的权值满足小根堆的性质。</li></ol><h4 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h4><p>这棵二叉树即为这个序列的笛卡尔树。它有以下性质：</p><ol><li>它的中序遍历是原序列。</li><li>任意一个结点的值都大于它的两个儿子的值。</li><li>两个点的 lca 就是他们的 RMQ。</li></ol><p>构造方法：</p><ol><li>维护一个单调栈，按顺序插入每一个元素，每个元素包含<strong>值</strong>和<strong>序号</strong>两个信息。</li><li>每当栈顶元素 $v$ 的值大于当前元素 $u$ 的值，弹出 $v$ 并将其设为 $u$ 的左儿子。否则将 $u$ 设为 $v$ 的右儿子。最后将 $u$ 入栈。</li><li>最终栈顶元素的序号为树根。</li></ol><h4 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h4><p><code>s[]</code> 存储编号，<code>w[]</code> 存储值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= N; ++i) &#123;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (top &amp;&amp; t &lt; w[top]) ls[i] = s[top--];</span><br><span class="line">  <span class="keyword">if</span> (top) rs[s[top]] = i;</span><br><span class="line">  s[++top] = i, w[top] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="【模板】Stoer-Wagner-算法"><a href="#【模板】Stoer-Wagner-算法" class="headerlink" title="【模板】Stoer-Wagner 算法"></a><a href="https://www.luogu.com.cn/problem/P5632">【模板】Stoer-Wagner 算法</a></h3><p><del>什么谔谔玩意，学不会</del></p><hr><h3 id="【模板】Prufer-序列"><a href="#【模板】Prufer-序列" class="headerlink" title="【模板】Prufer 序列"></a><a href="https://www.luogu.com.cn/problem/P6086">【模板】Prufer 序列</a></h3><h4 id="Prufer-序列与带标号无根树的相互转化"><a href="#Prufer-序列与带标号无根树的相互转化" class="headerlink" title="Prufer 序列与带标号无根树的相互转化"></a>Prufer 序列与带标号无根树的相互转化</h4><p>Prufer 序列可以将一个带标号 $n$ 个结点的树用 $[1, n]$ 中的 $n - 2$ 个整数表示。也可以理解为完全图的生成树与数列之间的双射。</p><p>Prufer 是这样建立的：每次选择一个编号最小的叶结点并删掉它，然后在序列中记录下它连接到的那个结点。重复 $n - 2$ 次后就只剩下两个结点，算法结束。</p><p>重建树的方法是类似的。根据 Prufer 序列的性质，我们可以得到原树上每个点的度数。然后你也可以得到度数最小的叶结点编号，而这个结点一定与 Prufer 序列的第一个数连接。然后我们同时删掉这两个结点的度数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123; <span class="comment">// tree -&gt; prufer code</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    cin &gt;&gt; f[i], ++d[f[i]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= N - <span class="number">2</span>; ++i, ++j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (d[j]) ++j;</span><br><span class="line">    <span class="keyword">for</span> (p[i] = f[j]; i &lt;= N - <span class="number">2</span> &amp;&amp; !--d[p[i]] &amp;&amp; p[i] &lt; j; ++i)</span><br><span class="line">      p[i + <span class="number">1</span>] = f[p[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123; <span class="comment">// prufer code -&gt; tree</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">2</span>; ++i)</span><br><span class="line">    cin &gt;&gt; p[i], ++d[p[i]];</span><br><span class="line">  p[N - <span class="number">1</span>] = N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt; N; ++i, ++j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (d[j]) ++j;</span><br><span class="line">    <span class="keyword">for</span> (f[j] = p[i]; i &lt; N &amp;&amp; !--d[p[i]] &amp;&amp; p[i] &lt; j; ++i)</span><br><span class="line">      f[p[i]] = p[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Prufer-序列的性质"><a href="#Prufer-序列的性质" class="headerlink" title="Prufer 序列的性质"></a>Prufer 序列的性质</h4><ol><li>在构造完 Prufer 序列后原树中会剩下两个结点，其中一个一定是编号最大的点 $n$。</li><li>每个结点在序列中出现的次数是其度数减 $1$。（没有出现的就是叶结点）</li><li>通过 Prufer 序列显然有结论：完全图 $K_n$ 有 $n^{n - 2}$ 棵生成树。</li></ol><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://oi-wiki.org/graph/prufer/">Prufer 序列 - OI Wiki</a></li></ul><hr><h3 id="CF156D-Clues"><a href="#CF156D-Clues" class="headerlink" title="CF156D Clues"></a><a href="http://codeforces.com/problemset/problem/156/D">CF156D Clues</a></h3><h4 id="problem-6"><a href="#problem-6" class="headerlink" title="problem"></a>problem</h4><p>一个 $n$ 个点 $m$ 条边的带标号无向图有 $k$ 个连通块。我们希望添加 $k - 1$ 条边使得整个图连通。求方案数。</p><h4 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a>solution</h4><blockquote><p>前置知识：<a href="https://oi-wiki.org/math/combination/#_9">多重组合数</a></p></blockquote><p>设 $s_i(1 \le i \le k)$ 表示第 $i$ 个联通块中的点数。设 $d_i$ 为构造的连通图中第 $i$ 个连通块的度数。显然有 $\sum_{i = 1}^k d_i = 2k - 2$。则对于给定的 $d$ 序列构造 Prufer 序列的方案数是</p><script type="math/tex; mode=display">\binom{k - 2}{d_1 - 1, d_2 - 1, \cdots, d_k - 1} = \frac{(k - 2)!}{\prod_{i = 1}^k (d_i - 1)!}</script><p>对于第 $i$ 个联通块，它对外连接的方式有 $s_i^{d_i}$ 种，因此对于给定 $d$ 序列使图联通的方案数是</p><script type="math/tex; mode=display">\binom{k - 2}{d_1 - 1, d_2 - 1, \cdots, d_k - 1} \times \prod_{i = 1}^k s_i^{d_i}</script><p>然后我们要枚举 $d$ 序列，式子变成</p><script type="math/tex; mode=display">\sum_{d_i \ge 1, \sum_{i = 1}^k d_i = 2k - 2} \binom{k - 2}{d_1 - 1, d_2 - 1, \cdots, d_k - 1} \times \prod_{i = 1}^k s_i^{d_i}</script><blockquote><p>对于处理这个式子，我们有多元二项式定理</p><script type="math/tex; mode=display">(\sum_{i = 1}^m x_i)^p = \sum_{c_i \ge 0, \sum_{i = 1}^m c_i = p} \binom{p}{c_1, c_2, \cdots, c_m} \times \prod_{i = 1}^m x_i^{c_i}</script></blockquote><p>令 $e_i = d_i - 1$，那么显然有 $\sum_{i = 1}^k e_i = k - 2$，于是式子成为</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{e_i \ge 0, \sum_{i = 1}^k e_i = k - 2} \binom{k - 2}{e_1, e_2, \cdots, e_k} \times \prod_{i = 1}^k s_i^{e_i + 1} \\=& (\sum_{i = 1}^k s_i)^{k - 2} \times \prod_{i = 1}^k s_i \\=& n^{k - 2} \times \prod_{i = 1}^k s_i\end{aligned}</script><p>这个式子就很好求了。并查集统计一下即可，可以写成 $O(n \alpha(n))$ 的。</p><h4 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://oi-wiki.org/graph/prufer/">Prufer 序列 - OI Wiki</a></li></ul><hr><h3 id="【模板】EXCRT"><a href="#【模板】EXCRT" class="headerlink" title="【模板】EXCRT"></a><a href="https://www.luogu.com.cn/problem/P4777">【模板】EXCRT</a></h3><h4 id="problem-7"><a href="#problem-7" class="headerlink" title="problem"></a>problem</h4><p>给定 $n$ 组非负整数 $m_i, r_i$，求解关于 $x$ 的方程组的最小非负整数解。</p><p>其中方程组中的第 $i(1 \le i \le n)$ 个方程为</p><script type="math/tex; mode=display">x \equiv r_i \pmod{m_i}</script><h4 id="solution-9"><a href="#solution-9" class="headerlink" title="solution"></a>solution</h4><p>中国剩余定理就是垃圾。</p><p>直接跑 $n$ 次 exgcd 可以在 $O(n \log n)$ 的时间内解决这个问题，并且不要求 $m_i$ 两两互质。</p><h4 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mod</span><span class="params">(ll b, ll m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll b, ll p, ll m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;g, ll &amp;x, ll &amp;y)</span></span>;</span><br><span class="line"></span><br><span class="line">ll N, m[<span class="number">100003</span>], r[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">EXCRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll M = <span class="number">1</span>, ans = <span class="number">0</span>, a, b, c, x, y, g;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    a = M, b = m[i], c = <span class="built_in">Mod</span>(r[i] - ans, b);</span><br><span class="line">    <span class="built_in">exgcd</span>(a, b, g, x, y);</span><br><span class="line">    <span class="comment">// if (c % gcd) return -1;</span></span><br><span class="line">    ans += <span class="built_in">Mul</span>(x, c / g, b / g) * M;</span><br><span class="line">    ans = <span class="built_in">Mod</span>(ans, M *= b / g);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Mod</span>(ans, M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    cin &gt;&gt; m[i] &gt;&gt; r[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, <span class="built_in">EXCRT</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="AT1219-歴史の研究"><a href="#AT1219-歴史の研究" class="headerlink" title="AT1219 歴史の研究"></a><a href="https://www.luogu.com.cn/problem/AT1219">AT1219 歴史の研究</a></h3><p>第一道回滚莫队题目。</p><h4 id="problem-8"><a href="#problem-8" class="headerlink" title="problem"></a>problem</h4><p>给定长为 $n (1 \le n \le 10^5)$ 的序列 $a (1 \le a_i \le 10^9, 1 \le i \le n)$ 和 $q (1 \le q \le 10^5)$ 组询问 $l_i, r_i$。</p><p>每次询问 $\max_{i = l}^r a_i \times t_{a_i}$，其中 $t_x$ 表示 $x$ 在 $a_{l..r}$ 中的出现次数。</p><h4 id="solution-10"><a href="#solution-10" class="headerlink" title="solution"></a>solution</h4><p>不需要支持修改，考虑离线算法。发现统计的区间容易扩展而难以删除，于是考虑回滚莫队：</p><ul><li>预处理，$O(n \log n + q \log q)$<ul><li>序列分块，本题需要离散化，$O(n \log n)$</li><li>对询问进行排序，$O(q \log q)$</li></ul></li><li>莫队，对每个块分别处理左端点在该块内的询问，$O(n \sqrt n)$<ul><li>第 $i$ 个块右端点为 $R_i$，初始设左指针为 $R_i + 1$，右指针为 $R_i$ 表示空区间</li><li>对于 $r$ 在块内的询问（或 $r - l \le \sqrt n$ 的询问），暴力统计</li><li>向右扩展区间直到右指针到达当前询问的 $r$，并记录当前的答案</li><li>采取手段向左扩展，<strong>同时不对向右扩展记录的数据产生影响</strong></li><li>记录该次询问的答案，并采取手段<strong>还原为向左扩展前的状态</strong></li><li>容易想到这样<del>通过牺牲常数</del>做到了 $O(n \sqrt n)$ 的复杂度</li></ul></li></ul><h4 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h4><p>好像写得非常不容易理解，还是看代码吧（</p><p>写的时候注意头脑清醒，同时注意不要滥用 <code>memset</code> 系函数。</p><p>我相信你能看懂自己的变量名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  now = std::<span class="built_in">max</span>(now, <span class="number">1ll</span> * ++c[z[p]] * z_[z[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">    ans = std::<span class="built_in">max</span>(ans, <span class="number">1ll</span> * ++c_[z[i]] * z_[z[i]]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">    --c_[z[i]];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, l, r; i &lt;= num &amp;&amp; j &lt;= M; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(c + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * N);</span><br><span class="line">    r = R[i];</span><br><span class="line">    now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; bel[q[j].l] == i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (q[j].r &lt; r) &#123;</span><br><span class="line">        ans[q[j].id] = <span class="built_in">solve</span>(q[j].l, q[j].r);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      l = R[i] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (r &lt; q[j].r) <span class="built_in">add</span>(++r);</span><br><span class="line">      ll t = now;</span><br><span class="line">      <span class="keyword">while</span> (l &gt; q[j].l) <span class="built_in">add</span>(--l);</span><br><span class="line">      ans[q[j].id] = now, now = t;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= R[i]) --c[z[l++]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="【模板】回滚莫队"><a href="#【模板】回滚莫队" class="headerlink" title="【模板】回滚莫队"></a><a href="https://www.luogu.com.cn/problem/P5906">【模板】回滚莫队</a></h3><p>比上面一道难写多了。写法是自己想的。</p><p>为什么我写数据结构常数这么大啊（哭）</p><h4 id="problem-9"><a href="#problem-9" class="headerlink" title="problem"></a>problem</h4><p>给定长为 $n (1 \le n \le 2 \times 10^5)$ 的序列 $a (1 \le a_i \le 2 \times 10^9, 1 \le i \le n)$ 和 $q (1 \le q \le 2 \times 10^5)$ 组询问 $l_i, r_i$。</p><p>每次询问 $a_{l..r}$ 中相同的数的最大下标差。</p><h4 id="code-7"><a href="#code-7" class="headerlink" title="code"></a>code</h4><p>没啥好说的，看你自己的代码吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addR</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">dmax</span>(mx[z[p]], p);</span><br><span class="line">  <span class="built_in">dmin</span>(mn[z[p]], p);</span><br><span class="line">  <span class="built_in">dmax</span>(now, mx[z[p]] - mn[z[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addL</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">dmax</span>(mx_[z[p]], mx[z[p]]);</span><br><span class="line">  <span class="built_in">dmax</span>(mx_[z[p]], p);</span><br><span class="line">  <span class="built_in">dmin</span>(mn_[z[p]], mn[z[p]]);</span><br><span class="line">  <span class="built_in">dmin</span>(mn_[z[p]], p);</span><br><span class="line">  <span class="built_in">dmax</span>(now, mx_[z[p]] - mn_[z[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">delL</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  mx_[z[p]] = <span class="number">0</span>;</span><br><span class="line">  mn_[z[p]] = inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="built_in">dmax</span>(mx_[z[i]], i);</span><br><span class="line">    <span class="built_in">dmin</span>(mn_[z[i]], i);</span><br><span class="line">    <span class="built_in">dmax</span>(ans, mx_[z[i]] - mn_[z[i]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">    mx_[z[i]] = <span class="number">0</span>, mn_[z[i]] = inf;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(mn_ + <span class="number">1</span>, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, t, l, r; i &lt;= num &amp;&amp; j &lt;= M; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(mx + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * N);</span><br><span class="line">    <span class="built_in">memset</span>(mn + <span class="number">1</span>, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * N);</span><br><span class="line">    r = R[i];</span><br><span class="line">    now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; bel[q[j].l] == i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (q[j].r &lt; r) &#123;</span><br><span class="line">        ans[q[j].id] = <span class="built_in">solve</span>(q[j].l, q[j].r);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      l = R[i] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (r &lt; q[j].r) <span class="built_in">addR</span>(++r);</span><br><span class="line">      t = now;</span><br><span class="line">      <span class="keyword">while</span> (l &gt; q[j].l) <span class="built_in">addL</span>(--l);</span><br><span class="line">      ans[q[j].id] = now, now = t;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= R[i]) <span class="built_in">delL</span>(l++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="CF1285D-Dr-Evil-Underscores"><a href="#CF1285D-Dr-Evil-Underscores" class="headerlink" title="CF1285D Dr. Evil Underscores"></a><a href="http://codeforces.com/problemset/problem/1285/D">CF1285D Dr. Evil Underscores</a></h3><h4 id="problem-10"><a href="#problem-10" class="headerlink" title="problem"></a>problem</h4><p>给出 $n (1 \le n \le 10^5)$ 个数 $a_i (0 \le a_i \le 2^{30} - 1)$，找到 $x$ 使得 $\max_{i = 1}^n a_i \oplus x$ 最小。求出这个最小值。</p><h4 id="solution-11"><a href="#solution-11" class="headerlink" title="solution"></a>solution</h4><p><del>动脑子会以为是二分，但这显然就是 Trie 大水题</del></p><p>建出 01-Trie，在 Trie 上 dfs（树形 dp）：</p><ul><li>设当前结点为 $u$，在数字从低到高第 $c$ 位</li><li>令 $s$ 为递归处理 $\mathrm{nxt}_{u, 0}$ 与 $\mathrm{nxt}_{u, 1}$ 返回答案的较小值。</li><li>若 $u$ 的两个儿子都存在，则答案为 $s + 2^c$，否则答案为 $s$。</li></ul><p>代码很丑，就不放了。</p><hr><h3 id="AGC004C-AND-Grid"><a href="#AGC004C-AND-Grid" class="headerlink" title="AGC004C AND Grid"></a><a href="https://agc004.contest.atcoder.jp/tasks/agc004_c#">AGC004C AND Grid</a></h3><h4 id="problem-11"><a href="#problem-11" class="headerlink" title="problem"></a>problem</h4><p>给定一个网格图，有些位置已经被涂色。要求构造两个相同大小的网格图，并且在上面涂色，需要保证颜色四连通，且满足这两个网格的涂色部分的重合位置恰好是给定的网格图的涂色位置。题目保证边界上不会被涂色。</p><h4 id="solution-12"><a href="#solution-12" class="headerlink" title="solution"></a>solution</h4><p>维护两个网格图，都初始化为原网格图。将第一个网格图的第一列和奇数行（除最后一列）全部染色；第二个网格图的最后一列和偶数行（除第一列）全部染色。</p><p>容易想到这样是对的。</p><hr><h3 id="数列分块入门-9"><a href="#数列分块入门-9" class="headerlink" title="数列分块入门 9"></a><a href="https://loj.ac/problem/6285">数列分块入门 9</a></h3><p>🐴的，没想到我一直咕掉的数列分块 9 是回滚莫队板子（</p><hr><h3 id="CF576C-Points-on-Plane"><a href="#CF576C-Points-on-Plane" class="headerlink" title="CF576C Points on Plane"></a><a href="http://codeforces.com/problemset/problem/576/C">CF576C Points on Plane</a></h3><h4 id="problem-12"><a href="#problem-12" class="headerlink" title="problem"></a>problem</h4><p>给出 $n (1 \le n \le 10^6)$ 个点 $(x_i, y_i) (0 \le x_i, y_i \le 10^6)$，求一个排列 $p$，使得 $\sum_{i = 2}^n |x_{p_i} - x_{p_{i - 1}}| + |y_{p_i} - y_{p_{i - 1}}| \le 2.5 \times 10^9$。</p><h4 id="solution-13"><a href="#solution-13" class="headerlink" title="solution"></a>solution</h4><p>依据莫队的分块思想进行排序，算一下会发现这样最多会跳 $3 \times 10^9$。加一个奇偶排序，最多就成了 $2 \times 10^9$，很稳。</p><hr><h3 id="CF679A-Bear-and-Prime-100"><a href="#CF679A-Bear-and-Prime-100" class="headerlink" title="CF679A Bear and Prime 100"></a><a href="http://codeforces.com/problemset/problem/679/A">CF679A Bear and Prime 100</a></h3><p>大水题，没啥好说的。这是我的第一道交互题。</p><hr><h3 id="CF727C-Guess-the-Array"><a href="#CF727C-Guess-the-Array" class="headerlink" title="CF727C Guess the Array"></a><a href="http://codeforces.com/problemset/problem/727/C">CF727C Guess the Array</a></h3><p>一眼秒。从这题知道了可以一次输出进行多次询问（只需在最后 flush 一次），也可将多次询问的回答一起读入。可以关同步。可以 <code>::tie</code>。</p><hr><h3 id="CF730B-Minimum-and-Maximum"><a href="#CF730B-Minimum-and-Maximum" class="headerlink" title="CF730B Minimum and Maximum"></a><a href="http://codeforces.com/problemset/problem/730/B">CF730B Minimum and Maximum</a></h3><h4 id="problem-13"><a href="#problem-13" class="headerlink" title="problem"></a>problem</h4><p>这是一道交互题。输入有 $T (1 \le T \le 1000)$ 组数据。</p><p>有一个长度为 $n (1 \le n \le 50)$ 的序列，你需要求出最小数和最大数的编号。每次可以询问序列中两个数的相对大小，最多可以询问 $\lceil \frac{3n}{2} \rceil - 2$ 次。</p><h4 id="solution-14"><a href="#solution-14" class="headerlink" title="solution"></a>solution</h4><p>朴素的想法是把序列 $O(n)$ 地扫一遍。这样的比较次数是 $2n - 2$，会超过限制。优化很简单：每次取相邻的两个元素比较大小，再分别将较大者与当前的最大值比较；将较小者与当前的最小值比较。这样将原先 $4$ 次的询问优化成了 $3$ 次，恰好符合要求。</p><h4 id="code-8"><a href="#code-8" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;?&#x27;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; u &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">  cin &gt;&gt; c;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T, N, mx, mn;</span><br><span class="line">  <span class="keyword">for</span> (cin &gt;&gt; T; T; --T) &#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">if</span> (N &amp; <span class="number">1</span>) mx = mn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ask</span>(<span class="number">1</span>, <span class="number">2</span>) == <span class="string">&#x27;&lt;&#x27;</span>) mn = <span class="number">1</span>, mx = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">else</span> mn = <span class="number">2</span>, mx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span> - (N &amp; <span class="number">1</span>), u, v; i &lt;= N; i += <span class="number">2</span>) &#123;</span><br><span class="line">      u = i, v = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ask</span>(u, v) == <span class="string">&#x27;&gt;&#x27;</span>) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ask</span>(u, mn) == <span class="string">&#x27;&lt;&#x27;</span>) mn = u;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ask</span>(v, mx) == <span class="string">&#x27;&gt;&#x27;</span>) mx = v;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;!&#x27;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mn &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="CF750F-New-Year-and-Finding-Roots"><a href="#CF750F-New-Year-and-Finding-Roots" class="headerlink" title="CF750F New Year and Finding Roots"></a><a href="http://codeforces.com/problemset/problem/750/F">CF750F New Year and Finding Roots</a></h3><p>一上午没做出来，我是傻逼。</p><hr><h3 id="CF896B-Ithea-Plays-With-Chtholly"><a href="#CF896B-Ithea-Plays-With-Chtholly" class="headerlink" title="CF896B Ithea Plays With Chtholly"></a><a href="http://codeforces.com/problemset/problem/896/B">CF896B Ithea Plays With Chtholly</a></h3><p>我觉得这题翻译⑧太对劲，所以我不会做，也想不到题解为啥是对的（</p><hr><h3 id="P2153-SDOI2009-晨跑"><a href="#P2153-SDOI2009-晨跑" class="headerlink" title="P2153 [SDOI2009]晨跑"></a><a href="https://www.luogu.com.cn/problem/P2153">P2153 [SDOI2009]晨跑</a></h3><h4 id="problem-14"><a href="#problem-14" class="headerlink" title="problem"></a>problem</h4><p>有一个 $N$ 个点 $M$ 条边的有向图。找出若干条 $1 \sim N$ 的互不相交路径，使得这些路径条数尽量多且总长度尽量短。s</p><h4 id="solution-15"><a href="#solution-15" class="headerlink" title="solution"></a>solution</h4><p><del>有限制条件的最短路，显然是网络流。</del>对于每个点只能经过一次的限制条件，通过拆点解决。</p><p>对每个点拆点 $i, i’$，连边 $(i, i’, 1, 0)$；对于原图中的边 $(u, v, w)$，连边 $(u, v, 1, w)$，超级源、汇分别为 $1’, N$，跑最小费用最大流即可。</p><hr><h3 id="复习专题"><a href="#复习专题" class="headerlink" title="复习专题"></a>复习专题</h3><p>这部分是 fa_555 的复习。不对外公布。</p><p>见 <code>_workspace\review\</code> 目录下 <code>Treap.cpp</code>, <code>FHQ-Treap.cpp</code>, <code>FHQ-Treap2.cpp</code>, <code>Splay.cpp</code>, <code>Miller_Rabin.cpp</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 Jan Records</title>
      <link href="/2020/2020-Jan-Records/"/>
      <url>/2020/2020-Jan-Records/</url>
      
        <content type="html"><![CDATA[<p>菜鸡 fa_555 会把一些动态简要地记在这里。主要还是留给自己以后看的。</p><span id="more"></span><p><em>所有代码不保证包括无关紧要的部分</em></p><hr><h3 id="非-OI"><a href="#非-OI" class="headerlink" title="非 OI"></a>非 OI</h3><p>一月的前半段一直在准备期末考试。期末考得<strong>很烂</strong>。</p><p>15 号来了 qbxt。</p><hr><h3 id="CF325D-Reclamation"><a href="#CF325D-Reclamation" class="headerlink" title="CF325D Reclamation"></a><a href="http://codeforces.com/problemset/problem/325/D">CF325D Reclamation</a></h3><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><p>给定一个 $N \times M$ 的<strong>环形</strong>网格图（圆柱的侧面）。</p><p>按顺序给出 $K$ 次操作，第 $i$ 次操作会选中一个格子 $(x_i, y_i)$。如果把这个格子变成障碍后，圆柱的顶面和底面依然相连通，那么把这个格变成障碍。</p><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>考虑环形，把网格横向复制。用并查集维护。如果两部分中对应的点在同一个集合中，则操作不能执行。</p><p>由于 DSU 需要支持撤销，路径压缩失去了正确性。为了保证复杂度正确，按秩合并是必须的。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>由于太长时间没写代码，sb fa_555 这题写挂了好多地方。</p><ul><li><p>按秩合并，集合大小要初始化！</p></li><li><p><code>std::bitset</code> 的两维不要开反！</p></li></ul><p><del>这份代码也是抄的 cf 上外国友人的</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct IO &#123; ... &#125; cin, cout; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">std::bitset&lt;6003&gt; vis[<span class="number">3003</span>];</span><br><span class="line"><span class="comment">// bitset 两维大小开反真是草了（</span></span><br><span class="line"><span class="keyword">int</span> N, M, K, ans, top, U[<span class="number">19</span>], V[<span class="number">19</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line"><span class="comment">// 这个 DSU 需要支持撤销，不能路径压缩！</span></span><br><span class="line"><span class="comment">// 为了复杂度正确，需要按秩合并</span></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">18000003</span>], siz[<span class="number">18000003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span>; <span class="comment">// 无路径压缩</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">  <span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (siz[u] &gt; siz[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">  fa[u] = v, siz[v] += siz[u];</span><br><span class="line">  U[++top] = u, V[top] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// DSU</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DSU;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (M * (x - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  vis[x].<span class="built_in">set</span>(y);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, p = <span class="built_in">pos</span>(x, y), nx, ny; k &lt; <span class="number">8</span>; ++k) &#123;</span><br><span class="line">    nx = x + dx[k], ny = y + dy[k];</span><br><span class="line">    <span class="keyword">if</span> (nx &lt; <span class="number">1</span> || nx &gt; N) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (ny &lt; <span class="number">1</span>) ny = M &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ny &gt; M &lt;&lt; <span class="number">1</span>) ny = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (vis[nx][ny]) <span class="built_in">merge</span>(p, <span class="built_in">pos</span>(nx, ny));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N * M &lt;&lt; <span class="number">1</span>; ++i)</span><br><span class="line">    fa[i] = i, siz[i] = <span class="number">1</span>; <span class="comment">// 初始化！</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x, y; K; --K) &#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">mark</span>(x, y), <span class="built_in">mark</span>(x, y + M);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(<span class="built_in">pos</span>(x, y)) == <span class="built_in">find</span>(<span class="built_in">pos</span>(x, y + M))) &#123;</span><br><span class="line">      vis[x].<span class="built_in">reset</span>(y), vis[x].<span class="built_in">reset</span>(y + M);</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        siz[V[top]] -= siz[U[top]];</span><br><span class="line">        fa[U[top]] = U[top];</span><br><span class="line">      &#125; <span class="keyword">while</span> (--top);</span><br><span class="line">    &#125; <span class="keyword">else</span> ++ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="P1456-Monkey-King"><a href="#P1456-Monkey-King" class="headerlink" title="P1456 Monkey King"></a><a href="https://www.luogu.com.cn/problem/P1456">P1456 Monkey King</a></h3><p>用来唤醒记忆的左偏树例题。</p><h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h4><p>有 $N$ 只猴子，初始时他们两两不认识，且第 $i$ 只猴子有 $a_i$ 的战斗力。有 $M$ 个事件会发生，在第 $i$ 个事件中，$x_i, y_i$ 两只猴子会各自叫上他们认识的猴子里战斗力最高的打一架。一架之后，两只战斗里最高的猴子的战斗力会各减小一半（向下取整）并互相认识 <em><del>不打不相识嘛</del></em>。认识关系具有传递性。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>支持找爹、查询最大值、修改和合并，<del>一看就</del>是左偏树！</p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><p>直接看代码吧。好好看看板子和修改的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct IO &#123; ... &#125; cin, cout; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> iarrN = <span class="keyword">int</span>[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">iarrN fa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span>; <span class="comment">// 有路径压缩</span></span><br><span class="line">&#125; <span class="comment">// DSU</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DSU;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LTT &#123;</span><br><span class="line">iarrN ls, rs, dis, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p + q;</span><br><span class="line">  <span class="keyword">if</span> (s[p] &lt; s[q])</span><br><span class="line">    std::<span class="built_in">swap</span>(p, q);</span><br><span class="line">  rs[p] = <span class="built_in">merge</span>(rs[p], q);</span><br><span class="line">  fa[rs[p]] = p;</span><br><span class="line">  <span class="keyword">if</span> (dis[ls[p]] &lt; dis[rs[p]])</span><br><span class="line">    std::<span class="built_in">swap</span>(ls[p], rs[p]);</span><br><span class="line">  dis[p] = dis[rs[p]] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reduce</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// reduce the value of $p by half</span></span><br><span class="line">  s[p] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> t = <span class="built_in">merge</span>(ls[p], rs[p]);</span><br><span class="line">  ls[p] = rs[p] = dis[p] = <span class="number">0</span>;</span><br><span class="line">  fa[t] = fa[p] = <span class="built_in">merge</span>(t, p);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// LTT</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LTT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N) != EOF) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">      ls[i] = rs[i] = dis[i] = <span class="number">0</span>;</span><br><span class="line">      fa[i] = i;</span><br><span class="line">      cin &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v; M; --M) &#123;</span><br><span class="line">      cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">      u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">      <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="string">&#x27;1&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">reduce</span>(u), <span class="built_in">reduce</span>(v);</span><br><span class="line">      fa[fa[u]] = fa[fa[v]] = <span class="built_in">merge</span>(fa[u], fa[v]);</span><br><span class="line">      cout &lt;&lt; s[<span class="built_in">find</span>(u)] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="UVA11419-SAM-I-AM"><a href="#UVA11419-SAM-I-AM" class="headerlink" title="UVA11419 SAM I AM"></a><a href="https://www.luogu.com.cn/problem/UVA11419">UVA11419 SAM I AM</a></h3><p><em>由于 UVa 在国内网络环境速度过于难受，链接用了谷</em></p><h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h4><p>$N \times M$ 的网格图，$K$ 个点 $(x_i, y_i)$ 中有障碍。一颗炮弹可以摧毁一整行/一整列的障碍。求至少几颗炮弹可以摧毁所有的障碍。</p><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>二分图裸题，不过我只想写网络流。对于点 $(x, y)$，连边 $(S, x_L, 1), (x_L, y_R, \mathrm{inf}), (y_R, T, 1)$，答案即为最小点覆盖（最大流）。</p><p>难的是<strong>输出方案</strong>。我们发现，对于 左侧所有入边满流的点 与 与左侧不满流的点相连的右侧的点 需要计入答案。</p><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><p>用了题解的一个小 trick：只建需要的边。此外，<code>memset</code> 和 <code>memcpy</code> 直接算了内存大小，不建议像我一样 <code>&lt;&lt; 2</code>，至少也要 <code>* sizeof(int)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct IO &#123; ... &#125; cin; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> iarrN = <span class="keyword">int</span>[<span class="number">2013</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">std::bitset&lt;2013&gt; ex, vis;</span><br><span class="line"><span class="keyword">int</span> N, M, K, S, T, tot;</span><br><span class="line">iarrN cur, dep, head;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nxt, to, w;</span><br><span class="line">&#125; e[<span class="number">6000003</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _aE(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  tot = <span class="number">1</span>, S = <span class="number">0</span>, T = N + M + <span class="number">1</span>;</span><br><span class="line">  ex.<span class="built_in">reset</span>(), vis.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">0</span>, (N + M + <span class="number">2</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= K; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">addEdge</span>(x, y + N, inf);</span><br><span class="line">    <span class="keyword">if</span> (!ex[x]) <span class="built_in">addEdge</span>(S, x, <span class="number">1</span>), ex.<span class="built_in">set</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (!ex[y + N]) <span class="built_in">addEdge</span>(y + N, T, <span class="number">1</span>), ex.<span class="built_in">set</span>(y + N);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dinic: returns maxflow */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="comment">// dfs</span></span><br><span class="line">  vis.<span class="built_in">set</span>(u);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt)</span><br><span class="line">    <span class="keyword">if</span> (e[i].w &amp;&amp; !vis[e[i].to])</span><br><span class="line">      <span class="built_in">mark</span>(e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; N &gt;&gt; M &gt;&gt; K, N) &#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">dinic</span>(S, T);</span><br><span class="line">    <span class="built_in">mark</span>(S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">      <span class="keyword">if</span> (ex[i] &amp;&amp; !vis[i])</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; r&quot;</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N + <span class="number">1</span>; i &lt;= N + M; ++i)</span><br><span class="line">      <span class="keyword">if</span> (ex[i] &amp;&amp; vis[i])</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; c&quot;</span> &lt;&lt; i - N;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="FJOI2007-轮状病毒"><a href="#FJOI2007-轮状病毒" class="headerlink" title="[FJOI2007]轮状病毒"></a><a href="https://www.luogu.com.cn/problem/P2144">[FJOI2007]轮状病毒</a></h3><p><del>做道应景的题</del></p><h4 id="solution-Luogu-WJiannan"><a href="#solution-Luogu-WJiannan" class="headerlink" title="solution (Luogu @WJiannan)"></a><a href="https://steaunk.blog.luogu.org/solution-p2144">solution (Luogu @WJiannan)</a></h4><p>抄了题解还没看懂/kk，复读一遍吧。</p><blockquote><p>考虑把先不管中心点，然后把外围的 $n$ 个点拆环成链，暂时强制第一个点不能和最后一个点连边。</p><p>于是方案数就类似一个整数拆分，将外围的点分成若干个联通块，</p><p>即设 $f_i$ 为当前已经分配了前 $i$ 个点的方案数，$f_i = \sum_{j=1}^{i} f_{i-j} \times j$（因为每加入一个联通块，中心点都可以向其中的任意一个点连边）。</p><p>但是我们还需要考虑上第一个点与最后一个点连边的情况，发现，如果分配第一个联通块大小为 $x$，那么我们可以把这张图逆时针旋转，则总共有 $x$ 种不同的方案。</p><p>于是答案的计算方式就等于</p><script type="math/tex; mode=display">f_i = \sum_{j = 1}^{i - 1} f_{i - j} \times j + f_0 \times i^2</script></blockquote><p>高精度视为 $O(1)$，总复杂度 $O(n^2)$。</p><h4 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h4><p>高精度写得奇丑无比，不放了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct BigInteger &#123; ... &#125; f[103]; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; N;</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">    f[j] = f[j] + f[<span class="number">0</span>] * (j * j);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i + j &lt;= N; ++j)</span><br><span class="line">      f[i + j] = f[i + j] + f[i] * j;</span><br><span class="line">  std::cout &lt;&lt; f[N];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="APIO2012-派遣"><a href="#APIO2012-派遣" class="headerlink" title="[APIO2012]派遣"></a><a href="https://www.luogu.com.cn/problem/P1552">[APIO2012]派遣</a></h3><h4 id="solution-Luogu-amazingOZR"><a href="#solution-Luogu-amazingOZR" class="headerlink" title="solution (Luogu @amazingOZR)"></a><a href="https://www.luogu.com.cn/blog/user13180/solution-p1552">solution (Luogu @amazingOZR)</a></h4><p>自己没想出来。贴一下抄的题解，顺便修一下格式。</p><p>明显领导关系形成一棵树，则答案为 $ans = max \{L_u \times k \}$，其中 $k$ 代表以 $u$ 为根的子树中选出的节点数个数（设这些节点为 $v_1, v_2, \cdots, v_k$）且有 $\sum_{i = 1}^{k} C_{v_i} \leq M$。</p><p>所以以每个节点建一个大根堆，维护薪水值。初始时若自己满足条件就选自己，否则不选。从叶子节点往上推，对于每个节点，将它与它的儿子节点合并。如果当前的选择费用超出了 $M$，就弹出堆里最大的，一直到不超过 $M$ 为止。动态维护当前选择的节点数 <code>num</code> 和选择费用 <code>sum</code> 即可。</p><p>总复杂度 $O(n \log n)$（不大会证 /wq）。</p><h4 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h4><p>学会做法，代码倒是挺简单<del>，也是抄的题解。不过自己去了去糟粕</del>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct IO &#123; ... &#125; cin; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> iarrN = <span class="keyword">int</span>[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, tot;</span><br><span class="line">iarrN head, L;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125; e[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LTT &#123;</span><br><span class="line">iarrN rt, ls, rs, dis, s, cnt, sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p + q;</span><br><span class="line">  <span class="keyword">if</span> (s[p] &lt; s[q]) std::<span class="built_in">swap</span>(p, q);</span><br><span class="line">  rs[p] = <span class="built_in">merge</span>(rs[p], q);</span><br><span class="line">  <span class="keyword">if</span> (dis[ls[p]] &lt; dis[rs[p]])</span><br><span class="line">    std::<span class="built_in">swap</span>(ls[p], rs[p]);</span><br><span class="line">  dis[p] = dis[rs[p]] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// LTT</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LTT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u; i &lt;= N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; s[i] &gt;&gt; L[i];</span><br><span class="line">    <span class="built_in">addEdge</span>(u, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i, u = N, v; u; --u) &#123;</span><br><span class="line">    rt[u] = u, cnt[u] = <span class="number">1</span>;</span><br><span class="line">    sum[u] = s[u];</span><br><span class="line">    <span class="keyword">for</span> (i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">      rt[u] = <span class="built_in">merge</span>(rt[u], rt[v = e[i].to]);</span><br><span class="line">      sum[u] += sum[v], cnt[u] += cnt[v];</span><br><span class="line">      <span class="keyword">while</span> (sum[u] &gt; M) &#123;</span><br><span class="line">        sum[u] -= s[rt[u]], --cnt[u];</span><br><span class="line">        rt[u] = <span class="built_in">merge</span>(ls[rt[u]], rs[rt[u]]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = std::<span class="built_in">max</span>(ans, <span class="number">1ll</span> * L[u] * cnt[u]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="JSOI2010-满汉全席"><a href="#JSOI2010-满汉全席" class="headerlink" title="[JSOI2010]满汉全席"></a><a href="https://www.luogu.com.cn/problem/P4171">[JSOI2010]满汉全席</a></h3><p>2-SAT 模板题。</p><h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>把每种材料拆成两个点。</p><p>每组的两个限制都是<strong>或</strong>的形式：如果不满足其中一个限制，则必须满足另外一个限制。</p><p>最后检验一下每种材料的两个点是否<strong>不在</strong>同一个 SCC 内（合法）。</p><p>总复杂度 $O(Tn)$，$T$ 为数据组数。</p><h4 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h4><p>主要看看 tarjan。</p><p>把每种材料 <code>i</code> 拆成两个点：<code>i &lt;&lt; 1</code> 代表 <code>i</code> 的满式做法，<code>i &lt;&lt; 1 | 1</code> 代表 <code>i</code> 的汉式做法，最终结点的值域为 <code>[2, N &lt;&lt; 1 | 1]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct IO &#123; ... &#125; cin; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dmin</span><span class="params">(<span class="keyword">int</span> &amp;m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; m) m = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> iarr2N = <span class="keyword">int</span>[<span class="number">203</span>];</span><br><span class="line"></span><br><span class="line">std::bitset&lt;203&gt; vis;</span><br><span class="line"><span class="keyword">int</span> T, N, M, tot, top, dft, cntSCC;</span><br><span class="line">iarr2N head, s, dfn, low, bel;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125; e[<span class="number">2003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cntSCC = tot = dft = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="keyword">char</span> u_, v_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u, v; M; --M) &#123;</span><br><span class="line">    <span class="comment">// 这个建图可以看一下嗷</span></span><br><span class="line">    cin &gt;&gt; u_ &gt;&gt; u &gt;&gt; v_ &gt;&gt; v;</span><br><span class="line">    u &lt;&lt;= <span class="number">1</span>, v &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">addEdge</span>(u | (u_ == <span class="string">&#x27;m&#x27;</span>), v | (v_ == <span class="string">&#x27;h&#x27;</span>));</span><br><span class="line">    <span class="built_in">addEdge</span>(v | (v_ == <span class="string">&#x27;m&#x27;</span>), u | (u_ == <span class="string">&#x27;h&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (cin &gt;&gt; T; T; --T) &#123;</span><br><span class="line">    <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= (N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); ++i)</span><br><span class="line">      <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">      <span class="keyword">if</span> (bel[i &lt;&lt; <span class="number">1</span>] == bel[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) &#123;</span><br><span class="line">        f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    std::cout &lt;&lt; (f ? <span class="string">&quot;BAD&quot;</span> : <span class="string">&quot;GOOD&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="POJ2976-Dropping-tests"><a href="#POJ2976-Dropping-tests" class="headerlink" title="POJ2976 Dropping tests"></a><a href="http://poj.org/problem?id=2976">POJ2976 Dropping tests</a></h3><p>01 分数规划模板题。</p><p>没届到这个算法跟名字有什么关系，甚至也没届到这是个什么算法（</p><h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem"></a>problem</h4><p>给出 $n$ 组 $a, b$，选出其中 $n - k$ 组，使得 $\frac{\sum a}{\sum b}$ 最大。</p><h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h4><p>题目要求 $\frac{\sum a}{\sum b} \ge x$，即 $\sum (a - x b) \ge 0$ 中 $x$ 的最大值。</p><p>二分 $x$，把 $a_i - x b_i$ 排序，判断最大的 $n - k$ 的和是否大于等于 0 即可。</p><p>总复杂度 $O(n \log r)$，$r$ 为答案值域大小。</p><p>代码过丑，不放了。</p><hr><h3 id="P1642-规划"><a href="#P1642-规划" class="headerlink" title="P1642 规划"></a><a href="https://www.luogu.com.cn/problem/P1642">P1642 规划</a></h3><p>01 分数规划模板题。</p><h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem"></a>problem</h4><p>$N$ 个结点的树，每个结点 $i$ 有两个值 $a_i, b_i$，删去其中 $K$ 个结点，使得剩余结点的 $\frac{\sum a_i}{\sum b_i}$ 最大。</p><h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h4><p>首先把<em>删除 $K$ 个点</em>转化为<em>留下 $N - K$ 个点</em>，<del>那它长得就跟个 01 分数规划似的。</del>考虑二分这个最大值，可以通过一次树形 dp <code>check</code>。</p><p>设 <code>f[u][i]</code> 为以 <code>u</code> 为根的子树中<strong>有一个包含 <code>u</code> 且 <code>siz = i</code> 的连通块</strong>时的最大值。那么转移方程为</p><script type="math/tex; mode=display">f_{u, i} = \max\{f_{u, i - j} + f_{v, j}\}</script><p>实现起来有些细节要注意。</p><h4 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct IO &#123; ... &#125; cin; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> iarrN = <span class="keyword">int</span>[<span class="number">103</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, tot;</span><br><span class="line">iarrN head, siz, a, b;</span><br><span class="line"><span class="keyword">double</span> t[<span class="number">103</span>], f[<span class="number">103</span>][<span class="number">103</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125; e[<span class="number">203</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  f[u][<span class="number">0</span>] = <span class="number">0</span>, siz[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((v = e[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    siz[u] += siz[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = std::<span class="built_in">min</span>(siz[u], K); j; --j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= std::<span class="built_in">min</span>(siz[v], j); ++k)</span><br><span class="line">        f[u][j] = std::<span class="built_in">max</span>(f[u][j], f[u][j - k] + f[v][k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">min</span>(siz[u], K); i; --i)</span><br><span class="line">    f[u][i] = f[u][i - <span class="number">1</span>] + t[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    t[i] = a[i] - mid * b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j)</span><br><span class="line">      f[i][j] = -inf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (f[i][K] &gt; -eps) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">  K = N - K;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    cin &gt;&gt; b[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="built_in">addEdge</span>(u, v), <span class="built_in">addEdge</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">double</span> mid; r - l &gt; eps; ) &#123;</span><br><span class="line">    mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="P3709-大爷的字符串题"><a href="#P3709-大爷的字符串题" class="headerlink" title="P3709 大爷的字符串题"></a><a href="https://www.luogu.com.cn/problem/P3709">P3709 大爷的字符串题</a></h3><blockquote><p>这个题充分考察了大家的语文水平</p><p>可以发现这个乱七八糟的题面，本质是每次从区间中取出一个严格上升的序列，然后问最少取几次</p><p>由于是严格上升，所以只和相同的数个数有关，即要用区间出现次数最大的那个数出现次数那么多次</p><p>从上句话可以看出这出题人语文没救</p><p>即要求区间众数</p></blockquote><p>我觉得也就 lxl 这样的人才能写出这么难读的题面和题解<del>，所以我不在这放题面了，你复习的时候自己读去</del>。</p><h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h4><p>题面翻译成人话：给出一个序列，选定若干个区间，<strong>每次从中取出一个单调增序列，求最少几次取完</strong>。</p><p>加粗部分可以转化为：<strong>求该区间的众数的出现次数</strong>，即<strong>区间内所有数出现次数的最大值</strong>。</p><p>这样这个题就没啥难度了。</p><h4 id="code-7"><a href="#code-7" class="headerlink" title="code"></a>code</h4><p>放一放 <code>add</code> 和 <code>del</code> 函数的部分。可读性很低。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  --t[cnt[z[p]]];</span><br><span class="line">  <span class="keyword">if</span> (cnt[z[p]] == now) ++now;</span><br><span class="line">  ++t[++cnt[z[p]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!--t[cnt[z[p]]] &amp;&amp; cnt[z[p]] == now) --now;</span><br><span class="line">  ++t[--cnt[z[p]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="HNOI2009-最小圈"><a href="#HNOI2009-最小圈" class="headerlink" title="[HNOI2009]最小圈"></a><a href="https://www.luogu.com.cn/problem/P3199">[HNOI2009]最小圈</a></h3><p>题意真难读。</p><h4 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h4><p>要求求图中所有环上边权的平均值的最小值，即求 $\min\{ \frac{\sum_{i = 1}^{k} w_i}k\}$，其中 $k$ 为环的边数。</p><p>设 $\mathrm{ans}$ 为这个最小值。则 $\sum_{i = 1}^k (w_i - \mathrm{ans}) = 0$。二分这个最小值，判断新图有无负环即可。</p><hr><h3 id="SCOI2014-方伯伯运椰子"><a href="#SCOI2014-方伯伯运椰子" class="headerlink" title="[SCOI2014]方伯伯运椰子"></a><a href="https://www.luogu.com.cn/problem/P3288">[SCOI2014]方伯伯运椰子</a></h3><p>没看懂<strong>，你个懒熊回来复习的时候记得补上</strong></p><hr><p>一月结束了。</p>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019 Dec Records</title>
      <link href="/2019/2019-Dec-Records/"/>
      <url>/2019/2019-Dec-Records/</url>
      
        <content type="html"><![CDATA[<p>菜鸡 fa_555 会把一些动态简要地记在这里。主要还是留给自己以后看的。</p><span id="more"></span><p><em>所有代码不保证包括无关紧要的部分</em></p><hr><h3 id="P1131-ZJOI2007-时态同步"><a href="#P1131-ZJOI2007-时态同步" class="headerlink" title="P1131 [ZJOI2007]时态同步"></a>P1131 [ZJOI2007]时态同步</h3><p>由于我不会 dp，机房神仙考前强推给我的<del>，但我现在才来做</del>。</p><p>题目描述很长很唬人，但实际非常水，一眼切，就算切不掉也能看一眼代码就能完全明白的那种。</p><p>实现起来可以用一些小优化减小常数。</p><p><strong>【已解决】</strong>但是有一个大问题：为什么快读的 <code>buf[]</code> 数组开 <code>1&lt;&lt;20|1</code> 就会 RE 一个点，<code>1&lt;&lt;24|1</code> 就不会？害怕自己快读出锅了/kk</p><p><strong>破案，快读的三目忘了加 <code>p1 == p2</code></strong><del>，我是 sb</del></p><hr><h3 id="在-c-11-中使用-using-而非-typedef"><a href="#在-c-11-中使用-using-而非-typedef" class="headerlink" title="在 c++11 中使用 using 而非 typedef"></a>在 c++11 中使用 <code>using</code> 而非 <code>typedef</code></h3><p><code>typedef</code> 是 c 的遗留物。</p><p>c++11 强化了 <code>using</code> 的作用。自此，<code>using</code> 能做的事情是 <code>typedef</code> 的超集。</p><p>e.g.</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- typedef long long ll;</span></span><br><span class="line"><span class="deletion">- typedef int iarrN[100003];</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ using ll = long long;</span></span><br><span class="line"><span class="addition">+ using iarrN = int[100003];</span></span><br></pre></td></tr></table></figure><hr><h3 id="P5755-NOI2000-单词查找树"><a href="#P5755-NOI2000-单词查找树" class="headerlink" title="P5755 [NOI2000]单词查找树"></a>P5755 [NOI2000]单词查找树</h3><p>发现 Luogu 新上了一面 NOI / 省选题，点开一道题目似乎很毒瘤的看了看。</p><p>？？？</p><p>这不是棵 Trie 树马！贴心的 CCF 生怕选手看不出还给了张图（</p><p>写了写了<del>，还能顺便蹭篇题解</del></p><p><strong>TODO: 但是并不是很会算 Trie 的空间/kk。</strong></p><p><strong>TODO: 似乎可以排序 + 骚操作搞过去</strong></p><p>但是数据好像很水的样子，<code>std::cin</code> + <code>std::string</code> 还能 3ms AC（</p><h3 id="P3369-【模板】普通平衡树"><a href="#P3369-【模板】普通平衡树" class="headerlink" title="P3369 【模板】普通平衡树"></a>P3369 【模板】普通平衡树</h3><p>看 AgOH 的视频学会了 FHQ-Treap。</p>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fa_555 的 CSP-S 2019 退役记</title>
      <link href="/2019/fa-555-%E7%9A%84-CSP-S-2019-%E9%80%80%E5%BD%B9%E8%AE%B0/"/>
      <url>/2019/fa-555-%E7%9A%84-CSP-S-2019-%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h2><p>由于菜 fa_555 一直不会 dp 和优化，所以在打各种 dp。</p><p>用暴力过掉了<a href="https://www.luogu.org/problem/P4719">【模板】动态 dp</a>，并且还上了最优解第二 <strong><em>（消耗 rp）</em></strong>。</p><p>机房的同学发现奇数年 NOIP 都考了模拟/搜索，于是认定今年 CSP 一定会有模拟或搜索题 <strong><em>（flag1）</em></strong>。</p><hr><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>期中考试后全校<strong>除了 OI 选手</strong>都放假了。考前想要出去放放风，于是下午全机房溜出去看了「天気の子」。</p><p>真的太爱这部剧的世界观辣 <del>，如果能给我个妹子我也宁可把一座城淹掉的</del>！</p><p><del>我永远喜欢天野陽菜！</del></p><hr><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>中午 12 点不到就到了日照，被告知宿舍没有收拾好，于是顶着大太阳站了一小时，晒得有点反胃。</p><p>下午在宿舍里焦急地复习了各种模板，<del>和</del>听 $\texttt{I}\color{red}{\texttt{rressey}}$、$\texttt{q}\color{red}{\texttt{azswedx}}$ 讨论了卡常之类的东西，没有颓废。</p><hr><p>晚上试机，发现考场门口是“祝各位同学 <strong>CPS</strong> 取得好成绩”。</p><p>入场问监考老师带的包放在哪里，结果竟然让我随身带着（黑人问号脸）。考场电脑用 <code>getchar</code> 和 <code>fread</code> 都贼慢，第二天才发现是火绒的锅。机子没啥问题。</p><p>发现 D 盘里有个 <code>day1.rar</code>，里面有 <code>robot</code>, <code>route</code>, <code>consequence</code> 三个文件夹。天真的我以为这是第二天的题，于是开始兴奋地试密码 <del>，还以为自己要被禁赛了</del>。出场问了 $\texttt{I}\color{red}{\texttt{rressey}}$ 才知道这是 NOI 2019 day1。</p><hr><p>宿舍有仨人打呼噜，睡得很差。睡了大概有 4h 的样子。</p><hr><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>早饭真难吃。</p><p>门口已经改成了“祝各位同学 <strong>CSP</strong> 取得好成绩”。</p><hr><p>开包看题。用大概 20min 切掉了 T1，反复确认了 <code>1ull</code> 之类的细节问题。</p><p>保证不会出错以后开了 T2。发现链的做法可以很容易地扩展到树上，于是开始推链的 $O(1)$ 转移的做法。用了大约 30min 的样子。写出代码来发现怎么也过不了树的大样例，又调了半小时才发现是一处下标写错了 <del>，我事 sb</del>。由于感觉花了很长时间，过了大样例就跑去 T3 了。</p><p>此时才大约 10:10，心想：“我还能 2h 骗不出 60 分不成？”<strong><em>（flag2）</em></strong>。读完题发现不大可做，吃了条士力架冷静了一下。死磕 2h 无果，全排列 10 分 + <code>std::random_shuffle</code> 走人。</p><hr><p>出场以为自己挂掉，心态很是爆炸。结果 $\texttt{君}\color{red}{\texttt{莫笑～}}$ 等同学都说自己大约只能拿 150 分，甚至 $\texttt{I}\color{red}{\texttt{rressey}}$ 也只有 210 分，心情瞬间不那么糟了。</p><p>午饭挺不错。大家声讨了出题人，并纷纷表示“明天 T1 可怜，T2 由乃，T3 小葱，我 8:31 离场”<strong><em>（flag3）</em></strong>。<del>果然一个都没有。</del></p><p>午饭后跟 $\texttt{I}\color{red}{\texttt{rressey}}$ 小声说了一句：“明天不会考<strong>屁配</strong>吧”<strong><em>(flag4)</em></strong>。</p><hr><p>听说 T2 大样例很水，很慌，不过由于调了很长时间，心里还是有底。</p><p>下午和 $\texttt{I}\color{red}{\texttt{rressey}}$ 一起颓了一会，才意识到自己应该去学习。做了下新出的<a href="https://www.luogu.org/problem/P5656">【模板】二元一次不定方程</a>，并确信自己完全明白了。</p><p>晚上为了睡好，紧急把我爸从隔壁市喊来，出去住了酒店。在酒店写了扫描线求面积，但求周长怎么也写不对。</p><p>果然睡得挺好。第二天脑子都睡糊涂了。</p><hr><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>回到学校宿舍，花 5min 调出来了扫描线求周长 <strong><em>（rp 耗光）</em></strong>，还蛮高兴的。</p><p>去考场的路上发现没带水，心态有点崩。果然接下来度过了人生最阴暗的 3.5h。</p><hr><p>看到 T1 的 <code>Yazid</code> 发现自己奶中，直接懵逼。读错了题目，以为最多只能选 <code>M</code> 道菜，结果花了 2h，过不了大样例 3。暴力和正解错得一样，但紧张到读了好几遍题都没发现错误。</p><p>感觉不能继续浪费时间，开了 T2。自我感觉只会 $O(2 ^ n)$ 暴力，于是光速打完继续调 T1。</p><p>还剩 40min 时意识到必须开 T3，发觉部分分充足，于是写了 $O(n ^ 2)$ + 链的 55 分。二叉树没空写了。</p><hr><p>出考场差点哭了出来。</p><p>晚上参加了我校传统的退役选手送别会，交流发现高二选手人均考挂。</p><hr><p><strong>100 + 100 + 10 + 8 + 12 + 55 = 285</strong></p><p>因为读错题浪费时间而扔掉 WC 甚至 1= 的分数是我从来没想过的极其愚蠢的退役方式。</p><p>发现人均比我分高，意识到自己完蛋了。从没想过自己会联赛退役，心情极端差。</p><p>憧憬的 WC APIO CTS NOI 都将与我无关。</p><hr><h2 id="Day-3-1"><a href="#Day-3-1" class="headerlink" title="Day 3"></a>Day 3</h2><p>文化课真好玩，挨老师训真不好玩。</p><p>教室一点也不像机房。这里没有一点家的感觉。</p><p>回机房看了一眼。我的位置上已经没有电脑了。昨晚有人把倒计时改成了 “距 CSP-S 2019 还剩 -1 天”。我加了两笔，成了 “-2 天”。</p><hr><h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p>机房的倒计时我每天都去改一次。我也不知道为什么想这样做。</p><p>源程序公示了，好在没有挂分。$\texttt{一}\color{red}{\texttt{扶苏一}}$ 自测的结果除去高三选手，我是 rk67，和去年 $\texttt{I}\color{red}{\texttt{rressey}}$ 一模一样。初中神仙 $\texttt{q}\color{red}{\texttt{azswedx}}$ 直接搞到了 rk1，在这里祝贺他。</p><p>同级的选手真的几乎全挂了。一批实力稳 1= 的选手竟然有些甚至连 2= 都保不住，真的很可惜。</p><p>我似乎没有退役？前方的道路还是由我来选择吧。</p><h2 id="Day-17"><a href="#Day-17" class="headerlink" title="Day 17"></a>Day 17</h2><p>SD 的成绩发了。</p><p>分数一点没变，名次变成了连带高三 rk 79。</p><p>这个名次拿不到 7 级。</p><p>就说这些吧。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF985E 【Pencils and Boxes】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-CF985E-%E3%80%90Pencils-and-Boxes%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-CF985E-%E3%80%90Pencils-and-Boxes%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>under 题解 <a href="https://www.luogu.org/problem/CF985E">CF985E</a></p><hr><span id="more"></span><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定大小为 $n$ 的可重集合 $T$ 与整数 $k, d$，求若干互不相交的可重集合 $S_i$，使得</p><ul><li>$\bigcup S_i = T$</li><li>$|S_i| \ge k$</li><li>$\max\{S_i\} - \min\{S_i\} \le d$</li></ul><p>判断能否找到一组合法的解。</p><ul><li>$1 \le k, n \le 5 \times 10^5, \ d \le 10^9$</li></ul><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>初看题面，很容易想到一种贪心做法：</p><p>从小到大排序，每次选择第一个未被选用的数 $a_i$，将 $a_i \sim a_i + d$ 的所有数划分到同一集合中。</p><p>不难想到这种算法是错误的。考虑数据 <code>4 2 1 1 2 2 3</code>，就可以把这种算法卡掉。对于这组数据，唯一合法的划分方案为 $S_1 = \{1, 2\}, S_2 = \{2, 3\}$。上述贪心将两个元素 <code>2</code> 划分到了同一个集合中，导致 <code>3</code> 无法分配。</p><p><del>自然想到</del>利用 dp。</p><p>令 <code>f[i]</code> 表示前 i 个数有无合法划分方案。转移时利用队列，考虑 <code>a[i] - a[i - K]</code> 的差值与 <code>k</code> 的大小关系。细节见代码。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::bitset&lt;500003&gt; f;</span><br><span class="line"><span class="keyword">int</span> N, K, D, z[<span class="number">500003</span>];</span><br><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[i - K]) q.<span class="built_in">push</span>(z[i - K + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; z[i] - q.<span class="built_in">front</span>() &gt; D)</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">    f.<span class="built_in">set</span>(i, (<span class="keyword">bool</span>)q.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; N &gt;&gt; K &gt;&gt; D;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    std::cin &gt;&gt; z[i];</span><br><span class="line">  std::<span class="built_in">sort</span>(z + <span class="number">1</span>, z + N + <span class="number">1</span>);</span><br><span class="line">  std::cout &lt;&lt; (<span class="built_in">dp</span>() ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3593 【[POI2015]TAB】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-P3593-%E3%80%90POI2015-TAB%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-P3593-%E3%80%90POI2015-TAB%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>under 题解 <a href="https://www.luogu.org/problem/P3593">P3593</a></p><span id="more"></span><hr><p>本篇题解代码已<a href="http://darkbzoj.tk/submission/38792">在 darkbzoj AC</a>（平均 128ms 每测试点），但<a href="https://www.luogu.org/record/24905515">在洛谷全 TLE</a>。</p><p>在本机可过极限数据 （131 MB，生成代码附于文末）。因无人 AC，猜测可能是洛谷数据出锅，烦请各位管理员核实。</p><hr><p>qbxt 的例题，跑来<del>水</del>做一发，结果没想到是道坑题!</p><p><em>上面本来有两张表情，但是洛谷图床不能在外链访问，所以……</em></p><hr><h3 id="发掘题目信息"><a href="#发掘题目信息" class="headerlink" title="发掘题目信息"></a>发掘题目信息</h3><ul><li>矩阵中的数两两不同</li><li>操作：交换任意 整行 / 整列</li><li>元素值域 <code>[-1e6, 1e6]</code>，整数</li></ul><p>对于原矩阵中同一行中的元素：</p><ol><li>考虑行交换，交换后显然仍在同一行内；</li><li>考虑列交换，交换后顺序改变，但仍在同一行内。</li></ol><p>原矩阵中同一列中元素的情况类似。</p><p>因此直接判断原矩阵同一 行/列 中的元素在变换后矩阵内是否均仍在同一 行/列，复杂度 $O(Tnm)$，可以通过本题。细节见代码。</p><p><del>你以为这就完了吗？当然没有。</del></p><h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><ul><li>每组数据第二个矩阵中的元素可能在第一个矩阵中并未出现，但可能在上一组数据中出现过，需要进行处理。考虑 <code>memset</code> 的巨大常数，选用清零较快的 <code>std::bitset</code>。</li><li>如果边读边做，发现数据 NIE 后应该把当前组数据读完，而不是直接做下一组数据。</li><li>别忘了给个偏移量</li></ul><hr><p><del>你以为这就完了吗？当然没有。</del></p><h3 id="爆零后的探索"><a href="#爆零后的探索" class="headerlink" title="爆零后的探索"></a>爆零后的探索</h3><p>我在洛谷 TLE 后猜测是算法常数过大，于是在本地测试了极限数据。</p><p>发现效率瓶颈在<strong>读入</strong>：<code>scanf 10s+</code>, <code>getchar 3s+</code>, <code>fread ~0.35s</code>。然而，这份使用了 <code>fread</code> 的代码仍然在洛谷不能通过本题。</p><hr><p>darkbzoj AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IO</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">10000000</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,<span class="number">10000000</span>,stdin),p1==p2)?EOF:*p1++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">inline</span> IO <span class="keyword">operator</span>&gt;&gt;(T &amp;n) &#123;</span><br><span class="line">    n=<span class="number">0</span>; <span class="keyword">bool</span> s=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) s|=c==<span class="string">&#x27;-&#x27;</span>,c=<span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) n=(n&lt;&lt;<span class="number">3</span>)+(n&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=<span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">if</span>(s) n=-n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; cin;</span><br><span class="line"></span><br><span class="line">std::bitset&lt;2000003&gt; vis;</span><br><span class="line"><span class="keyword">int</span> T, N, M, nr[<span class="number">1003</span>], nc[<span class="number">1003</span>], r[<span class="number">2000003</span>], c[<span class="number">2000003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vis.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="built_in">memset</span>(nr, <span class="number">0</span>, <span class="keyword">sizeof</span> nr);</span><br><span class="line">  <span class="built_in">memset</span>(nc, <span class="number">0</span>, <span class="keyword">sizeof</span> nc);</span><br><span class="line">  <span class="keyword">bool</span> f = <span class="number">1</span>;</span><br><span class="line">  cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; t;</span><br><span class="line">      t += <span class="number">1000000</span>;</span><br><span class="line">      vis.<span class="built_in">set</span>(t);</span><br><span class="line">      r[t] = i, c[t] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; t;</span><br><span class="line">      <span class="keyword">if</span> (!f) <span class="keyword">continue</span>;</span><br><span class="line">      t += <span class="number">1000000</span>;</span><br><span class="line">      <span class="keyword">if</span> (!vis[t]) &#123; f = <span class="number">0</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">      <span class="keyword">if</span> (!nr[r[t]]) nr[r[t]] = i;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nr[r[t]] != i) f = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!nc[c[t]]) nc[c[t]] = j;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nc[c[t]] != j) f = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (cin &gt;&gt; T; T; --T)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">solve</span>() ? <span class="string">&quot;TAK&quot;</span> : <span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>极限数据生成代码（T = 10，N = M = 1000，均 TAK）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> T = <span class="number">10</span>; T; --T) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1000 1000&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; ++j)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ++t);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; ++j)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ++t);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果这篇题解出现了错误，欢迎各位 dalao 斧正。<strong>谢谢大家 qwq！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 SP913 【QTREE2 - Query on a tree II】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-SP913-%E3%80%90QTREE2-Query-on-a-tree-II%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-SP913-%E3%80%90QTREE2-Query-on-a-tree-II%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>under 题解 <a href="https://www.luogu.org/problem/SP913">SP913</a></p><hr><p>找树剖题的时候发现这题，发现用倍增很<del>水</del>简单，于是写了一发，发现跟现有题解还不大一样，于是写篇题解造 (bao) 福 (fu) 社会。</p><span id="more"></span><hr><h3 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h3><p>树上倍增，LCA</p><p><del>当然你也可以顺手树剖维护个 LCA 然后倍增统计答案</del></p><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><em>以下设 <code>f</code> 为 <code>u</code> 和 <code>v</code> 的最近公共祖先</em></p><ol><li>以结点 <code>1</code> 为根，套路性 dfs，并求出倍增祖先数组 <code>fa[][]</code> &amp; 结点深度 <code>dep[]</code> &amp; 根到每个结点的边权和 <code>wn[]</code><ul><li>$O(n \log n)$</li></ul></li><li>对于每个 <code>DIST u v</code> 操作，答案显然为 <code>wn[u] + wn[v] - 2 * wn[f]</code><ul><li>单次 $O( \log n)$</li></ul></li><li>对于每个 <code>KTH u v k</code> 操作，分情况讨论。<ul><li>若 <code>dep[u] - dep[f] + 1 &lt; k</code>，答案即为 <code>u</code> 的 <code>k</code> 级祖先；</li><li>若 <code>dep[u] - dep[f] + 1 &gt; k</code>，答案为 <code>v</code> 的 祖先，且为 <code>dep[u] + dep[v] - 2 * dep[k] + 2 - k</code> 级祖先。考虑 <code>u</code> 到 <code>v</code> 的路径上共有 <code>dep[u] + dep[v] - 2 * dep[f] + 1</code> 个结点，得到这个式子；</li><li>若 <code>dep[u] - dep[f] + 1 == k</code>， 答案为 <code>f</code>。可特判，也可并入前两种情况处理。</li><li>单次 $ O( \log n) $</li></ul></li></ol><p>总复杂度 $ O((n + q) \log n) $</p><hr><h3 id="变量解释与代码"><a href="#变量解释与代码" class="headerlink" title="变量解释与代码"></a>变量解释与代码</h3><p><del><code>cin:</code> 重载的快读</del></p><p><code>MX:</code> $ \lfloor \log_2 N \rfloor $</p><p><code>queryt(u, v, k):</code> 返回 <code>KTH u v k</code> 操作的答案</p><p><em>其余变量意义同 <strong>思路</strong> 部分</em></p><p>代码 (c++11) :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IO</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">inline</span> IO <span class="keyword">operator</span>&gt;&gt;(T &amp;n) &#123;</span><br><span class="line">    n=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) n=(n&lt;&lt;<span class="number">3</span>)+(n&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// n &gt;= 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; cin;</span><br><span class="line"><span class="comment">// 不要 iostream + using namespace std！会 CE 的！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MX = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> T, N, u, v, w, tot, head[<span class="number">10003</span>], dep[<span class="number">10003</span>], wn[<span class="number">10003</span>], fa[<span class="number">10003</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nxt, to, w;</span><br><span class="line">&#125; e[<span class="number">20003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  e[++tot] = &#123;head[u], v, w&#125;;</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 预处理</span></span><br><span class="line">  dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">  fa[u][<span class="number">0</span>] = f;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[u]; ++i)</span><br><span class="line">    fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((v = e[i].to) == f) <span class="keyword">continue</span>;</span><br><span class="line">    wn[v] = wn[u] + e[i].w;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 倍增求 LCA</span></span><br><span class="line">  <span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = MX; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (dep[v] &lt;= dep[u] - (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">      u = fa[u][i];</span><br><span class="line">  <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = MX; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (fa[u][i] != fa[v][i])</span><br><span class="line">      u = fa[u][i], v = fa[v][i];</span><br><span class="line">  <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 分类讨论</span></span><br><span class="line">  <span class="keyword">int</span> f = <span class="built_in">Lca</span>(u, v);</span><br><span class="line">  <span class="keyword">if</span> (dep[u] - dep[f] + <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">    <span class="comment">// 若答案为 $v 的祖先，则转换为求 u 的祖先的情况，简化代码</span></span><br><span class="line">    k = dep[u] + dep[v] - (dep[f] &lt;&lt; <span class="number">1</span>) + <span class="number">2</span> - k;</span><br><span class="line">    u = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = MX; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="comment">// 倍增维护答案</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= (<span class="number">1</span> &lt;&lt; i) + <span class="number">1</span>) &#123;</span><br><span class="line">      u = fa[u][i];</span><br><span class="line">      k -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 多测不清空，爆零两行泪</span></span><br><span class="line">  tot = wn[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span> fa);</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">    <span class="built_in">addEdge</span>(v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (cin &gt;&gt; T; T; --T) &#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">      <span class="keyword">if</span> (op[<span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (op[<span class="number">1</span>] == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, wn[u] + wn[v] - (wn[<span class="built_in">Lca</span>(u, v)] &lt;&lt; <span class="number">1</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queryt</span>(u, v, w));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果有错误或不懂的地方，请在私信或评论中告知我，<strong>谢谢你们 qwq</strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形结构 </tag>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 UVA10288 【优惠券 Coupons】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-UVA10288-%E3%80%90%E4%BC%98%E6%83%A0%E5%88%B8%20Coupons%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-UVA10288-%E3%80%90%E4%BC%98%E6%83%A0%E5%88%B8%20Coupons%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>under 题解 <a href="https://www.luogu.org/problem/UVA10288">UVA10288</a></p><hr><p>乍看这题：这不是裸的概率 dp 吗！</p><span id="more"></span><p>直到我看到<a href="https://www.luogu.org/discuss/show/65737">输出格式</a>……</p><p>为啥要输出带分数啊 <del>自闭了，怎么代码比推导难啊</del></p><hr><p>自闭归自闭，题目还是要做的。根据 <del>数学直觉</del> <a href="https://www.luogu.org/problem/SP1026">这道题</a>的经验，我们知道答案应该是 $\ n\sum_{i = 1}^n \tfrac{1}{i} \ $（这道题难点不在这个结论，就不进行证明了）。</p><p>要输出分数，调和级数 $ ( \sum_{i = 1} \frac{1}{i} ) $ 求起来就没有那么快乐了。我们假设已经求出调和级数的前 $i - 1 \ (i &gt; 1)$ 项是 $\frac{a}{b}$，那么第 $i$ 项就是</p><script type="math/tex; mode=display">\frac{a}{b} + \frac{1}{i} = \frac{ai + b}{bi}</script><p>一个简单的通分，使得这题可以直接计算了。</p><p>初看式子，我以为会爆精度。（由于并不会处理未知组数数据）打算用 python 打表，写出了这段代码 (python3)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line">A = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">B = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">34</span>): <span class="comment"># [2, 34)</span></span><br><span class="line">  a = A[-<span class="number">1</span>]</span><br><span class="line">  b = B[-<span class="number">1</span>]</span><br><span class="line">  A.append(a * i + b)</span><br><span class="line">  B.append(b * i)</span><br><span class="line">  d = gcd(A[-<span class="number">1</span>], B[-<span class="number">1</span>])</span><br><span class="line">  A[-<span class="number">1</span>] //= d</span><br><span class="line">  B[-<span class="number">1</span>] //= d</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">34</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(A[i], B[i]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出位数最多的一行是 <code>586061125622639 144403552893600</code>。由此发现边算边约分，并不会爆 <code>long long</code>。于是这题就可以直接用 c++ A掉了。具体<del>恶心</del>的输出格式详见代码。</p><hr><p>变量解释与参考代码 (c++11):</p><p><code>A[i]</code> 为调和级数前缀和第 i 项的分子</p><p><code>B[i]</code> 为调和级数前缀和第 i 项的分母</p><p><code>void Red(ll &amp;m, ll &amp;n)</code> 对 &amp;m 和 &amp;n 进行约分</p><p><code>int Len(ll n)</code> 返回整数 n 的数位个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ll A[<span class="number">35</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, B[<span class="number">35</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// B[1] 需要预处理，否则无法计算</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Red</span><span class="params">(ll &amp;m, ll &amp;n)</span> </span>&#123;</span><br><span class="line">  ll d = __gcd(m, n);</span><br><span class="line">    <span class="comment">// 库函数 __gcd() 联赛不可用</span></span><br><span class="line">  m /= d, n /= d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i = <span class="number">2</span>, a, b; i &lt;= <span class="number">33</span>; ++i) &#123;</span><br><span class="line">    a = A[i - <span class="number">1</span>], b  = B[i - <span class="number">1</span>];</span><br><span class="line">    A[i] = (ll)a * i + b;</span><br><span class="line">    B[i] = (ll)b * i;</span><br><span class="line">    <span class="built_in">Red</span>(A[i], B[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Len</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> ++ans; <span class="keyword">while</span>(n /= <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// do-while 可以避免 n == 0 的情况出错</span></span><br><span class="line">    <span class="comment">// 不过在这里用 while 也不会出问题</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; N) &#123;</span><br><span class="line">    ll a = A[N] * N, b = B[N];</span><br><span class="line">    <span class="built_in">Red</span>(a, b); <span class="comment">// 由于乘了一个 $N，需要再次约分</span></span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果能整除，直接特判，不需输出分数</span></span><br><span class="line">      cout &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll k = a / b; <span class="comment">// k 为带分数的整数部分</span></span><br><span class="line">    a -= k * b;</span><br><span class="line">    <span class="keyword">int</span> lb = <span class="built_in">Len</span>(b), lk = <span class="built_in">Len</span>(k);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下分别输出带分数的三行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lk + <span class="number">1</span>; ++i)</span><br><span class="line">      cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; k &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lb; ++i)</span><br><span class="line">      cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lk + <span class="number">1</span>; ++i)</span><br><span class="line">      cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果有错误或不懂的地方，请在私信或评论中告知我。<strong>谢谢大家qwq</strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 UVA10214 【树林里的树 Trees in a Wood.】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-UVA10214-%E3%80%90%E6%A0%91%E6%9E%97%E9%87%8C%E7%9A%84%E6%A0%91%20Trees%20in%20a%20Wood%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-UVA10214-%E3%80%90%E6%A0%91%E6%9E%97%E9%87%8C%E7%9A%84%E6%A0%91%20Trees%20in%20a%20Wood%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>under 题解 <a href="https://www.luogu.org/problem/UVA10214">UVA10214</a></p><hr><p>真心推荐刚学莫反的同学来做一下这道题目，这才是真正的 Mobius 反演入门题啊！</p><span id="more"></span><p><a href="https://www.luogu.org/problem/P2158">P2158 仪仗队</a>是这题的特殊情况，前者可以用欧拉 $\varphi$ 函数解决，而这题用 Mobius 反演简单得多。</p><p>没学过莫反的可以来我的<a href="https://www.luogu.org/blog/fa555/solution-p4450">这篇题解</a>的 前置知识 部分学习一下。</p><p>我们回到这题。</p><hr><p>分析题意，我们只需将四个象限之一的答案求出，就可推广到整个坐标系。</p><p>简化版题意：给定一个 N * M 的矩阵，求</p><script type="math/tex; mode=display">\sum \limits_{i = 1}^N \sum \limits_{j = 1}^M [\gcd(i, j) = 1]</script><p>尝试对这个式子进行套路性的莫反变形，得到</p><script type="math/tex; mode=display">\sum \limits_{i = 1}^N \sum \limits_{j = 1}^M \sum \limits_{d | \gcd(i, j)} \mu(d)</script><p>可以将 $d | \gcd(i, j)$ 拆开</p><script type="math/tex; mode=display">\sum \limits_{i = 1}^N \sum \limits_{j = 1}^M \sum \limits_{d | i, d | j} \mu(d)</script><p>改变枚举顺序，得到</p><script type="math/tex; mode=display">\sum \limits_{d = 1}^{\min(N, M)} \mu(d) \lfloor \tfrac{N}{d} \rfloor \lfloor \tfrac{M}{d} \rfloor</script><p>就可以单次 $O(n)$ 枚举答案了！</p><p>但是我们并不知道数据组数 <del>垃圾UVA</del>，所以优化是必要的。和式含有两个形如 $\lfloor \tfrac{N}{d} \rfloor$ 的因子，意味着可以通过数论分块优化到单次 $O( \sqrt{N})$ 的复杂度，可以通过本题。</p><p>TIPS:</p><ol><li><p>求出的 <code>ans</code> 是单个象限中的答案，加上坐标轴四个方向的贡献均为 <code>1</code>，因此答案的分子是 <code>ans * 4 + 4</code>。</p></li><li><p>原点是没有树的，因此分母是 <code>(N * 2 + 1) * (M * 2 + 1) - 1</code>。</p></li><li><p>极端数据的分母会爆 <code>int</code>，不要忘记 <code>long long</code> 和强制类型转换。</p></li></ol><p>code(c++):</p><p><em>请手动优化常数</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">bitset&lt;2003&gt; v; <span class="comment">// 此处作用等价于 bool v[2003];</span></span><br><span class="line"><span class="keyword">int</span> N, M, p[<span class="number">305</span>], mu[<span class="number">2003</span>];</span><br><span class="line">ll ans, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">  mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[i]) p[++m] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>, x; j &lt;= m &amp;&amp; i * p[j] &lt;= N; ++j) &#123;</span><br><span class="line">      x = i * p[j];</span><br><span class="line">      v.<span class="built_in">set</span>(x); <span class="comment">// v[x] = 1;</span></span><br><span class="line">      <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 此时 mu[x] = 0;</span></span><br><span class="line">      mu[x] = -mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">    mu[i] += mu[i - <span class="number">1</span>]; <span class="comment">// 顺便求出前缀和</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 规定输出小数位数</span></span><br><span class="line">  <span class="built_in">sieve</span>(<span class="number">2000</span>); <span class="comment">// min(maxa, maxb) = 2000</span></span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; N &gt;&gt; M) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!N) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>; <span class="comment">// 多测不清空，爆零两行泪</span></span><br><span class="line">    <span class="keyword">if</span>(N &gt; M) <span class="built_in">swap</span>(N, M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j, n, m; i &lt;= N; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">      n = N / i, m = M / i; <span class="comment">// 可有可无的小常数优化</span></span><br><span class="line">      j = <span class="built_in">min</span>(N / n, M / m);</span><br><span class="line">      ans += (ll)(mu[j] - mu[i - <span class="number">1</span>]) * n * m;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * <span class="number">4</span> + <span class="number">4</span>;</span><br><span class="line">    tot = (ll)(N * <span class="number">2</span> + <span class="number">1</span>) * (M * <span class="number">2</span> + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; (<span class="keyword">double</span>)ans / tot &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果有错误或不懂的地方，请在私信或评论中告知我。<strong>谢谢大家！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P4450 【双亲数】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-P4450-%E3%80%90%E5%8F%8C%E4%BA%B2%E6%95%B0%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-P4450-%E3%80%90%E5%8F%8C%E4%BA%B2%E6%95%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p><strong>upd：256 天后的更新，修复了错误和公式格式，充实了内容</strong></p><p>under 题解 <a href="https://www.luogu.org/problem/P4450">P4450</a></p><p><em>蒟蒻第一道莫反题</em></p><p><em>本题解适合新手学习基础，dalao 请跳过，不要嘲讽 qwq</em></p><span id="more"></span><hr><h3 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h3><h4 id="单位函数（-epsilon-）："><a href="#单位函数（-epsilon-）：" class="headerlink" title="单位函数（$\epsilon$）："></a>单位函数（$\epsilon$）：</h4><script type="math/tex; mode=display">\epsilon(i) = \begin{cases}1 &, i = 1 \\0 &, i \ne 1\end{cases}</script><p>即当且仅当 <code>i = 1</code> 时取值取值为 <code>1</code>，否则为 <code>0</code>。很简单对不对？</p><h4 id="Dirichlet-卷积（-ast-）："><a href="#Dirichlet-卷积（-ast-）：" class="headerlink" title="Dirichlet 卷积（$\ast$）："></a>Dirichlet 卷积（$\ast$）：</h4><p>Dirichlet 卷积是数论函数之间的运算。即</p><script type="math/tex; mode=display">h = f \ast g</script><p>其中 $f, g, h$ 均为数论函数。则</p><script type="math/tex; mode=display">h(n) = \sum_{d | n}{f(d) g \left(\frac nd \right)}</script><p>也可以写作</p><script type="math/tex; mode=display">h(n) = \sum_{i · j = n}{f(i) g(j)}</script><p>我们发现：$\epsilon$ 函数是 Dirichlet 卷积的单位元，即 $f = f \ast \epsilon$。</p><h4 id="Mobius-函数（-mu-）："><a href="#Mobius-函数（-mu-）：" class="headerlink" title="Mobius 函数（$\mu$）："></a>Mobius 函数（$\mu$）：</h4><script type="math/tex; mode=display">\mu(n) = \begin{cases}1 &, n = 1 \\(-1)^m &, n = p_1p_2 \cdots p_m \\0 &, \mathrm{otherwise}\end{cases}</script><p>其中 $p_1,p_2, \cdots, p_m$ 是不同的质数。$\mu(n)$ 恰在 $n$ 无平方因子时取值非零。显然 $\mu$ 是积性函数。</p><script type="math/tex; mode=display">\sum_{d | n}{\mu(d)} = \epsilon(n) \\\epsilon = 1 \ast \mu</script><h4 id="Mobius-变换"><a href="#Mobius-变换" class="headerlink" title="Mobius 变换"></a>Mobius 变换</h4><p>设 $f$ 是数论函数，若数论函数 $g$ 满足</p><script type="math/tex; mode=display">\begin{align}g &=  f * \mathbf1 \\\textrm{That is} \quad g(n) &= \sum_{d | n}{f(d)}\end{align}</script><p>则称 $g$ 是 $f$ 的 Mobius 变换。</p><p>推一下式子。</p><script type="math/tex; mode=display">g = f \ast 1 \Rightarrow f = f \ast \epsilon = f \ast 1 \ast \mu = g \ast \mu</script><p>即</p><script type="math/tex; mode=display">g = f \ast 1 \Leftrightarrow f = g \ast \mu</script><p>至此就可以来做这道题了。</p><hr><p>回到了原题。题目要求的是</p><script type="math/tex; mode=display">\sum_{i = 1}^A{\sum_{j = 1}^B{[\gcd(i, j) = d]}}</script><p>对式子进行套路性的变形</p><script type="math/tex; mode=display">\sum_{i = 1}^{\lfloor A / d \rfloor}{\sum_{j = 1}^{\lfloor B / d \rfloor}{[\gcd(i, j) = 1]}}</script><p>出现了 $[ \gcd(i, j) = 1]$，也即 $\epsilon( \gcd(i, j))$。把 $\epsilon = 1 \ast \mu$ 代入，得到了</p><script type="math/tex; mode=display">\sum_{i = 1}^{\lfloor A / d \rfloor}{\sum_{j = 1}^{\lfloor B / d \rfloor}{\sum_{g | \gcd(i, j)}{\mu(g)}}}</script><p><del>（似乎越来越丑了）</del>此时可以把 $d | \gcd(i, j)$ 拆开：</p><script type="math/tex; mode=display">\begin{align}& \sum_{i = 1}^{\lfloor A / d \rfloor}{\sum_{j = 1}^{\lfloor B / d \rfloor}{\sum_{g | i, g | j}{\mu(g)}}} \\=& \sum_{g = 1}^{\min(A / d, B / d)}{\mu(g) \left\lfloor \frac{A}{dg} \right\rfloor \left\lfloor \frac{B}{dg} \right\rfloor}\end{align}</script><p>至此，计算答案可以 $O(n)$ 解决。</p><p>算法还可以继续优化。发现式子里还有两个形如 $\lfloor n / d \rfloor$ 的因子，因此可以整除分块优化成 $O(\sqrt{n})$ 的。配合 $O(n)$ 的线性筛 $\mu$ 函数，总复杂度 $O(n)$，可以轻松通过本题。</p><hr><h3 id="code-1"><a href="#code-1" class="headerlink" title="code 1"></a>code 1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;1000003&gt; v;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">78501</span>], mu[<span class="number">1000003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">set</span>(<span class="number">1</span>), mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) p[++m] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; i * p[j] &lt;= N; ++j) &#123;</span><br><span class="line">      v.<span class="built_in">set</span>(i * p[j]);</span><br><span class="line">      <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      mu[i * p[j]] = -mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">    mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> A, B, d;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; A &gt;&gt; B &gt;&gt; d;</span><br><span class="line">  A /= d, B /= d;</span><br><span class="line">  <span class="keyword">if</span> (A &gt; B) std::<span class="built_in">swap</span>(A, B);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sieve</span>(A);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r, a, b; l &lt;= A; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    a = A / l, b = B / l;</span><br><span class="line">    r = std::<span class="built_in">min</span>(A / a, B / b);</span><br><span class="line">    ans += <span class="number">1ll</span> * a * b * (mu[r] - mu[l - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="code-2"><a href="#code-2" class="headerlink" title="code 2"></a>code 2</h3><p><del>如果你像我一样闲得难受，可以学来杜教筛写写这题，复杂度好像还更高了。</del></p><p>不会杜教筛但想学的朋友可以来看我的<a href="https://fa555.github.io/2020/杜教筛学习笔记/">这篇题解</a>。</p><p>这个多次询问的题目让我对杜教筛及空间优化有了更深入的理解（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;10003&gt; v, vm;</span><br><span class="line"><span class="keyword">int</span> MX, base, p[<span class="number">1231</span>], mu[<span class="number">10003</span>], mu_[<span class="number">10003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">to</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MX / x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> N)</span></span>; <span class="comment">// 同 code 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= base) <span class="keyword">return</span> mu[N];</span><br><span class="line">  <span class="keyword">if</span> (vm[<span class="built_in">to</span>(N)]) <span class="keyword">return</span> mu_[<span class="built_in">to</span>(N)];</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r, L; l &lt;= N; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    L = N / l, r = N / L;</span><br><span class="line">    ans += (r - l + <span class="number">1</span>) * <span class="built_in">getMu</span>(L);</span><br><span class="line">  &#125;</span><br><span class="line">  vm.<span class="built_in">set</span>(<span class="built_in">to</span>(N));</span><br><span class="line">  <span class="keyword">return</span> mu_[<span class="built_in">to</span>(N)] = <span class="number">1</span> - ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> A, B, d;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; A &gt;&gt; B &gt;&gt; d;</span><br><span class="line">  A /= d, B /= d;</span><br><span class="line">  <span class="keyword">if</span> (A &gt; B) std::<span class="built_in">swap</span>(A, B);</span><br><span class="line"></span><br><span class="line">  MX = A, base = <span class="built_in">pow</span>(A, <span class="number">2.</span> / <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">sieve</span>(base);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r, a, b, gR, gL; l &lt;= A; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    a = A / l, b = B / l;</span><br><span class="line">    r = std::<span class="built_in">min</span>(A / a, B / b);</span><br><span class="line">    vm.<span class="built_in">reset</span>(), gR = <span class="built_in">getMu</span>(r);</span><br><span class="line">    vm.<span class="built_in">reset</span>(), gL = <span class="built_in">getMu</span>(l - <span class="number">1</span>);</span><br><span class="line">    ans += <span class="number">1ll</span> * a * b * (gR - gL);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P5142 【区间方差】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-P5142-%E3%80%90%E5%8C%BA%E9%97%B4%E6%96%B9%E5%B7%AE%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-P5142-%E3%80%90%E5%8C%BA%E9%97%B4%E6%96%B9%E5%B7%AE%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>under 题解 <a href="https://www.luogu.org/problemnew/show/P5142">P5142</a></p><hr><p>题目要求维护模意义下的区间方差，显然是数据结构题。</p><span id="more"></span><p>考虑方差公式：</p><script type="math/tex; mode=display">\begin{aligned}\sigma^2 &= \frac{1}{n} \sum \limits_{i = 1}^n (x_i - \bar{x})^2 \\&= \frac{1}{n} (\sum \limits_{i = 1}^n x_i^2 - 2 \bar{x} \sum \limits_{i = 1}^nx_i + n \bar{x}^2) \\&= \frac{1}{n} (\sum \limits_{i = 1}^n x_i^2 - 2 \bar{x} \times n \bar{x} + n \bar{x}^2) \\&= \frac{1}{n} \sum \limits_{i = 1}^n x_i^2 - \bar{x}^2\end{aligned}</script><p>而算术平均数</p><script type="math/tex; mode=display">\begin{aligned} \bar{x} &= \frac{1}{n} \sum \limits_{i = 1}^n x_i \end{aligned}</script><p>可以发现，只要维护序列的<strong>区间和</strong>和<strong>区间平方和</strong>，就可以维护平均数和方差。</p><p><strong>区间和</strong>和<strong>区间平方和</strong>都<strong>满足结合律</strong>，因此可以用<strong>线段树</strong>维护。</p><hr><p>题目要求对 $ 1e9+7 $ 取模，而 $ 1e9+7 &lt; \frac{INT _ MAX}{2} $，完全可以不使用 <code>long long</code> 变量维护。</p><p><em>注：此处 MathJax 出锅，实际为 INT_MAX</em></p><p>于是写了一发代码，看看<del>毒瘤</del>真正的取模和强制类型转换<del>的大常数</del>是什么样子的：</p><p>代码(c++11) 含注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, op, x, y, s1, s2, inv, ave, ans, z[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> p = mod - <span class="number">2</span>, <span class="keyword">int</span> m = mod)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 快速幂用于费马小定理求逆元 </span></span><br><span class="line">  b %= m;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">1</span> % m;</span><br><span class="line">  <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, b = (ll)b * b % m)</span><br><span class="line">    <span class="keyword">if</span>(p &amp; <span class="number">1</span>) s = (ll)s * b % m;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> sr(x) ((ll)(x)*(x)%mod) <span class="comment">// 注意这个宏 </span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> L[<span class="number">400003</span>], R[<span class="number">400003</span>], s1[<span class="number">4000003</span>], s2[<span class="number">400003</span>];</span><br><span class="line">    <span class="comment">// s1[] 存储区间和，s2[] 存储区间平方和 </span></span><br><span class="line">    <span class="comment">// 由于无区间修改，不需要 lazytag 和 pushdown 操作 </span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    s1[p] = (s1[ls] + s1[rs]) % mod;</span><br><span class="line">    s2[p] = (s2[ls] + s2[rs]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    L[p] = l, R[p] = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">      s1[p] = z[l] % mod;</span><br><span class="line">      s2[p] = <span class="built_in">sr</span>(z[l]) % mod;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rs, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单点修改 </span></span><br><span class="line">    <span class="keyword">if</span>(L[p] == R[p]) &#123;</span><br><span class="line">      s1[p] = v % mod;</span><br><span class="line">      s2[p] = <span class="built_in">sr</span>(v) % mod;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (L[p] + R[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= m) <span class="built_in">modify</span>(ls, k, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rs, k, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 询问区间和 </span></span><br><span class="line">    <span class="keyword">if</span>(l == L[p] &amp;&amp; r == R[p]) <span class="keyword">return</span> s1[p] % mod;</span><br><span class="line">    <span class="keyword">int</span> m = (L[p] + R[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m) <span class="keyword">return</span> <span class="built_in">query1</span>(ls, l, r) % mod;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; m) <span class="keyword">return</span> <span class="built_in">query1</span>(rs, l, r) % mod;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">query1</span>(ls, l, m) + <span class="built_in">query1</span>(rs, m + <span class="number">1</span>, r)) % mod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 询问区间平方和 </span></span><br><span class="line">    <span class="keyword">if</span>(l == L[p] &amp;&amp; r == R[p]) <span class="keyword">return</span> s2[p] % mod;</span><br><span class="line">    <span class="keyword">int</span> m = (L[p] + R[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m) <span class="keyword">return</span> <span class="built_in">query2</span>(ls, l, r) % mod;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; m) <span class="keyword">return</span> <span class="built_in">query2</span>(rs, l, r) % mod;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">query2</span>(ls, l, m) + <span class="built_in">query2</span>(rs, m + <span class="number">1</span>, r)) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;z[i]);</span><br><span class="line">  SGT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(M--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>) SGT::<span class="built_in">modify</span>(<span class="number">1</span>, x, y % mod);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 以下各变量均在模意义下 </span></span><br><span class="line">      <span class="comment">// 强制类型转换 (ll) 一个也不能少！ </span></span><br><span class="line">      s1 = SGT::<span class="built_in">query1</span>(<span class="number">1</span>, x, y) % mod;    <span class="comment">// 区间和 </span></span><br><span class="line">      s2 = SGT::<span class="built_in">query2</span>(<span class="number">1</span>, x, y) % mod;    <span class="comment">// 区间平方和 </span></span><br><span class="line">      inv = <span class="built_in">qpow</span>(y - x + <span class="number">1</span>);              <span class="comment">// 区间长度（分母）的逆元 </span></span><br><span class="line">      ave = (ll)s1 * inv % mod;           <span class="comment">// 区间算术平均数 </span></span><br><span class="line">      ans = (ll)s2 * inv % mod - (ll)ave * ave % mod;</span><br><span class="line">      ans = (ans % mod + mod) % mod;      <span class="comment">// 区间方差，前文有减法操作，防止出现负数</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>后记：</p><p>故意不开 <code>long long</code> 并不是为了毒瘤，而是为了磨炼自己的基本功。</p><p>在平常的练习中把刀磨锋利，才能在考试中得心应手地使用。</p><p><del>（寓言故事草）</del></p><p>如果有错误或不懂的地方，请在私信或评论中告知我。<strong>谢谢大家！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 AT2648 【pushpush】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-AT2648-%E3%80%90pushpush%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-AT2648-%E3%80%90pushpush%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>under 题解 <a href="https://www.luogu.org/problemnew/show/AT2648">AT2648</a></p><hr><p>题目要求我们多次翻转序列，但时间复杂度显然不允许。</p><p>思考发现可以在序列首尾插入来避免翻转操作。</p><p>可以借助 STL 容器。但是该选择哪一种容器呢？</p><span id="more"></span><hr><p>以下内容部分引用自 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference</a></p><p>STL 中提供了三种支持首尾插入的容器。</p><p><strong><code>std::vector</code></strong></p><ul><li>随机访问——常数 O(1)</li><li>在末尾插入或移除元素——均摊常数 O(1)</li><li>插入或移除元素——与到 vector 结尾的距离成线性 O(n)</li></ul><p><strong><code>std::deque</code></strong></p><ul><li>随机访问——常数 O(1)</li><li>在结尾或起始插入或移除元素——常数 O(1)</li><li>插入或移除元素——线性 O(n)</li></ul><p><strong><code>std::list</code></strong></p><p><del>cppreference 并没有标注复杂度</del></p><p>list 通常实现为双向链表，因此具有类似链表的复杂度（和更大的常数）。</p><p>从实际运行来看，list 具有 O(1) 的随机插入 / 移除复杂度，但只有 O(N) 的随机访问。 <del>不就是不能随机访问吗说那么多干啥</del></p><p><a href="http://www.cppblog.com/sailing/articles/161659.html">附性能测试实验一组</a></p><hr><p>回到本题。题目需要从序列首尾插入，但不需要随机访问，因此 deque 和 list 都可以选择。为了避免常数影响，我们选择较快的 deque。</p><p>代码 (C++11) （卡到了最优解第一珂海星）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, a;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="keyword">if</span>(i &amp; <span class="number">1</span>) q.<span class="built_in">push_back</span>(a);</span><br><span class="line">    <span class="keyword">else</span> q.<span class="built_in">push_front</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(N &amp; <span class="number">1</span>) <span class="built_in">reverse</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 序列长度是奇数时最后别忘了翻转</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it = q.<span class="built_in">begin</span>(); it != q.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><del>我永远喜欢 STL</del></strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 AT1157 【2015】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-AT1157-%E3%80%902015%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-AT1157-%E3%80%902015%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>under 题解 <a href="https://www.luogu.org/problemnew/show/AT1157">AT1157</a></p><span id="more"></span><hr><p><strong>题意</strong></p><p>给定数字 $N$，判断它的二进制是否是回文。</p><p>二进制？当然是用 bitset！</p><p>$O( \frac{n}{w})$ 的时空复杂度、实现了与 <code>unsigned long</code> 和 <code>std::string</code> 之间的类型转换，简直不要更好用！</p><p>直接上代码，<del>注释才是本体</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span> <span class="comment">// std::bitset 头文件 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">bitset&lt;32&gt; bit; <span class="comment">// N &lt;= 10^9，不少于 30 位 </span></span><br><span class="line">string s, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  bit = (<span class="keyword">unsigned</span>)N;</span><br><span class="line">    <span class="comment">// bitset 支持与 unsigned long 之间使用 = 运算符赋值 </span></span><br><span class="line"></span><br><span class="line">  s = r = bit.<span class="built_in">to_string</span>().<span class="built_in">substr</span>(<span class="number">32</span> - <span class="built_in">log2</span>(N));</span><br><span class="line">    <span class="comment">// 成员函数 to_string() 返回 std::string </span></span><br><span class="line">    <span class="comment">// 注意高位不足时会用 &#x27;0&#x27; 补齐，要去除高位的 &#x27;0&#x27; </span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">reverse</span>(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>());</span><br><span class="line">  cout &lt;&lt; (s == r ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// 判断并输出 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><del>我永远爱STL</del></strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半夜睡不着扯淡文学</title>
      <link href="/2003/%E5%8D%8A%E5%A4%9C%E7%9D%A1%E4%B8%8D%E7%9D%80%E6%89%AF%E6%B7%A1%E6%96%87%E5%AD%A6/"/>
      <url>/2003/%E5%8D%8A%E5%A4%9C%E7%9D%A1%E4%B8%8D%E7%9D%80%E6%89%AF%E6%B7%A1%E6%96%87%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>纯乱写的，如有雷同纯属巧合。还没写完。</p><hr><p>　　高中前两年中有一年半经常去机房，不怎么在教室呆，尤其是语文英语化学生物课果断全翘，啥都没学过。<br>　　高二下学期由于疫情晚放假了一个月，彼时我已经竞赛失败回班了。虽说失去了翘课的理由，但是还是不想上语文课，就经常去对面教室自己呆着。<br>　　那个学期的最后一天好像是七月末或八月初。下课后我赖在对面教室没回去，结果进来了杀气腾腾的语文老师🐷🍚。🐷🍚恶狠狠地恐吓我，说让我暑假把古诗文都背了，回来狠狠地提问我。<br>　　我：昂。<br>　　转头回了班里跟哥们打听背诵提问到哪了，答曰 xxx。翻开书一看下一篇，项脊轩志。得了，就从这开始背……<br>　　吗？不可能的。虽说一直没忘，但是我这 b 拖延症直到开学才开始焦虑这事。刚开学的前几天我提心吊胆，每个早读都死了命的背项脊轩志。当时满脑子都是杀了我吧这文章怎么这么难背啊。<br>　　过了一周🐷🍚开始提问了。这里有两个笑点。笑点解析 1：🐷🍚压根忘了她说要提问我的事，天天焦虑的我是小丑。笑点解析 2：山东新高考压根不考项脊轩志，不用背这篇，我是大丑。<br>　　不过🐷🍚忘了要专门提问我，这事归根结底还是我赢。</p><p>　　高三那会也不知道咋回事，每天早起晚睡还睡不着，但是就是不困。不过有个副作用是每天上午化学课都发动被动技能时间快进，上课眼一眨就下课了，不知道是不是我掌握了某种控制时间流动的技术。<br>　　问问大伙应该是闭一下眼再睁一下就算眨一次眼吧？这个定义很关键，在线等挺急的。<br>　　为了避免上化学课时间快进，我经常委托张哥给我打印歌词上课看，这样时间就不会快进了。那段时间词汇量真是突飞猛进，可惜是日语词汇量，高考用不着。不过这操作也不是百利无害的，明显的坏处一是化学还是一点不会，二是白天也开始犯困了。</p><p>　　当时每天下午好像还比普通班提前下课去吃饭。光记得一到点就开冲，捎带着烦恼一下今天该吃什么了。唉不得不说高中那破烂食堂比北邮还是稍微强点。<br>　　实验一班男同学们凝聚力还是相当的强的，并且也很有默契，经常能在同一个食堂碰头，然后全坐在一起。有段时间食堂桌子好像能搬动，当时四张桌子拼一块坐了将近二十个人，全班一共也就才 24 个男生。我吃饭贼慢，每次都几乎耗满 30 分钟晚饭时间，最后一个踩点回去。<br>　　晚自习的云彩总是很好看，偶尔还有粉色或者紫色的那种晚霞，很像 b 站那种回忆青春的视频里那样式的，特别适合对着窗外愣神。文学水平不太好光会说好看了，得整点活。哦对，scenery 美晚霞。<br>　　晚自习八点半下课是一整天最爽的时候。一方面刚刚结束的一节两小时超长晚自习已经很爽了，另一方面后面还有一个更爽的超长晚自习。这个课间恰好凉快且不困，出门走两步相当舒服，大伙唠逼磕也都状态很好。<br>　　当时还有一个重要的休闲活动。级部认为从其他地方请高级老师来开讲座能够大幅提高成绩。我们当然是非常支持的，因为这样就不用上正常的课了，可以去大会议厅摸鱼，啊不是，学习更加先进的知识。当时每次整这个活就意味着我要吃早饭了。我每次都让君君给我带个摊煎饼，香得嘛不谈。名师们还是能带来一些梗的，比如有个山西来的语文老师（好像姓高？）把费县叫成了费城，极大地增强了大伙的地域自豪感。</p><p>　　老段找我谈话。说小杜啊，你回来上了半个学期的课了成绩也没起色，一直县 30 名上不去下不来，卡在这里了。是不是上课没跟着老师走啊？<br>　　我寻思着我一二年级没处理好，一直没上文化课，现在跟着老师直接一轮复习根本跟不上。我倒是想自学，但是你一直让我跟，我就认真跟了。成绩不好你又怪我？<br>　　老段对我进行了严厉批评，我自然也不太服气。老段认为我一定是没认真跟老师进度，要求我必须跟上，我说 ok。这次会晤后我立即形成个人决议，不再理会任何老师的复习进度。</p><p>　　过了半年，还剩一个来月高考了，老段又找我谈话。说你小子最近不错啊，一直考前几，是不是上次听我的认真跟进度奏效了？<br>　　我心想我他妈从那开始一句课没听过纯自学的，搞半天还是我自己来靠谱，老师真不行吧。并且我都回来 9 个月了，自学一遍高中文化课考县前 5 难度不大吧。你这么看不起我？<br>　　我说嘿嘿，啊对，还是您给的思路好，这么保持下去高考应该挺不错的。他说你看看，早不听我的，不然成绩不是更好了，你小子赶紧回去好好学习吧，哈哈，高考考好点啊。<br>　　我就笑么乎地走了。边走边想什么 b 玩意，真听你的我早翻车了，趁早收拾收拾复读吧。</p><hr><p>没写完。下次睡不着的时候再说吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo!</title>
      <link href="/1999/Hello-Hexo/"/>
      <url>/1999/Hello-Hexo/</url>
      
        <content type="html"><![CDATA[<p>这是 Hexo 博客自带的使用说明。</p><span id="more"></span><hr><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
