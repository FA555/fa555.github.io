<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="某 AtCoder 的 dp 场"><meta name="keywords" content=""><meta name="author" content="fa_555"><meta name="copyright" content="fa_555"><title>某 AtCoder 的 dp 场 | fa_555's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 7.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%B9%E3%83%88"><span class="toc-number">1.</span> <span class="toc-text">A - コンテスト</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem"><span class="toc-number">1.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution"><span class="toc-number">1.2.</span> <span class="toc-text">solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E3%82%B2%E3%83%BC%E3%83%A0"><span class="toc-number">2.</span> <span class="toc-text">B - ゲーム</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-1"><span class="toc-number">2.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-1"><span class="toc-number">2.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code"><span class="toc-number">2.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E3%83%88%E3%83%BC%E3%83%8A%E3%83%A1%E3%83%B3%E3%83%88"><span class="toc-number">3.</span> <span class="toc-text">C - トーナメント</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-2"><span class="toc-number">3.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-2"><span class="toc-number">3.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-1"><span class="toc-number">3.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E3%82%B5%E3%82%A4%E3%82%B3%E3%83%AD"><span class="toc-number">4.</span> <span class="toc-text">D - サイコロ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-3"><span class="toc-number">4.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-3"><span class="toc-number">4.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-2"><span class="toc-number">4.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">E - 数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-4"><span class="toc-number">5.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-4"><span class="toc-number">5.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-3"><span class="toc-number">5.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E6%BA%96%E6%80%A5"><span class="toc-number">6.</span> <span class="toc-text">F - 準急</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-5"><span class="toc-number">6.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-5"><span class="toc-number">6.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-4"><span class="toc-number">6.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-%E8%BE%9E%E6%9B%B8%E9%A0%86"><span class="toc-number">7.</span> <span class="toc-text">G - 辞書順</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-6"><span class="toc-number">7.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-6"><span class="toc-number">7.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-5"><span class="toc-number">7.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-%E3%83%8A%E3%83%83%E3%83%97%E3%82%B6%E3%83%83%E3%82%AF"><span class="toc-number">8.</span> <span class="toc-text">H - ナップザック</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-7"><span class="toc-number">8.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-7"><span class="toc-number">8.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-6"><span class="toc-number">8.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E3%82%A4%E3%82%A6%E3%82%A3"><span class="toc-number">9.</span> <span class="toc-text">I - イウィ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-8"><span class="toc-number">9.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-amp-code-1"><span class="toc-number">9.2.</span> <span class="toc-text">solution &amp; code 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-amp-code-2"><span class="toc-number">9.3.</span> <span class="toc-text">solution &amp; code 2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-%E3%83%9C%E3%83%BC%E3%83%AB"><span class="toc-number">10.</span> <span class="toc-text">J - ボール</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-9"><span class="toc-number">10.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-10"><span class="toc-number">10.2.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-7"><span class="toc-number">10.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-%E3%82%BF%E3%83%BC%E3%82%B2%E3%83%83%E3%83%88"><span class="toc-number">11.</span> <span class="toc-text">K - ターゲット</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-11"><span class="toc-number">11.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-8"><span class="toc-number">11.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-8"><span class="toc-number">11.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L-%E7%8C%AB"><span class="toc-number">12.</span> <span class="toc-text">L - 猫</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-12"><span class="toc-number">12.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-9"><span class="toc-number">12.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-9"><span class="toc-number">12.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M-%E5%AE%B6"><span class="toc-number">13.</span> <span class="toc-text">M - 家</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-13"><span class="toc-number">13.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-10"><span class="toc-number">13.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-10"><span class="toc-number">13.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N-%E6%9C%A8"><span class="toc-number">14.</span> <span class="toc-text">N - 木</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-14"><span class="toc-number">14.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-11"><span class="toc-number">14.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-11"><span class="toc-number">14.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-%E6%96%87%E5%AD%97%E5%88%97"><span class="toc-number">15.</span> <span class="toc-text">O - 文字列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-15"><span class="toc-number">15.1.</span> <span class="toc-text">problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-12"><span class="toc-number">15.2.</span> <span class="toc-text">solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-12"><span class="toc-number">15.3.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P-%E3%81%86%E3%81%AA%E3%81%8E"><span class="toc-number">16.</span> <span class="toc-text">P - うなぎ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#problem-16"><span class="toc-number">16.1.</span> <span class="toc-text">problem</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars.githubusercontent.com/u/29965600"></div><div class="author-info__name text-center">fa_555</div><div class="author-info__description text-center">夢の続きを知りたいのかい？</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/111890">Luogu</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">31</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/FA555">Github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://codeforces.com/profile/fa_555">Codeforces</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/files/topimg/johannes-plenio-E-Zuyev2XWo-unsplash.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">fa_555's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">文章</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/links">友链</a></span></div><div id="post-info"><div id="post-title">某 AtCoder 的 dp 场</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-22</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 28 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><del>Typical DP Contest，13 年的远古比赛了</del></p>
<p><a target="_blank" rel="noopener" href="https://tdpc.contest.atcoder.jp/">比赛地址</a></p>
<p>本文为部分翻译+题解</p>
<p>谷的翻译大部分（所有正确使用了 $\LaTeX$ 的）是我搞的。很惭愧，就做了一点微小的贡献。</p>
<span id="more"></span>
<hr>
<h3 id="A-コンテスト"><a href="#A-コンテスト" class="headerlink" title="A - コンテスト"></a>A - コンテスト</h3><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><p>有一场有 $n \ (1 \le n \le 100)$ 个问题的比赛，其中第 $i$ 个问题的分数为 $p_i \ (1 \le p_i \le 100)$。某个参赛者的分数为他做出的题目的分数之和。有多少种可能的得分？</p>
<h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>傻逼背包，连优化都不用的那种（</p>
<hr>
<h3 id="B-ゲーム"><a href="#B-ゲーム" class="headerlink" title="B - ゲーム"></a>B - ゲーム</h3><h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h4><p>Alice 和 Bob 在玩游戏。初始时有两座山，左边的山上有 $A$ 个物品，从上到下的第 $i$ 个价值为 $a_i$；右边的山上有 $B$ 个物品，从上到下的第 $i$ 个价值为 $b_i$。Alice 先手，Alice 和 Bob 交替进行操作，可行的操作如下：</p>
<ul>
<li>如果两座山都空了，游戏结束。</li>
<li>如果只有某一座山空了，取走另一座山上的最上面的物品。</li>
<li>如果两座山都没有空，选择任意一座山，并取走其最上面的物品。</li>
</ul>
<p>两人都想取得更大的价值。假设两人都采取最优策略，请求出 Alice 能取得的物品的价值总和。</p>
<p>输入的所有数字都是 $[1, 1000]$ 中的整数。</p>
<h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>考虑从终局向前逆推。设 $f_{i, j}$ 表示 $A$ 被取走第 $i \sim A$ 个物品， $B$ 被取走第 $j \sim B$ 个物品时的价值。</p>
<p>对 $i + j$ 为偶数/奇数，即 Alice/Bob 操作时分类转移：</p>
<script type="math/tex; mode=display">
f_{i, j} = \begin{cases}
\max(f_{i + 1, j} + a_i, f_{i, j + 1} + b_j) & , (i + j) \equiv 0 \pmod 2 \\
\min(f_{i + 1, j}, f_{i, j + 1}) & , (i + j) \equiv 1 \pmod 2
\end{cases}</script><p>边界条件 $f_{i, B + 1} = f_{A + 1, j} = 0$。</p>
<p>答案即为 $f_{1, 1}$。总复杂度 $O(AB)$。</p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>实现时要尤其注意边界情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">1003</span>][<span class="number">1003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span>* a, <span class="keyword">int</span> B, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// a, b 下标均从 1 开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = A + <span class="number">1</span>; i; --i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = B + <span class="number">1</span>; j; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; A &amp;&amp; j &gt; B) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; A)</span><br><span class="line">          f[i][j] = f[i][j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; B)</span><br><span class="line">          f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          f[i][j] = std::<span class="built_in">min</span>(f[i + <span class="number">1</span>][j], f[i][j + <span class="number">1</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; A)</span><br><span class="line">          f[i][j] = f[i][j + <span class="number">1</span>] + b[j];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; B)</span><br><span class="line">          f[i][j] = f[i + <span class="number">1</span>][j] + a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          f[i][j] = std::<span class="built_in">max</span>(f[i + <span class="number">1</span>][j] + a[i], f[i][j + <span class="number">1</span>] + b[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> f[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="C-トーナメント"><a href="#C-トーナメント" class="headerlink" title="C - トーナメント"></a>C - トーナメント</h3><h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h4><p>有 $2^k \ (1 \le k \le 10)$ 人参加一场锦标赛，这场锦标赛按以下的形式进行。</p>
<p><em>译者注：我知道可读性很差，但是很好理解，日语原题面就是这样的</em></p>
<ul>
<li>第 1 轮，1 和 2，3 和 4，… 进行比赛。</li>
<li>第 2 轮，(1 和 2 的胜者)和(3 和 4 的胜者)，(5 和 6 的胜者)和(7 和 8 的胜者)，… 进行比赛。</li>
<li>第 3 轮，((1 和 2 的胜者)和(3 和 4 的胜者)的胜者)和((5 和 6 的胜者)和(7 和 8 的胜者)的胜者)，((9 和 10 的胜者)和(11 和 12 的胜者)的胜者)和((13 和 14 的胜者)和(15 和 16 的胜者)的胜者)，… 进行比赛。</li>
<li>重复相同的过程，直到第 $K$ 轮。</li>
</ul>
<p>第 $K$ 轮结束后将会决出优胜者。如果第 $i$ 个人的 Elo Rating 为 $R_i \ (1 \le R_i \le 4000)$，求出每个人成为优胜者的概率。</p>
<p>规定：如果 Elo Rating 为 $R_P$ 的人 $P$ 和 Elo Rating 为 $R_Q$ 的人 $Q$ 对战，人 $P$ 的获胜概率为 $1 / (1 + 10^{(R_Q - R_P) / 400})$。假设不同的比赛的胜负是互相独立的。</p>
<h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>显然是道概率 dp（</p>
<p>设 $f_{k, i}$ 表示第 $k$ 轮比赛中第 $i$ 个人获胜的概率。不难得到这样的转移方程：</p>
<script type="math/tex; mode=display">
f_{k, i} = f_{k - 1, i} \times \sum_{j \in S}{(f_{k - 1, j} \times P)}</script><p>其中 $S$ 表示第 $k$ 轮中可能与 $i$ 比赛的人；$P$ 表示第 $j$ 个人此时获胜的概率。</p>
<p>边界条件 $f_{i, 0} = 1$。</p>
<p>答案即为 $f_{K, i} \ (1 \le i \le 2^K)$。总复杂度 $O(K \times 2^K)$。</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> db = <span class="keyword">double</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R[<span class="number">1</span>&lt;&lt;<span class="number">10</span>|<span class="number">1</span>];</span><br><span class="line">db f[<span class="number">11</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>|<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">calc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + <span class="built_in">pow</span>(<span class="number">10.</span>, (R[q] - R[p]) / <span class="number">400.</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> K, N;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; K;</span><br><span class="line">  N = <span class="number">1</span> &lt;&lt; K;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    cin &gt;&gt; R[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, len; k &lt;= K; ++k) &#123;</span><br><span class="line">    len = <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, mn, mx, mid, l, r; i &lt;= N; ++i) &#123;</span><br><span class="line">      db now = <span class="number">0</span>;</span><br><span class="line">      mx = (i - <span class="number">1</span>) / len * len + len, mn = mx - len + <span class="number">1</span>;</span><br><span class="line">      mid = ((mn + mx) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i &lt; mid) l = mid, r = mx;</span><br><span class="line">      <span class="keyword">else</span> l = mn, r = mid - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 此处的 l ~ r 为可能此时和第 j 个人比赛的编号区间</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; ++j)</span><br><span class="line">        now += f[k - <span class="number">1</span>][j] * <span class="built_in">calc</span>(i, j);</span><br><span class="line">      f[k][i] = now * f[k - <span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>, f[K][i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="D-サイコロ"><a href="#D-サイコロ" class="headerlink" title="D - サイコロ"></a>D - サイコロ</h3><h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem"></a>problem</h4><p>将六个面的骰子掷 $N \ (1 \le N \le 100)$ 次，求每一次掷得的点数的乘积是 $D \ (1 \le D \le 10^{18})$ 的倍数的概率。</p>
<h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>考虑骰子掷出点数的乘积的质因子只可能有 $2, 3, 5$。考虑直接从这三个因数进行转移。</p>
<p>设 $f_{i, a, b, c}$ 表示第 $i$ 次掷骰子后点数的乘积中因子 $2$ 有 $a$ 个，$3$ 有 $b$ 个，$5$ 有 $c$ 个的可能性。</p>
<p>直接枚举每次掷骰子的过程转移即可。</p>
<p>边界条件 $f_{0, 0, 0, 0} = 1$。</p>
<p>答案即为 $f_{N, a, b, c}$。总复杂度 $O(Nabc)$。</p>
<h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><p>实现看了看霓虹国神仙 Suikaba 的（小声</p>
<p>这个 dp 数组甚至可以滚动数组压掉一维，不过这里没写。</p>
<p>变量名和上文略有不同。数组大小奇怪是因为是压着上界开的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> s2[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> s3[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> s5[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> f[<span class="number">101</span>][<span class="number">61</span>][<span class="number">39</span>][<span class="number">27</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">long</span> <span class="keyword">long</span> D)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> d2 = <span class="number">0</span>, d3 = <span class="number">0</span>, d5 = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (D % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    D /= <span class="number">2</span>, ++d2;</span><br><span class="line">  <span class="keyword">while</span> (D % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">    D /= <span class="number">3</span>, ++d3;</span><br><span class="line">  <span class="keyword">while</span> (D % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    D /= <span class="number">5</span>, ++d5;</span><br><span class="line">  <span class="keyword">if</span> (D != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt;= d2; ++i2)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i3 = <span class="number">0</span>; i3 &lt;= d3; ++i3)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i5 = <span class="number">0</span>; i5 &lt;= d5; ++i5)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t2, t3, t5; j &lt;= <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            t2 = <span class="built_in">min</span>(d2, i2 + s2[j]);</span><br><span class="line">            t3 = <span class="built_in">min</span>(d3, i3 + s3[j]);</span><br><span class="line">            t5 = <span class="built_in">min</span>(d5, i5 + s5[j]);</span><br><span class="line">            f[i + <span class="number">1</span>][t2][t3][t5] += f[i][i2][i3][i5] / <span class="number">6</span>;</span><br><span class="line">          &#125;</span><br><span class="line">  <span class="keyword">return</span> f[N][d2][d3][d5];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="E-数"><a href="#E-数" class="headerlink" title="E - 数"></a>E - 数</h3><h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem"></a>problem</h4><p>求出在 $1 \sim N$ 中有多少个整数的数码和是 $D$ 的倍数。答案对 $10^9 + 7$ 取模。</p>
<h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h4><p>这里是一篇记忆化搜索实现数位 dp 的题解。</p>
<p>设 $f_{i, j}$ 为最低位到从低到高第 $i$，模 $D$ 余数为 $j$ 时的合法方案数。</p>
<p>考虑搜索转移，深搜函数原型 <code>int dfs(int pos, int rem, bool lim)</code>，其中 <code>pos</code> 表示当前在从低到高第 <code>pos</code> 位，要搜索的余数为 <code>rem</code>，是否贴紧原数上界（<code>lim == 1/0</code>）。转移时按照含义即可。</p>
<p>注意有些题目需要特判前导零、考虑连续的几位数等特殊情况（本题不需要）。</p>
<p>dp 数组初始值要为一个小于零的数（想一想，为什么？）</p>
<h4 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h4><p>理论上记忆化搜索实现要比递推转移常数大一点，但就这题来看这份代码跑得比大多数递推还要快（</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, D, num[<span class="number">10003</span>], f[<span class="number">10003</span>][<span class="number">101</span>];</span><br><span class="line">std::string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> rem, <span class="keyword">bool</span> lim)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!pos) <span class="keyword">return</span> !rem;</span><br><span class="line">  <span class="keyword">if</span> (!lim &amp;&amp; f[pos][rem] != <span class="number">-1</span>) <span class="keyword">return</span> f[pos][rem];</span><br><span class="line">  <span class="keyword">int</span> mx = lim ? num[pos] : <span class="number">9</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mx; ++i)</span><br><span class="line">    ans = (ans + <span class="built_in">dfs</span>(pos - <span class="number">1</span>, (rem + i) % D, lim &amp;&amp; i == mx)) % mod;</span><br><span class="line">  <span class="keyword">if</span> (!lim) f[pos][rem] = ans;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; D &gt;&gt; s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">rbegin</span>(); it != s.<span class="built_in">rend</span>(); ++it)</span><br><span class="line">    num[++N] = *it &amp; <span class="number">15</span>;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">dfs</span>(N, <span class="number">0</span>, <span class="number">1</span>) - <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="F-準急"><a href="#F-準急" class="headerlink" title="F - 準急"></a>F - 準急</h3><h4 id="problem-5"><a href="#problem-5" class="headerlink" title="problem"></a>problem</h4><p>有一条有 $N$ 个站的电车线路。你要在这条线路上送外卖。</p>
<ul>
<li>你需要在 $1$ 号站停靠，在 {$2$ 号站，…，$N - 1$ 号站} 的子集停靠，在 $N$ 号站停靠。</li>
<li>你不会在连续超过 $K$ 个车站停靠。</li>
</ul>
<p>求有多少种可能的停靠方案数。答案对 $10^9 + 7$ 取模。</p>
<h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h4><p>设 $f_{i, 0/1}$ 表示前 $i$ 个车站不停靠/停靠的方案数。显然有 $f_{i, 0} = f_{i - 1, 0} + f_{i - 1, 1}$。</p>
<p>对于 $f_{i, 1}$，需要减去不合法的方案数，即前 $K - 1$ 个车站都停靠的方案数。<del>显然</del>这个等于 $f_{i - K, 0}$。</p>
<p>边界条件 $f_{0, 0} = f_{0, 1} = f_{1, 1} = 1, f_{1, 0} = 0$。</p>
<p>答案即为 $f_{N, 1}$。总复杂度 $O(N)$。</p>
<h4 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1000003</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; K; ++i)</span><br><span class="line">    f[i][<span class="number">0</span>] = f[i][<span class="number">1</span>] = (f[i - <span class="number">1</span>][<span class="number">0</span>] + f[i - <span class="number">1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt;= N; ++i) &#123;</span><br><span class="line">    f[i][<span class="number">0</span>] = f[i][<span class="number">1</span>] = (f[i - <span class="number">1</span>][<span class="number">0</span>] + f[i - <span class="number">1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">    f[i][<span class="number">1</span>] = (f[i][<span class="number">1</span>] - f[i - K][<span class="number">0</span>] + mod) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[N][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="G-辞書順"><a href="#G-辞書順" class="headerlink" title="G - 辞書順"></a>G - 辞書順</h3><h4 id="problem-6"><a href="#problem-6" class="headerlink" title="problem"></a>problem</h4><p>求字符串 $s \ (1 \le |s| \le 10^6)$ 的字典序第 $K \ (1 \le K \le 10^{18})$ 小的非空<strong>子序列</strong>或判断不存在。相同的子序列只计算一次。字符集小写拉丁字母。</p>
<h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h4><blockquote>
<p>と，色々書いたけどわかりにくい解説だな…．<br>自分もかなり苦手な問題なので…．<br>—— Suikaba 的原话</p>
</blockquote>
<p>看了 Suikaba 神仙的题解，尝试来自己胡一胡（</p>
<p>设 $\mathrm{nxt}_{i, c}$ 为 $s$ 中第 $i$ 个位置之后第一个出现 $c$ 的位置；$f_i$ 为使用第 $i$ 个位置的字符，其后子序列的个数。那么有</p>
<script type="math/tex; mode=display">
f_i = 1 + \sum_{c \in |T|} f_{\mathrm{nxt}_{i, c}}</script><p>其中 $T$ 表示字符集。加上的 $1$ 表示当前字符单独成串。</p>
<p>考虑如何找到字典序第 $K$ 小的集合。设一个向后跳的指针，初始指向字符串起始位置。从小到大枚举 $T$ 中的字符，向后边跳指针边统计答案即可。实现细节见代码。</p>
<h4 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">1000003</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">1000003</span>][<span class="number">27</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> K, f[<span class="number">1000003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld&quot;</span>, s + <span class="number">1</span>, &amp;K);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  std::<span class="built_in">fill</span>(nxt[N + <span class="number">1</span>] + <span class="number">1</span>, nxt[N + <span class="number">1</span>] + <span class="number">27</span>, N + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(nxt[i] + <span class="number">1</span>, nxt[i + <span class="number">1</span>] + <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * <span class="number">26</span>);</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++j) &#123;</span><br><span class="line">      f[i] += f[nxt[i][j]];</span><br><span class="line">      f[i] = std::<span class="built_in">min</span>(f[i], K + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nxt[i][s[i] &amp; <span class="number">31</span>] = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> g = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i, p = <span class="number">1</span>; K &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i)</span><br><span class="line">      <span class="keyword">if</span> (f[nxt[p][i]] &lt; K)</span><br><span class="line">        K -= f[nxt[p][i]];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        --K;</span><br><span class="line">        p = nxt[p][i] + <span class="number">1</span>;</span><br><span class="line">        g = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(i - <span class="number">1</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">26</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(g ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;Eel&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="H-ナップザック"><a href="#H-ナップザック" class="headerlink" title="H - ナップザック"></a>H - ナップザック</h3><h4 id="problem-7"><a href="#problem-7" class="headerlink" title="problem"></a>problem</h4><p>有 $U \ (1 \le U \le 100)$ 个物品，第 $i$ 个的质量、价值、颜色分别为 $w_i, v_i, c_i \ (1 \le w_i, v_i \le 10000, 1 \le c_i \le 50)$。有一个背包，能容纳总质量为 $W \ (1 \le W \le 10000)$，颜色种类数为 $C \ (1 \le C \le 50)$ 的物品。求能容纳的物品的最大总价值。</p>
<h4 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h4><p>设 $f_{i, j}$ 表示使用不超过 $i$ 种颜色，总质量为 $j$ 时的最大价值。</p>
<p>需要枚举颜色个数和所有颜色，以每个颜色为整体进行转移。</p>
<p>转移时直接套用 01 背包转移方程 $F_i = max{\{F_{i - w_j} + v_j\}}$ 即可。其中 $F$ 代表 $f$ 的第一维。</p>
<p>初始状态 $f_{i, j} = - \infty, f_{0, 0} = 0$。</p>
<p>答案即为 $\max{\{f_{C, i}\}}$。总复杂度 $O(UCW)$，不过常数很小。</p>
<h4 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> w, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10003</span>], f[<span class="number">53</span>][<span class="number">10003</span>];</span><br><span class="line">vector&lt;Node&gt; z[<span class="number">53</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, W, C;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N &gt;&gt; W &gt;&gt; C;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, w, v, c; i &lt;= N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; w &gt;&gt; v &gt;&gt; c;</span><br><span class="line">    z[c].<span class="built_in">push_back</span>(&#123;w, v&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0xc0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">50</span>; ++c)</span><br><span class="line">    <span class="keyword">if</span> (z[c].<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = C; i; --i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(t, f[i - <span class="number">1</span>], <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (W + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (Node x : z[c])</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= x.w; --j)</span><br><span class="line">            t[j] = <span class="built_in">max</span>(t[j], t[j - x.w] + x.v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; ++j)</span><br><span class="line">          f[i][j] = <span class="built_in">max</span>(f[i][j], t[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  cout &lt;&lt; *<span class="built_in">max_element</span>(f[C], f[C] + W + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="I-イウィ"><a href="#I-イウィ" class="headerlink" title="I - イウィ"></a>I - イウィ</h3><h4 id="problem-8"><a href="#problem-8" class="headerlink" title="problem"></a>problem</h4><p>给定一个仅由字符 $\texttt{i}$ 和 $\texttt{w}$ 构成的字符串 $s \ (1 \le |s| \le 300)$。你可以进行若干次操作，每次从串中选取连续的三个字符 $\texttt{iwi}$ 并删除。删除后这三个字符的左侧和右侧会连接在一起，得到一个长度比原来小 $3$ 的新串。求可能的最大操作次数。</p>
<h4 id="solution-amp-code-1"><a href="#solution-amp-code-1" class="headerlink" title="solution &amp; code 1"></a>solution &amp; code 1</h4><p>设 $f_{l, r}$ 表示 $s$ 的子串 $s_{l..r}$ 的答案。这个可以直接枚举分界点 $m \in [l, r)$ 分治转移。</p>
<p>套上记忆化，总复杂度是 $O(n^2)$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">303</span>][<span class="number">303</span>];</span><br><span class="line">std::string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// [l, r]</span></span><br><span class="line">  <span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (f[l][r] != <span class="number">-1</span>) <span class="keyword">return</span> f[l][r];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = l; m &lt; r; ++m) &#123;</span><br><span class="line">    ans = std::<span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(l, m) + <span class="built_in">dfs</span>(m + <span class="number">1</span>, r));</span><br><span class="line">    <span class="keyword">if</span> (s[l] == <span class="string">&#x27;i&#x27;</span> &amp;&amp; s[m] == <span class="string">&#x27;w&#x27;</span> &amp;&amp; s[r] == <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dfs</span>(l + <span class="number">1</span>, m - <span class="number">1</span>) == m - l - <span class="number">1</span> &amp;&amp; <span class="built_in">dfs</span>(m + <span class="number">1</span>, r - <span class="number">1</span>) == r - m - <span class="number">1</span>)</span><br><span class="line">        ans = r - l + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[l][r] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="solution-amp-code-2"><a href="#solution-amp-code-2" class="headerlink" title="solution &amp; code 2"></a>solution &amp; code 2</h4><p>其实这题大可不必 dp。考虑删去一个串 $\texttt{iwi}$ 后当且仅当它的左侧或右侧是 $\texttt{i}$ 才有可能出现一个新的串 $\texttt{iwi}$。</p>
<p>可以首先删去所有的 $\texttt{iwii}$ 和 $\texttt{iiwi}$ 的子串 $\texttt{iwi}$。</p>
<p>总复杂度也是 $O(n^2)$，带一个很小的常数<del>，具体多小取决于数据强度</del>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> N = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string::size_type p = <span class="number">0</span>; ; )</span><br><span class="line">    <span class="keyword">if</span> ((p = s.<span class="built_in">find</span>(<span class="string">&quot;iiwi&quot;</span>)) != std::string::npos)</span><br><span class="line">      s.<span class="built_in">erase</span>(p + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((p = s.<span class="built_in">find</span>(<span class="string">&quot;iwii&quot;</span>)) != std::string::npos)</span><br><span class="line">      s.<span class="built_in">erase</span>(p, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string::size_type p = <span class="number">0</span>; (p = s.<span class="built_in">find</span>(<span class="string">&quot;iwi&quot;</span>, p)) != std::string::npos; )</span><br><span class="line">    s.<span class="built_in">erase</span>(p, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (N - s.<span class="built_in">size</span>()) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="J-ボール"><a href="#J-ボール" class="headerlink" title="J - ボール"></a>J - ボール</h3><h4 id="problem-9"><a href="#problem-9" class="headerlink" title="problem"></a>problem</h4><p>有 $N \ (1 \le N \le 16)$ 个物品，其中第 $i$ 个在 $x_i \ (0 \le x_i \le 15)$ 坐标处。向坐标 $x$ 扔球时，分别有 $\frac{1}{3}$ 的概率击中坐标 $x - 1, x, x + 1$ 中的一个；如果打中的坐标上有物品，将其打倒。求出在最优策略下期望扔球多少次将所有物品打倒。保证 $x_i$ 两两不同。</p>
<p>赛时补充：<strong>每次扔球时可以先看到上一次扔球击中的位置再决定向哪里扔球。</strong></p>
<h4 id="problem-10"><a href="#problem-10" class="headerlink" title="problem"></a>problem</h4><p>看到这个数据范围，盲猜状压。</p>
<p>设 $E(S)$ 为状态 $S$ 时的期望次数。考虑如何转移。一般这种题需要列出一个关于 $E(S)$ 的方程，把它反解出来。</p>
<p>考虑向 $x$ 扔球的情况，能列出这样的一个方程：</p>
<script type="math/tex; mode=display">
E(S) = 1 + \sum{(P(u) \times E(T))} + (1 - \sum{P(u)}) \times E(S)</script><p>其中 $P(x) = \frac{1}{3}$ 表示击中坐标 $x$ 的概率，$u \in \{x - 1, x, x + 1 \}$，<code>T = S &amp; ~u</code>。化简可得</p>
<script type="math/tex; mode=display">
E(S) = \frac{1 + \sum{(P(u) \times E(T))}}{\sum P(u)}</script><p>就可以枚举 $x$ 进行转移了。</p>
<p>显然可以记忆化一下。设 $f_S = E(S)$，初始状态 $f_0 = 0$。</p>
<p>答案即为 $E(S)$。总复杂度 $O(N \times 2^N)$。</p>
<h4 id="code-7"><a href="#code-7" class="headerlink" title="code"></a>code</h4><p>代码可能换了一些奇怪的写法，但是跟上面式子是等价的（</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> f[<span class="number">1</span>&lt;&lt;<span class="number">16</span>|<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (f[S] &gt;= <span class="number">0.</span>) <span class="keyword">return</span> f[S];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> ans = <span class="number">1</span> &lt;&lt; <span class="number">16</span>, E;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, c; x &lt; <span class="number">16</span>; ++x) &#123;</span><br><span class="line">    <span class="keyword">int</span> T[] = &#123;</span><br><span class="line">      S &amp; ~((<span class="number">1</span> &lt;&lt; x) &lt;&lt; <span class="number">1</span>),</span><br><span class="line">      S &amp; ~(<span class="number">1</span> &lt;&lt; x),</span><br><span class="line">      S &amp; ~((<span class="number">1</span> &lt;&lt; x) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    c = <span class="number">0</span>, E = <span class="number">1.</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">      <span class="keyword">if</span> (S != T[i])</span><br><span class="line">        E += <span class="built_in">dfs</span>(T[i]) / <span class="number">3.</span>, ++c;</span><br><span class="line">    ans = std::<span class="built_in">min</span>(ans, <span class="number">3</span> * E / c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[S] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, S = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">  std::<span class="built_in">fill</span>(f + <span class="number">1</span>, f + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>), <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t; N; --N) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    S |= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="K-ターゲット"><a href="#K-ターゲット" class="headerlink" title="K - ターゲット"></a>K - ターゲット</h3><h4 id="problem-11"><a href="#problem-11" class="headerlink" title="problem"></a>problem</h4><p>对于一个含 $K$ 个圆的序列 $C_1, C_2, \cdots, C_K$，如果对于每个 $i$ 都有圆 $C_{i + 1}$ <strong>严格</strong>位于圆 $C_i$ 的内部，那么它们可以成为一个大小为 $K$ 的靶子。</p>
<p>平面直角坐标系里有 $N \ (1 \le N \le 10^6)$ 个圆，第 $i$ 个的圆心为 $(x_i, 0) \ (1 \le x_i \le 10^9)$，半径为 $r_i \ (1 \le r_i \le 10^9)$。选出若干个圆并重新排列构成靶子，求出可能构成的靶子的最大大小。</p>
<h4 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a>solution</h4><p>对于每个圆 $i$ 构造一个二元组 $(x_i + r_i, x_i - r_i)$，按升序排序，再对第二关键字求出最长下降子序列的长度就是答案。</p>
<p>想象一下一堆圆画在这里是什么样子的、取出合法的部分是什么样子的，这个就很显然了（</p>
<h4 id="code-8"><a href="#code-8" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100003</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[<span class="number">100003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, N_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, r; i &lt;= N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; r;</span><br><span class="line">    p[i] = &#123;x + r, x - r&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(p + <span class="number">1</span>, p + N + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  f[<span class="number">1</span>] = -p[<span class="number">1</span>].second;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (f[N_] &lt; -p[i].second) f[++N_] = -p[i].second;</span><br><span class="line">    <span class="keyword">else</span> *<span class="built_in">lower_bound</span>(f + <span class="number">1</span>, f + N_ + <span class="number">1</span>, -p[i].second) = -p[i].second;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N_);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="L-猫"><a href="#L-猫" class="headerlink" title="L - 猫"></a>L - 猫</h3><h4 id="problem-12"><a href="#problem-12" class="headerlink" title="problem"></a>problem</h4><p>有 $N \ (1 \le N \le 1000)$ 只猫，猫 $i$ 和猫 $j$ 的友好值为 $z_{i, j} \ (1 \le z_{i, j} \le 1000)$。猫的幸福度是与距离不超过 $1$ 的所有猫的友好值之和。把猫按照 $1 \sim N$ 的顺序置于一条线上（设猫 $i$ 的坐标为 $x_i$，则 $\forall i \in [1, N), x_i &lt; x_{i + 1}$）。$x_i$ 可以为任意实数。求猫的幸福度之和的最大值。</p>
<p>保证 $z_{i, i} = 0, z_{i, j} = z_{j, i}$。</p>
<h4 id="solution-9"><a href="#solution-9" class="headerlink" title="solution"></a>solution</h4><p>设 $f_{i, j} \ (j \le i)$ 表示猫 $j$ 和猫 $i$ 在 $1$ 距离以内时前 $i$ 只猫的最大幸福度（两两之间计算一次）。则</p>
<script type="math/tex; mode=display">
f_{i, j} = \max_{k = 1}^j{\{f_{i - 1, k}\}} + \sum_{l = j}^i z_{i, l}</script><p>这个转移是 $O(N)$ 的，太慢了，要想办法优化掉。</p>
<p>令 $\mathrm{mx}_{i, k} = \max_{k = 1}^j{\{f_{i - 1, k}\}}, s_{i, j} = \sum_{k = j}^i z_{i, k}$，则 $f_{i, j} = \mathrm{mx}_{i, j} + s_{i, i} - s_{i, j - 1}$，转移成了 $O(1)$ 的。</p>
<p>答案即为 $2 \times \max{\{f_{N, i}\}}$。总复杂度 $O(N^2)$。</p>
<h4 id="code-9"><a href="#code-9" class="headerlink" title="code"></a>code</h4><p>这里把三个数组都压了一维。其中 $\mathrm{mx}$ 先使用 $\mathrm{mx}_{i}$ 而后统计 $\mathrm{mx}_{i + 1}$。</p>
<p>注意这个写法下 $\mathrm{mx}_{i, 0}$ 要初始化成负无穷大。</p>
<p>这份代码目前在 AtC 是时间并列第一。空间有神仙用 <code>std::vector</code> 卡到 256KB 的，实在卡不过（</p>
<p>听说有写法还能省掉一个数组，不管了不管了.jpg</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s[<span class="number">1003</span>], mx[<span class="number">1003</span>], f[<span class="number">1003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  mx[<span class="number">0</span>] = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">      cin &gt;&gt; s[j], s[j] += s[j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">      f[j] = mx[j] + s[i] - s[j - <span class="number">1</span>];</span><br><span class="line">      mx[j] = std::<span class="built_in">max</span>(mx[j - <span class="number">1</span>], f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[i + <span class="number">1</span>] = mx[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *std::<span class="built_in">max_element</span>((f + <span class="number">1</span>, f + N + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="M-家"><a href="#M-家" class="headerlink" title="M - 家"></a>M - 家</h3><h4 id="problem-13"><a href="#problem-13" class="headerlink" title="problem"></a>problem</h4><p>一栋房子有 $H \ (2 \le H \le 10^9)$ 层，每层的结构相同，都有 $R \ (1 \le R \le 16)$ 个房间。每层的构造用矩阵 $g$ 表示。如果 $g_{i, j} = 1$，则房间 $i$ 和房间 $j$ 之间有一条双向通路。对于任意的 $h \ (1 &lt; h \le H)$ 和 $r \ (1 \le r \le R)$，可以通过 $h$ 层房间 $r$ 下楼到 $h - 1$ 层房间 $r$，不能上楼。求从 $H$ 层房间 $1$ 到 $1$ 层房间 $1$ 的不自交的路径条数。</p>
<p>保证 $g_{i, j} \in \{0, 1\}, g_{i, i} = 0, g_{i, j} = g_{j, i}$。答案对 $10^9 + 7$ 取模。</p>
<h4 id="solution-10"><a href="#solution-10" class="headerlink" title="solution"></a>solution</h4><p><del>看到大得离谱的 $H$ 直接推测矩阵+快速幂相关，看到小得离谱的 $R$ 直接推测状压相关</del></p>
<p>设矩阵 $M_{i, j}$ 表示在同一层中房间 $i$ 到房间 $j$ 的不自交的路径数。</p>
<p>这个可以状压求，设 $f_{s, i, S}$ 为从房间 $s$ 出发，经过总点集为 $S$ 到达 $i$ 的不自交的路径数。直接枚举转移没啥问题。那么 $M_{s, i} = \sum{f_{s, i, T}}$。</p>
<p>初始状态 $f_{i, s, 2^s} = 1$。</p>
<p>答案即为 $(M^H)_{0, 0}$。总复杂度 $O((2^R + \log H)R^3)$，时限 8s 足够了。</p>
<h4 id="code-10"><a href="#code-10" class="headerlink" title="code"></a>code</h4><p>对于每个 $s$，$f$ 后两维的值互相独立，可以直接去掉第一维。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _Add(<span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">  <span class="keyword">return</span> (m + n) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  m = _Add(m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> S, z[<span class="number">17</span>][<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Matrix</span>(<span class="keyword">int</span> _S, <span class="keyword">bool</span> e=<span class="number">0</span>); <span class="comment">// e=1 时构造单位矩阵</span></span><br><span class="line">  Matrix <span class="keyword">operator</span>*(Matrix rhs);</span><br><span class="line">  <span class="keyword">friend</span> Matrix <span class="keyword">operator</span>^(Matrix b, <span class="keyword">int</span> p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H, R, z[<span class="number">17</span>][<span class="number">17</span>], f[<span class="number">16</span>][<span class="number">1</span>&lt;&lt;<span class="number">16</span>|<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; H &gt;&gt; R;</span><br><span class="line">  <span class="function">Matrix <span class="title">M</span><span class="params">(R)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; R; ++j)</span><br><span class="line">      std::cin &gt;&gt; z[i][j];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; R; ++s) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[s][<span class="number">1</span> &lt;&lt; s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; <span class="number">1</span> &lt;&lt; R; ++S)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i)</span><br><span class="line">        <span class="keyword">if</span> (f[i][S]) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; R; ++j)</span><br><span class="line">          <span class="keyword">if</span> (!((S &gt;&gt; j) &amp; <span class="number">1</span>) &amp;&amp; z[i][j])</span><br><span class="line">            <span class="built_in">Add</span>(f[j][S | (<span class="number">1</span> &lt;&lt; j)], f[i][S]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i)</span><br><span class="line">      M.z[s][i] = std::<span class="built_in">accumulate</span>(f[i], f[i] + (<span class="number">1</span> &lt;&lt; R), <span class="number">0</span>, _Add);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; (M ^ H).z[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="N-木"><a href="#N-木" class="headerlink" title="N - 木"></a>N - 木</h3><h4 id="problem-14"><a href="#problem-14" class="headerlink" title="problem"></a>problem</h4><p>给定一棵 $N \ (1 \le N \le 1000)$ 个点的树。现在你有 $N$ 个点，需要重新画出这棵树。要求在连边过程中仍然是一棵树。求加边的方案数。</p>
<h4 id="solution-11"><a href="#solution-11" class="headerlink" title="solution"></a>solution</h4><p>是看的<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/ylxmf2005/solution-at690">这个神仙</a>的题解。</p>
<p>显然可以枚举每个点树形 dp 一遍。假设现在 dfs 到了点 $u$，考虑怎么转移。</p>
<p>设 $f_u$ 为以 $u$ 为根的子树的方案数，$s_u$ 为这棵子树中有多少条边。</p>
<p>从 $u$ 的儿子向上转移。假设现在处理到 $v$，需要在当前的加边序列中<strong>相对顺序不变地</strong>加入 $v$ 子树中的边。也即 <code>s[u] += s[v], f[u] = f[u] * f[v] * C(s[u], s[v])</code>。</p>
<p>最终答案是以每个点为根时的答案总和的一半，因为每条边会被两个端点计算一次，导致方案两两本质相同。</p>
<p>预处理出组合数，总复杂度 $O(n^2)$。</p>
<h4 id="code-11"><a href="#code-11" class="headerlink" title="code"></a>code</h4><p>代码中 <code>siz[]</code> 即为上文的 $s$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>, inv2 = <span class="number">500000004</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1003</span>], siz[<span class="number">1003</span>], head[<span class="number">1003</span>], C[<span class="number">1003</span>][<span class="number">1003</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; e[<span class="number">2003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  f[u] = <span class="number">1</span>, siz[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((v = e[i].to) == t) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    siz[u] += siz[v];</span><br><span class="line">    f[u] = <span class="number">1ll</span> * f[u] * f[v] % mod * C[siz[u]][siz[v]] % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  ++siz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; N; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="built_in">addEdge</span>(u, v), <span class="built_in">addEdge</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    C[i][<span class="number">0</span>] = C[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">      C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">    ans = (ans + f[i]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span> * ans * inv2 % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="O-文字列"><a href="#O-文字列" class="headerlink" title="O - 文字列"></a>O - 文字列</h3><h4 id="problem-15"><a href="#problem-15" class="headerlink" title="problem"></a>problem</h4><p>构造一个小写字母构成的字符串，其中字母 $\alpha$ 出现了 $z_\alpha \ (0 \le z_\alpha \le 10)$ 次，且相同字母不相邻。求构造方案数。答案对 $10^9 + 7$ 取模。</p>
<h4 id="solution-12"><a href="#solution-12" class="headerlink" title="solution"></a>solution</h4><p>抄了<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/ylxmf2005/solution-at693">这里</a>。</p>
<h4 id="code-12"><a href="#code-12" class="headerlink" title="code"></a>code</h4><p>c++14。和题解的略有不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _Add(<span class="keyword">int</span> m, <span class="keyword">int</span> n);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;m, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> z[<span class="number">27</span>], f[<span class="number">27</span>][<span class="number">263</span>], C[<span class="number">263</span>][<span class="number">263</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">26</span>, t; i; --i) &#123;</span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">if</span> (t) z[++N] = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">260</span>; ++i) &#123;</span><br><span class="line">    C[i][<span class="number">0</span>] = C[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">      C[i][j] = _Add(C[i - <span class="number">1</span>][j - <span class="number">1</span>], C[i - <span class="number">1</span>][j]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> l = z[<span class="number">1</span>];</span><br><span class="line">  f[<span class="number">1</span>][z[<span class="number">1</span>] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; l; ++k)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= std::<span class="built_in">min</span>(z[i], k); ++b)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>, j; a + b &lt;= z[i] &amp;&amp; a &lt;= l + <span class="number">1</span> - k; ++a) &#123;</span><br><span class="line">          j = k - b + z[i] - a - b;</span><br><span class="line">          <span class="built_in">Add</span>(f[i][j], <span class="number">1ll</span> * f[i - <span class="number">1</span>][k] * C[k][b] % mod * C[l + <span class="number">1</span> - k][a] % mod * C[z[i] - <span class="number">1</span>][a + b - <span class="number">1</span>] % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    l += z[i];</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; f[N][<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="P-うなぎ"><a href="#P-うなぎ" class="headerlink" title="P - うなぎ"></a>P - うなぎ</h3><h4 id="problem-16"><a href="#problem-16" class="headerlink" title="problem"></a>problem</h4><p>有一棵 $N \ (1 \le N \le 1000)$ 个点的树，第 $i$ 条边连接 $a_i$ 和 $b_i$。求出有多少种方案能够选出包含 $K \ (1 \le K \le 50)$ 条互不相交的路径的集合。注意集合是无序的。</p>
<p>此处两条路径不相交定义为两条路径的点集的交集为端点的并集的子集。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">fa_555</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.fa555.tech/2020/%E6%9F%90At%E7%9A%84dp%E5%9C%BA/">https://blog.fa555.tech/2020/%E6%9F%90At%E7%9A%84dp%E5%9C%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.fa555.tech">fa_555's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/2020-Apr-Records/"><i class="fa fa-chevron-left">  </i><span>2020 Apr Records</span></a></div><div class="next-post pull-right"><a href="/2020/2020-Mar-Records/"><span>2020 Mar Records</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"></div></div></div><footer class="footer-bg" style="background-image: url(/files/topimg/johannes-plenio-E-Zuyev2XWo-unsplash.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2024 By fa_555</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>